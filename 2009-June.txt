From vafa at mail.berlios.de  Mon Jun  1 03:40:29 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Mon, 1 Jun 2009 03:40:29 +0200
Subject: [Xepersian-development] r44 - trunk
Message-ID: <200906010140.n511eT6k028447@sheep.berlios.de>

Author: vafa
Date: 2009-06-01 03:40:24 +0200 (Mon, 01 Jun 2009)
New Revision: 44

Modified:
   trunk/xepersian.dtx
Log:
fixed the issue of wrong footnote rule when \LTRfootnote is inserted in some pages

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-05-31 15:29:39 UTC (rev 43)
+++ trunk/xepersian.dtx	2009-06-01 01:40:24 UTC (rev 44)
@@ -156,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 43}
+\def\xepersianrevision{revision 44}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -458,40 +458,34 @@
 % \fi
 % \part{footnote-bidi-xepersian.def}
 %    \begin{macrocode}
-\def\thefootnote{\if at RomanFootNum\latinfont{\@arabic\c at footnote}\else\@arabic\c at footnote\fi}
-\let\PersianFootNum=\NativeFootNum
-\long\def\@RTLfootnotetext#1{\insert\footins{%
-    \@RTLtrue
-    \reset at font\footnotesize
+\long\def\@RTLfootnotetext#1{%
+    \begingroup
+    \setbox\footins
+    \vbox{\@RTLtrue\reset at font\footnotesize
     \interlinepenalty\interfootnotelinepenalty
     \splittopskip\footnotesep
     \splitmaxdepth \dp\strutbox \floatingpenalty \@MM
     \hsize\columnwidth \@parboxrestore
-    \protected at edef\@currentlabel{%
-       \csname p at footnote\endcsname\@thefnmark
-    }%
-    \color at begingroup
     \bidi at footnotetext@dir{#1}%
-      \@makefntext{%
-        \rule\z@\footnotesep\ignorespaces\persianfont#1\@finalstrut\strutbox}%
-    \bidi at footnotetext@after
-    \color at endgroup}}%
-\long\def\@LTRfootnotetext#1{\insert\footins{%
-    \@RTLfalse
-    \reset at font\footnotesize
+    \edef\@currentlabel{\csname p at footnote\endcsname\@thefnmark}\@makefntext
+    {\rule{\z@}{\footnotesep}\ignorespaces\persianfont #1\strut}}%
+     \bidi at footnotetext@after
+    \insert\footins{\unvbox\footins}%
+    \endgroup}
+\long\def\@LTRfootnotetext#1{%
+    \begingroup
+    \setbox\footins
+    \vbox{\@RTLfalse\reset at font\footnotesize
     \interlinepenalty\interfootnotelinepenalty
     \splittopskip\footnotesep
     \splitmaxdepth \dp\strutbox \floatingpenalty \@MM
     \hsize\columnwidth \@parboxrestore
-    \protected at edef\@currentlabel{%
-       \csname p at footnote\endcsname\@thefnmark
-    }%
-    \color at begingroup
     \bidi at footnotetext@dir{#1}%
-      \@makefntext{%
-        \rule\z@\footnotesep\ignorespaces\latinfont#1\@finalstrut\strutbox}%
-    \bidi at footnotetext@after
-    \color at endgroup}}%
+    \edef\@currentlabel{\csname p at footnote\endcsname\@thefnmark}\@makefntext
+    {\rule{\z@}{\footnotesep}\ignorespaces\latinfont #1\strut}}%
+     \bidi at footnotetext@after
+    \insert\footins{\unvbox\footins}%
+    \endgroup}
 \long\def\@mpRTLfootnotetext#1{
   \global\setbox\@mpfootins\vbox{\@RTLtrue
     \unvbox\@mpfootins



From vafa at mail.berlios.de  Tue Jun  2 08:43:32 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 2 Jun 2009 08:43:32 +0200
Subject: [Xepersian-development] r45 - trunk
Message-ID: <200906020643.n526hWlG019945@sheep.berlios.de>

Author: vafa
Date: 2009-06-02 08:43:27 +0200 (Tue, 02 Jun 2009)
New Revision: 45

Modified:
   trunk/xepersian.dtx
Log:
new macros are added such that if the user loads xunicode package before xepersian package, he will get an error saying Package  xunicode must be loaded after xepersian package

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-01 01:40:24 UTC (rev 44)
+++ trunk/xepersian.dtx	2009-06-02 06:43:27 UTC (rev 45)
@@ -156,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 44}
+\def\xepersianrevision{revision 45}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -167,6 +167,19 @@
 \DeclareOption{localise}{\input{localise-xepersian.def}}
 \DeclareOption*{\PassOptionsToPackage{\CurrentOption}{bidi}}
 \ProcessOptions\relax
+\newcommand\xepersian at isloaded[2][]{
+  \expandafter\ifx\csname if at xepersian@#2loaded@\endcsname\relax
+    \expandafter\newif\csname if at xepersian@#2loaded@\endcsname
+  \fi
+  \@ifpackageloaded{#2}
+    {\csname @xepersian@#2loaded at true\endcsname #1}
+    {\csname @xepersian@#2loaded at false\endcsname}}
+\xepersian at isloaded{xunicode}
+\AtBeginDocument{
+  \if at xepersian@xunicodeloaded@
+    \xepersian at isloaded[\PackageError{xepersian}{Package xunicode must be loaded after xepersian package}{}]{xunicode}
+  \fi%
+}
 \RequirePackage[RTLdocument]{bidi}
 \RequirePackage{fontspec}
 \RequirePackage{xepersian-persiancal}



From vafa at mail.berlios.de  Tue Jun  2 09:55:31 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 2 Jun 2009 09:55:31 +0200
Subject: [Xepersian-development] r46 - trunk
Message-ID: <200906020755.n527tVjV016147@sheep.berlios.de>

Author: vafa
Date: 2009-06-02 09:55:27 +0200 (Tue, 02 Jun 2009)
New Revision: 46

Modified:
   trunk/xepersian.dtx
Log:
if user does not use \settextfont and \setlatintextfont he will get error and if  he does not use \setdigitfont he gets a warning

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-02 06:43:27 UTC (rev 45)
+++ trunk/xepersian.dtx	2009-06-02 07:55:27 UTC (rev 46)
@@ -156,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 45}
+\def\xepersianrevision{revision 46}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -180,6 +180,15 @@
     \xepersian at isloaded[\PackageError{xepersian}{Package xunicode must be loaded after xepersian package}{}]{xunicode}
   \fi%
 }
+\AtBeginDocument{\ifdefined\persianfont\relax\else%
+\PackageError{xepersian}{Oops! you have not specified any font for the main text of the document. Please specify a font for the main text of the document by using \settextfont\space CS, and then try to run xelatex on your document again}%
+\fi}
+\AtBeginDocument{\ifdefined\latinfont\relax\else%
+\PackageError{xepersian}{Oops! you have not specified any font for the Latin texts of the document. Please specify a font for the Latin texts of the document by using \setlatintextfont\space CS, and then try to run xelatex on your document again}%
+\fi}
+\AtBeginDocument{\ifdefined\decimalseparator\relax\else%
+\PackageWarning{xepersian}{You have not specified any font for the digits in maths mode and so the digits in maths mode will appear Latin. If you would like to have Persian digits in maths mode, then please specify a font for the digits in maths mode by using \setdigitfont\space CS, and then try to run xelatex on your document again}%
+\fi}
 \RequirePackage[RTLdocument]{bidi}
 \RequirePackage{fontspec}
 \RequirePackage{xepersian-persiancal}



From vafa at mail.berlios.de  Tue Jun  2 11:02:25 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 2 Jun 2009 11:02:25 +0200
Subject: [Xepersian-development] r47 - trunk
Message-ID: <200906020902.n5292Pin026999@sheep.berlios.de>

Author: vafa
Date: 2009-06-02 11:02:21 +0200 (Tue, 02 Jun 2009)
New Revision: 47

Modified:
   trunk/xepersian.dtx
Log:
fixed the issue of enumlabel inside latin and persian environments

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-02 07:55:27 UTC (rev 46)
+++ trunk/xepersian.dtx	2009-06-02 09:02:21 UTC (rev 47)
@@ -156,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 46}
+\def\xepersianrevision{revision 47}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -187,7 +187,7 @@
 \PackageError{xepersian}{Oops! you have not specified any font for the Latin texts of the document. Please specify a font for the Latin texts of the document by using \setlatintextfont\space CS, and then try to run xelatex on your document again}%
 \fi}
 \AtBeginDocument{\ifdefined\decimalseparator\relax\else%
-\PackageWarning{xepersian}{You have not specified any font for the digits in maths mode and so the digits in maths mode will appear Latin. If you would like to have Persian digits in maths mode, then please specify a font for the digits in maths mode by using \setdigitfont\space CS, and then try to run xelatex on your document again}%
+\PackageWarning{xepersian}{?You have not specified any font for the digits in maths mode and so the digits in maths mode will appear Latin. If you would like to have Persian digits in maths mode, then please specify a font for the digits in maths mode by using \setdigitfont\space CS, and then try to run xelatex on your document again?}%
 \fi}
 \RequirePackage[RTLdocument]{bidi}
 \RequirePackage{fontspec}
@@ -200,7 +200,7 @@
    }{%
       XePersian Error: #1%
    }{%
-      Please first produce a similar file without using XePersian package and then compile it with xelatex, if you got the same error, then please study the Persian translation of 'The not so Short Introduction to LaTeX' by MEHDI OMIDALI, otherwise please report the error with a minimal tex file which shows the error to  the Author of XePersian.%
+      Please first produce a similar file without using XePersian package and then compile it with xelatex, if you got the same error, then please study the Persian translation of ?The not so Short Introduction to LaTeX? by MEHDI OMIDALI, otherwise please report the error with a minimal tex file which shows the error to  the Author of XePersian.%
    }{#2}%
 }
 \gdef\@latexbug{%
@@ -236,12 +236,12 @@
   \@tempa}
 \def\lr#1{\begingroup\beginL\latinfont#1\endL\endgroup}
 \def\rl#1{\begingroup\beginR\persianfont#1\endR\endgroup}
-\def\latin{\bgroup\par\@RTLfalse\latinfont}
+\def\latin{\bgroup\LatinAlphs\par\@RTLfalse\latinfont}
 \def\endlatin{\par\egroup}
-\def\persian{\bgroup\par\@RTLtrue\persianfont}
+\def\persian{\bgroup\PersianAlphs\par\@RTLtrue\persianfont}
 \def\endpersian{\par\egroup}
-\def\Latin{\if at RTL\par\@RTLfalse\latinfont\fi}
-\def\Persian{\if at RTL\relax\else\par\@RTLtrue\persianfont\fi}
+\def\Latin{\if at RTL\par\LatinAlphs\@RTLfalse\latinfont\fi}
+\def\Persian{\if at RTL\relax\else\par\PersianAlphs\@RTLtrue\persianfont\fi}
 \let\originaltoday=\today
 \def\today{\lr{\originaltoday}}
 \let\latintoday\today
@@ -321,10 +321,17 @@
   \ifcase#1\or ?\fi
   \ifnum#1=\z@\fi\abj at num@iii}
 }
-\let\@latinalph\@alph%
+   \let\@latinalph\@alph%
    \let\@latinAlph\@Alph%
+\def\PersianAlphs{%
    \let\@alph\abjad%
    \let\@Alph\abjad%
+}
+\def\LatinAlphs{%
+   \let\@alph\@latinalph%
+   \let\@Alph\@latinAlph%
+}
+\PersianAlphs
 \@ifpackageloaded{listings}{\input{listings-xepersian.def}}{}
 \@ifpackageloaded{algorithmic}{\input{algorithmic-xepersian.def}}{}
 \@ifpackageloaded{algorithm}{\input{algorithm-xepersian.def}}{}
@@ -412,9 +419,9 @@
 % \part{beamer-xepersian.def}
 %    \begin{macrocode}
 \def\familydefault{\rmdefault}
-\def\latin{\bgroup\par\raggedright\@RTLfalse\latinfont}
+\def\latin{\bgroup\LatinAlphs\par\raggedright\@RTLfalse\latinfont}
 \def\endlatin{\par\egroup}
-\def\persian{\bgroup\par\raggedleft\@RTLtrue\persianfont}
+\def\persian{\bgroup\PersianAlphs\par\raggedleft\@RTLtrue\persianfont}
 \def\endpersian{\par\egroup}
 \def\biditheoremname{????}
 \def\bidicorollaryname{?????}



From vafa at mail.berlios.de  Tue Jun  2 17:36:27 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 2 Jun 2009 17:36:27 +0200
Subject: [Xepersian-development] r48 - trunk
Message-ID: <200906021536.n52FaRQM024811@sheep.berlios.de>

Author: vafa
Date: 2009-06-02 17:36:20 +0200 (Tue, 02 Jun 2009)
New Revision: 48

Modified:
   trunk/xepersian.dtx
Log:
added font extensions

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-02 09:02:21 UTC (rev 47)
+++ trunk/xepersian.dtx	2009-06-02 15:36:20 UTC (rev 48)
@@ -156,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 47}
+\def\xepersianrevision{revision 48}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -234,6 +234,51 @@
     \noexpand\DeclareRobustCommand\noexpand#1
       {\noexpand\fontfamily{\zf at family}\noexpand\selectfont}}%
   \@tempa}
+\newcommand\persiansfdefault{}
+\newcommand\persianttdefault{}
+\newcommand\navardefault{}
+\newcommand\pookdefault{}
+\newcommand\sayehdefault{}
+\DeclareRobustCommand\persiansffamily
+        {\not at math@alphabet\persiansffamily\mathpersiansf
+         \fontfamily\persiansfdefault\selectfont}
+\DeclareRobustCommand\persianttfamily
+        {\not at math@alphabet\persianttfamily\mathpersiantt
+         \fontfamily\persianttdefault\selectfont}
+\DeclareRobustCommand\navarfamily
+        {\not at math@alphabet\navarfamily\mathnavar
+         \fontfamily\navardefault\selectfont}
+\DeclareRobustCommand\pookfamily
+        {\not at math@alphabet\pookfamily\mathpook
+         \fontfamily\pookdefault\selectfont}
+\DeclareRobustCommand\sayehfamily
+        {\not at math@alphabet\sayehfamily\mathsayeh
+         \fontfamily\sayehdefault\selectfont}
+\DeclareTextFontCommand{\textpersiansf}{\persiansffamily}
+\DeclareTextFontCommand{\textpersiantt}{\persianttfamily}
+\DeclareTextFontCommand{\textnavar}{\navarfamily}
+\DeclareTextFontCommand{\textpook}{\pookfamily}
+\DeclareTextFontCommand{\textsayeh}{\sayehfamily}
+\newcommand*\setpersiansansfont[2][]{%
+  \zf at fontspec{Script=Persian,Mapping=parsidigits,#1}{#2}%
+  \let\persiansfdefault\zf at family
+  \normalfont}
+\newcommand*\setpersianmonofont[2][]{%
+  \zf at fontspec{Script=Persian,Mapping=parsidigits,#1}{#2}%
+  \let\persianttdefault\zf at family
+  \normalfont}
+\newcommand*\setnavarfont[2][]{%
+  \zf at fontspec{Script=Persian,Mapping=parsidigits,#1}{#2}%
+  \let\navardefault\zf at family
+  \normalfont}
+\newcommand*\setpookfont[2][]{%
+  \zf at fontspec{Script=Persian,Mapping=parsidigits,#1}{#2}%
+  \let\pookdefault\zf at family
+  \normalfont}
+\newcommand*\setsayehfont[2][]{%
+  \zf at fontspec{Script=Persian,Mapping=parsidigits,#1}{#2}%
+  \let\sayehdefault\zf at family
+  \normalfont}
 \def\lr#1{\begingroup\beginL\latinfont#1\endL\endgroup}
 \def\rl#1{\begingroup\beginR\persianfont#1\endR\endgroup}
 \def\latin{\bgroup\LatinAlphs\par\@RTLfalse\latinfont}



From vafa at mail.berlios.de  Tue Jun  2 19:02:00 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 2 Jun 2009 19:02:00 +0200
Subject: [Xepersian-development] r49 - trunk
Message-ID: <200906021702.n52H20d6028827@sheep.berlios.de>

Author: vafa
Date: 2009-06-02 19:01:51 +0200 (Tue, 02 Jun 2009)
New Revision: 49

Modified:
   trunk/xepersian.dtx
Log:
small change in error messages

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-02 15:36:20 UTC (rev 48)
+++ trunk/xepersian.dtx	2009-06-02 17:01:51 UTC (rev 49)
@@ -156,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 48}
+\def\xepersianrevision{revision 49}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -177,7 +177,7 @@
 \xepersian at isloaded{xunicode}
 \AtBeginDocument{
   \if at xepersian@xunicodeloaded@
-    \xepersian at isloaded[\PackageError{xepersian}{Package xunicode must be loaded after xepersian package}{}]{xunicode}
+    \xepersian at isloaded[\PackageError{xepersian}{Oops! you have loaded package xunicode before xepersian package. Please load package xunicode after xepersian package, and then try to run xelatex on your document again}{}]{xunicode}
   \fi%
 }
 \AtBeginDocument{\ifdefined\persianfont\relax\else%
@@ -200,7 +200,7 @@
    }{%
       XePersian Error: #1%
    }{%
-      Please first produce a similar file without using XePersian package and then compile it with xelatex, if you got the same error, then please study the Persian translation of ?The not so Short Introduction to LaTeX? by MEHDI OMIDALI, otherwise please report the error with a minimal tex file which shows the error to  the Author of XePersian.%
+      Oops! either you have done something wrong or it is a xepersian bug. Please first produce a similar file without using XePersian package and then compile it with xelatex, if you got the same error, then please study the Persian translation of ?The not so Short Introduction to LaTeX? by MEHDI OMIDALI, otherwise please report the error with a minimal tex file which shows the error to  the Author of XePersian.%
    }{#2}%
 }
 \gdef\@latexbug{%



From vafa at mail.berlios.de  Wed Jun  3 12:53:52 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Wed, 3 Jun 2009 12:53:52 +0200
Subject: [Xepersian-development] r50 - trunk
Message-ID: <200906031053.n53Arqtj013258@sheep.berlios.de>

Author: vafa
Date: 2009-06-03 12:53:42 +0200 (Wed, 03 Jun 2009)
New Revision: 50

Modified:
   trunk/xepersian.dtx
Log:
some small adjustments

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-02 17:01:51 UTC (rev 49)
+++ trunk/xepersian.dtx	2009-06-03 10:53:42 UTC (rev 50)
@@ -156,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 49}
+\def\xepersianrevision{revision 50}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -281,12 +281,12 @@
   \normalfont}
 \def\lr#1{\begingroup\beginL\latinfont#1\endL\endgroup}
 \def\rl#1{\begingroup\beginR\persianfont#1\endR\endgroup}
-\def\latin{\bgroup\LatinAlphs\par\@RTLfalse\latinfont}
+\def\latin{\bgroup\LatinAlphs\par\@RTLfalse\@RTL at footnotefalse\latinfont}
 \def\endlatin{\par\egroup}
-\def\persian{\bgroup\PersianAlphs\par\@RTLtrue\persianfont}
+\def\persian{\bgroup\PersianAlphs\par\@RTLtrue\@RTL at footnotetrue\persianfont}
 \def\endpersian{\par\egroup}
-\def\Latin{\if at RTL\par\LatinAlphs\@RTLfalse\latinfont\fi}
-\def\Persian{\if at RTL\relax\else\par\PersianAlphs\@RTLtrue\persianfont\fi}
+\def\Latin{\if at RTL\par\LatinAlphs\@RTLfalse\@RTL at footnotefalse\latinfont\fi}
+\def\Persian{\if at RTL\relax\else\par\PersianAlphs\@RTLtrue\@RTL at footnotetrue\persianfont\fi}
 \let\originaltoday=\today
 \def\today{\lr{\originaltoday}}
 \let\latintoday\today
@@ -464,9 +464,9 @@
 % \part{beamer-xepersian.def}
 %    \begin{macrocode}
 \def\familydefault{\rmdefault}
-\def\latin{\bgroup\LatinAlphs\par\raggedright\@RTLfalse\latinfont}
+\def\latin{\bgroup\LatinAlphs\par\raggedright\@RTLfalse\@RTL at footnotefalse\latinfont}
 \def\endlatin{\par\egroup}
-\def\persian{\bgroup\PersianAlphs\par\raggedleft\@RTLtrue\persianfont}
+\def\persian{\bgroup\PersianAlphs\par\raggedleft\@RTLtrue\@RTL at footnotetrue\persianfont}
 \def\endpersian{\par\egroup}
 \def\biditheoremname{????}
 \def\bidicorollaryname{?????}
@@ -532,6 +532,20 @@
 % \fi
 % \part{footnote-bidi-xepersian.def}
 %    \begin{macrocode}
+\long\def\@footnotetext#1{%
+    \begingroup
+    \setbox\footins
+    \vbox{\if at RTL@footnote\@RTLtrue\else\@RTLfalse\fi\reset at font\footnotesize
+    \interlinepenalty\interfootnotelinepenalty
+    \splittopskip\footnotesep
+    \splitmaxdepth \dp\strutbox \floatingpenalty \@MM
+    \hsize\columnwidth \@parboxrestore
+    \bidi at footnotetext@dir{#1}%
+    \edef\@currentlabel{\csname p at footnote\endcsname\@thefnmark}\@makefntext
+    {\rule{\z@}{\footnotesep}\ignorespaces\if at RTL@footnote#1\else\latinfont#1\fi\strut}}%
+     \bidi at footnotetext@after
+    \insert\footins{\unvbox\footins}%
+    \endgroup}
 \long\def\@RTLfootnotetext#1{%
     \begingroup
     \setbox\footins
@@ -560,6 +574,20 @@
      \bidi at footnotetext@after
     \insert\footins{\unvbox\footins}%
     \endgroup}
+\long\def\@mpfootnotetext#1{
+  \global\setbox\@mpfootins\vbox{\if at RTL@footnote\@RTLtrue\else\@RTLfalse\fi
+    \unvbox\@mpfootins
+    \reset at font\footnotesize
+    \hsize\columnwidth
+    \@parboxrestore
+    \protected at edef\@currentlabel
+         {\csname p at mpfootnote\endcsname\@thefnmark}
+    \color at begingroup
+     \bidi at footnotetext@dir{#1}
+    \if at RTL\global\let\bidi at footnoterule\right at footnote\else\global\let\bidi at footnoterule\left at footnote\fi
+      \@makefntext{
+        \rule\z@\footnotesep\ignorespaces\if at RTL@footnote#1\else\latinfont#1\fi\@finalstrut\strutbox}
+    \color at endgroup}}
 \long\def\@mpRTLfootnotetext#1{
   \global\setbox\@mpfootins\vbox{\@RTLtrue
     \unvbox\@mpfootins



From vafa at mail.berlios.de  Thu Jun  4 13:08:32 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Thu, 4 Jun 2009 13:08:32 +0200
Subject: [Xepersian-development] r51 - trunk
Message-ID: <200906041108.n54B8WZ3030956@sheep.berlios.de>

Author: vafa
Date: 2009-06-04 13:08:24 +0200 (Thu, 04 Jun 2009)
New Revision: 51

Modified:
   trunk/xepersian.dtx
Log:
changed \edef to \protected at edef in the implemenation of fotnote so that buggy polygllosia does not produce 'TeX Capacity exceeded'

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-03 10:53:42 UTC (rev 50)
+++ trunk/xepersian.dtx	2009-06-04 11:08:24 UTC (rev 51)
@@ -156,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 50}
+\def\xepersianrevision{revision 51}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -541,7 +541,7 @@
     \splitmaxdepth \dp\strutbox \floatingpenalty \@MM
     \hsize\columnwidth \@parboxrestore
     \bidi at footnotetext@dir{#1}%
-    \edef\@currentlabel{\csname p at footnote\endcsname\@thefnmark}\@makefntext
+    \protected at edef\@currentlabel{\csname p at footnote\endcsname\@thefnmark}\@makefntext
     {\rule{\z@}{\footnotesep}\ignorespaces\if at RTL@footnote#1\else\latinfont#1\fi\strut}}%
      \bidi at footnotetext@after
     \insert\footins{\unvbox\footins}%
@@ -555,7 +555,7 @@
     \splitmaxdepth \dp\strutbox \floatingpenalty \@MM
     \hsize\columnwidth \@parboxrestore
     \bidi at footnotetext@dir{#1}%
-    \edef\@currentlabel{\csname p at footnote\endcsname\@thefnmark}\@makefntext
+    \protected at edef\@currentlabel{\csname p at footnote\endcsname\@thefnmark}\@makefntext
     {\rule{\z@}{\footnotesep}\ignorespaces\persianfont #1\strut}}%
      \bidi at footnotetext@after
     \insert\footins{\unvbox\footins}%
@@ -569,7 +569,7 @@
     \splitmaxdepth \dp\strutbox \floatingpenalty \@MM
     \hsize\columnwidth \@parboxrestore
     \bidi at footnotetext@dir{#1}%
-    \edef\@currentlabel{\csname p at footnote\endcsname\@thefnmark}\@makefntext
+    \protected at edef\@currentlabel{\csname p at footnote\endcsname\@thefnmark}\@makefntext
     {\rule{\z@}{\footnotesep}\ignorespaces\latinfont #1\strut}}%
      \bidi at footnotetext@after
     \insert\footins{\unvbox\footins}%



From vafa at mail.berlios.de  Thu Jun  4 13:19:44 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Thu, 4 Jun 2009 13:19:44 +0200
Subject: [Xepersian-development] r52 - trunk
Message-ID: <200906041119.n54BJhnZ010914@sheep.berlios.de>

Author: vafa
Date: 2009-06-04 13:19:38 +0200 (Thu, 04 Jun 2009)
New Revision: 52

Modified:
   trunk/xepersian.dtx
Log:
docinfo has to be done after loading bidi package

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-04 11:08:24 UTC (rev 51)
+++ trunk/xepersian.dtx	2009-06-04 11:19:38 UTC (rev 52)
@@ -160,9 +160,6 @@
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
-\AtBeginDocument{\special{pdf: docinfo <<
-	/Creator (X?Persian \xepersianversion\space <\xepersianrevision> Copyright ? 2008-2009 Vafa Khalighi)
-         >>}}
 \DeclareOption{Kashida}{\input{kashida-xepersian.def}}
 \DeclareOption{localise}{\input{localise-xepersian.def}}
 \DeclareOption*{\PassOptionsToPackage{\CurrentOption}{bidi}}
@@ -194,6 +191,9 @@
 \RequirePackage{xepersian-persiancal}
 \RequirePackage{xepersian-mathsdigitspec}
 \RequirePackage{etoolbox}
+\AtBeginDocument{\special{pdf: docinfo <<
+	/Creator (X?Persian \xepersianversion\space <\xepersianrevision> Copyright ? 2008-2009 Vafa Khalighi)
+         >>}}
 \gdef\@latex at error#1#2{%
    \GenericError{%
       \space\space\space\@spaces\@spaces\@spaces



From vafa at mail.berlios.de  Fri Jun  5 16:43:35 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Fri, 5 Jun 2009 16:43:35 +0200
Subject: [Xepersian-development] r53 - trunk
Message-ID: <200906051443.n55EhZJe008912@sheep.berlios.de>

Author: vafa
Date: 2009-06-05 16:43:28 +0200 (Fri, 05 Jun 2009)
New Revision: 53

Added:
   trunk/ftxe-0.1.py
Modified:
   trunk/xepersian.dtx
Log:
the farsitex to unicode converter generates error if it is generated via docstrip

Added: trunk/ftxe-0.1.py
===================================================================
--- trunk/ftxe-0.1.py	2009-06-04 11:19:38 UTC (rev 52)
+++ trunk/ftxe-0.1.py	2009-06-05 14:43:28 UTC (rev 53)
@@ -0,0 +1,490 @@
+#########################################
+#       General Public License          #
+#       Author:  Mostafa Vahedi         #
+#       Date:    21 May 2009            #
+#       Version  0.1                    #
+#########################################
+
+import codecs
+
+import sys
+
+
+ft_numerical = [
+chr(0xB9),	# 	Arabic Thoushads Seperator
+chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
+]
+
+
+ft_vowels = [
+chr(0xB0),	#	ARABIC FATHA
+chr(0xB1),	#	ARABIC KASRA
+chr(0xB2),	#	ARABIC DAMMA
+chr(0xB3),	#	ARABIC FATHATAN
+chr(0xB4),	#	ARABIC SHADDA
+chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB),	#	ARABIC HAMZA ABOVE
+chr(0xC4) 	#	ARABIC SUKUN
+]
+
+ft_non_joiners = [
+chr(0x8F)	#	ARABIC LETTER HAMZA
+]
+
+ft_bidi_joiners_initial = [
+chr(0xE4),	#	ARABIC LETTER AIN, initial form
+chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
+chr(0xFB) 	#	ARABIC LETTER HEH, initial form
+]
+
+ft_bidi_joiners_medial = [
+chr(0xE3),	#	ARABIC LETTER AIN, medial form
+chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
+chr(0xFA) 	#	ARABIC LETTER HEH, medial form
+]
+
+ft_bidi_joiners_final = [
+chr(0xE2),	#	ARABIC LETTER AIN, final form
+chr(0xE6),	#	ARABIC LETTER GHAIN, final form
+chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
+]
+
+ft_bidi_joiners_isolated = [
+chr(0xE1),	#	ARABIC LETTER AIN, isolated form
+chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
+chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
+]
+
+ft_bidi_joiners_initial_medial = [
+chr(0x8B),	#	ARABIC TATWEEL
+chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
+chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
+chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
+chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
+chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
+chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
+chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
+]
+
+ft_bidi_joiners_final_isolated = [
+chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
+chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
+chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
+chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
+chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
+chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
+chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
+chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
+]
+
+ft_right_joiners_final = [
+chr(0x91)	#	ARABIC LETTER ALEF, final form
+]
+
+ft_right_joiners_isolated = [
+chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x90)	#	ARABIC LETTER ALEF, isolated form
+]
+
+ft_right_joiners_final_isolated = [
+chr(0xA2),	#	ARABIC LETTER DAL
+chr(0xA3),	#	ARABIC LETTER THAL
+chr(0xA4),	#	ARABIC LETTER REH
+chr(0xA5),	#	ARABIC LETTER ZAIN
+chr(0xA6),	#	ARABIC LETTER JEH
+chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
+chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF8)	#	ARABIC LETTER WAW
+]
+
+
+table_FT_UN = {
+chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
+chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
+chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
+chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
+chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
+chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
+chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
+chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
+chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
+chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
+chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
+chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
+chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
+chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
+chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
+chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
+chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
+chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
+chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
+chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
+chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
+chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
+chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
+chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
+chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
+chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
+chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
+chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
+chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
+chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
+chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
+chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
+chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
+chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
+chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
+chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
+chr(0xB5) : [u'\u0023'],	# * #
+chr(0xB6) : [u'\u0024'],	# * $
+chr(0xB7) : [u'\u0025'],	# * %
+chr(0xB8) : [u'\u0026'],	# * &
+chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
+chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
+chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
+chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
+chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
+chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
+chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
+chr(0xC5) : [u'\u002D'],	# * -
+chr(0xC6) : [u'\u002E'],	# * FULL STOP
+chr(0xC7) : [u'\u002F'],	# * /
+chr(0xC8) : [u'\u002A'],	# * *
+chr(0xC9) : [u'\u007E'],	# * ~
+chr(0xCA) : [u'\u003A'],	# * COLON
+chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
+chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
+chr(0xCD) : [u'\u002B'],	# * +
+chr(0xCE) : [u'\u003D'],	# * =
+chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
+# chr(0xD0) : [u'\u0040'],	# * @
+chr(0xD0) : [u''],	        # * @
+chr(0xD1) : [u'\u005D'],	# * [
+chr(0xD2) : [u'\u005C'],	# * \
+chr(0xD3) : [u'\u005B'],	# * ]
+chr(0xD4) : [u'\u005E'],	# * ^
+chr(0xD5) : [u'\u005F'],	# * _
+chr(0xD6) : [u'\u0060'],	# * `
+chr(0xD7) : [u'\u007D'],	# * {
+chr(0xD8) : [u'\u007C'],	# * |
+chr(0xDA) : [u'\u0020'],	# * SPACE
+chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
+chr(0xDE) : [u'\u007B'],	# * }
+chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
+chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
+chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
+chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
+chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
+chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
+chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
+chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
+chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
+chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
+chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
+chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
+chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
+chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
+chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
+chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
+chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
+chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
+}
+
+F_SLASH = chr(0xD2)
+F_PRNT_OPEN = chr(0xDE)
+F_AT_SIGN = chr(0xD0)
+
+# latex and farsitex commands whose first parameter does not need \lr{...}
+commands = [ "begin", 
+"end",
+"input", "include", "includeonly",
+"hspace", "vspace", "hspace*", "vspace*",
+"label", "ref", "cite",
+"bibliographystyle",
+"parbox",
+"newenvironment", "newtheorem",
+"persianmathdigitsfamily",
+"fontfamily", "fontseries", "fontshape",
+"rmdefault", "sfdefault", "ttdefault",
+"bfdefault", "itdefault", "sldefault", "scdefault",
+"pagenumbering", "pagestyle", "thispagestyle",
+"setcounter", "stepcounter", "setlength", "addtolength"
+]
+
+
+def ft_is_numeric(ch):
+	if ((ch in ft_numerical) or 
+	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
+		return 1
+	return 0
+
+def ft_can_join_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_final) or
+	    (ch in ft_bidi_joiners_isolated) or
+	    (ch in ft_bidi_joiners_initial_medial) or
+	    (ch in ft_bidi_joiners_final_isolated)):
+    		return 1
+	return 0
+
+def ft_can_join_right(ch):
+	if (ft_can_join_left(ch) or 
+	    (ch in ft_right_joiners_final) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_right_joiners_final_isolated)):
+		return 1
+	return 0
+
+def ft_joining_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or 
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_initial_medial)):
+		return 1
+	return 0
+
+
+def ft_joining_right(ch):
+	if ((ch in ft_right_joiners_final) or
+	    (ch in ft_bidi_joiners_medial) or 
+	    (ch in ft_bidi_joiners_final)):
+		return 1
+	return 0
+
+def ft_not_right_joined(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_bidi_joiners_isolated)):
+		return 1
+	return 0
+
+def ft_adjust_shaping(text, i):
+	current = text[i]
+	u = u''
+	try:
+		u = table_FT_UN[current][0]
+	except KeyError:
+		return u''
+
+	#if you don't want shaping remove the following comment
+	#return u
+
+	if ((current in ft_vowels) or (ft_is_numeric(current))):
+		return u
+
+	#find next non-vowel character on the left
+	text_len = len(text)
+	next_index = i+1
+	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
+		next_index += 1
+
+	if (next_index == text_len):
+		next = ''
+	else:
+		next = text[next_index]
+
+	# if current letter is joining from left but next letter is or can not joining
+	if (ft_joining_left(current)):
+		if (not ft_can_join_right(next)):
+			u += u'\u200D' #ZWJ
+		elif (ft_not_right_joined(next)):
+			u += u'\u200D\u200C' #ZWJ+ZWNJ
+	# if current letter can join but next letter is joining from right
+	elif (ft_can_join_left(current)):
+		if (ft_joining_right(next)):
+			u += u'\u200C\u200D' #ZWNJ+ZWJ
+		elif (ft_can_join_right(next)):
+			u += u'\u200C' #ZWNJ
+	return u
+
+def ft_adjust_number(text):
+	result = u''
+	i = len(text)-1
+	while (i >= 0):
+		result += ft_adjust_shaping(text, i)
+		i -= 1
+	return result
+
+
+def map_ft_unicode(text):
+	mapped_text = u''
+
+	i = 0
+	while (i < len(text)):
+		if (ft_is_numeric(text[i])):
+			next_index = i
+			while ((next_index+1 < len(text)) and
+			       (ft_is_numeric(text[next_index+1]))):
+				next_index += 1
+			mapped_text += ft_adjust_number(text[i:next_index+1])
+			i = next_index+1
+			continue
+
+		mapped_text += ft_adjust_shaping(text, i)
+		i += 1
+	return mapped_text
+
+# Finds next token all of the same language
+def ft_next_part(line, i):
+	j = i
+	language_flag = (line[j]<chr(0x80))
+	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
+		j += 1
+	return j
+
+# Main body of the program 
+if len(sys.argv) <= 2:
+	print 'usage: python undk in_filename out_filename'
+	exit(0)
+
+###################################
+# Begin of main body of the program
+###################################
+filename = sys.argv[1]
+outfile = sys.argv[2]
+
+try:
+	f = open(filename, 'r')
+except IOError:
+	print "Can not open the input file: " + filename
+	exit(0)
+
+try:
+	of = codecs.open(outfile, encoding='utf-8', mode='w')
+except IOError:
+	print "Can not open the output file: " + outfile
+	exit(0)
+
+line_number = 0
+for line in f:
+	line_number += 1
+	output_line = u''
+	line_len = len(line)
+	
+	# remove new-line characters from end of line
+	if (line_len>1 and line[line_len-1] == '\n'):
+		line_len-=1
+	if (line_len>1 and line[line_len-1] == '\r'):
+		line_len-=1
+
+	# check line-direction character
+	line_direction_rtl = (line[0] == '<')
+	if (line[0] != '>') and (line[0] != '<'):
+		print "FORMAT ERROR AT LINE: " + str(line_number)
+		exit(0)
+
+	i = 1
+
+	while (i<line_len):
+		next_part_index = ft_next_part(line, i)
+		next_part = line[i:next_part_index]
+		next_part_latin = (line[i]<chr(0x80))
+		
+		# see if we should put \lr{...} for the current english expression
+		if line_direction_rtl and next_part_latin:
+			is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
+			is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
+			is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
+		
+			cmd_index = 0
+			while cmd_index < len(commands):
+				len_cmd = len(commands[cmd_index])+2
+				if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
+					break
+				cmd_index += 1
+			is_commands_group = cmd_index < len(commands)
+			is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
+
+		if next_part_latin:
+			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
+				output_line += u'\\lr{'
+			
+			output_line += next_part.encode( 'utf-8' )
+			
+			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
+				output_line += u'}'
+		else:
+			if ( not line_direction_rtl):
+				output_line += u'\\rl{'
+				
+			output_line += map_ft_unicode(next_part)
+			
+			if (not line_direction_rtl):
+				output_line += u'}'
+				
+		i = next_part_index
+	# end of while			
+	
+	# write the processed line
+	output_line += u'\n'
+	of.write(output_line)
+	# end of line processing
+# end of file processing
+
+of.close()
+f.close()	

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-04 11:19:38 UTC (rev 52)
+++ trunk/xepersian.dtx	2009-06-05 14:43:28 UTC (rev 53)
@@ -105,7 +105,6 @@
 \generate{\file{README.txt}{\from{xepersian.dtx}{readme}}}
 \generate{\file{parsidigits.map}{\from{xepersian.dtx}{parsidigits.map}}}
 \generate{\file{txt2maths.map}{\from{xepersian.dtx}{txt2maths.map}}}
-\generate{\file{ftxe-0.1.py}{\from{xepersian.dtx}{ftxe-0.1.py}}}
 \generate{\file{thesis-sample.tex}{\from{xepersian.dtx}{thesis-sample.tex}}}
 \generate{\file{magazine-sample.tex}{\from{xepersian.dtx}{magazine-sample.tex}}}
 \generate{\file{test-correction.tex}{\from{xepersian.dtx}{test-correction.tex}}}
@@ -8220,497 +8219,6 @@
 U+003C U+003C	<>	U+00AB	; << -> LEFT POINTING GUILLEMET
 U+003E U+003E	<>	U+00BB	; >> -> RIGHT POINTING GUILLEMET
 %</txt2maths.map>
-%<*ftxe-0.1.py>
-#########################################
-#       General Public License          #
-#       Author:  Mostafa Vahedi         #
-#       Date:    21 May 2009            #
-#       Version  0.1                    #
-#########################################
-
-import codecs
-
-import sys
-
-
-ft_numerical = [
-chr(0xB9),	# 	Arabic Thoushads Seperator
-chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
-]
-
-
-ft_vowels = [
-chr(0xB0),	#	ARABIC FATHA
-chr(0xB1),	#	ARABIC KASRA
-chr(0xB2),	#	ARABIC DAMMA
-chr(0xB3),	#	ARABIC FATHATAN
-chr(0xB4),	#	ARABIC SHADDA
-chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB),	#	ARABIC HAMZA ABOVE
-chr(0xC4) 	#	ARABIC SUKUN
-]
-
-ft_non_joiners = [
-chr(0x8F)	#	ARABIC LETTER HAMZA
-]
-
-ft_bidi_joiners_initial = [
-chr(0xE4),	#	ARABIC LETTER AIN, initial form
-chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
-chr(0xFB) 	#	ARABIC LETTER HEH, initial form
-]
-
-ft_bidi_joiners_medial = [
-chr(0xE3),	#	ARABIC LETTER AIN, medial form
-chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
-chr(0xFA) 	#	ARABIC LETTER HEH, medial form
-]
-
-ft_bidi_joiners_final = [
-chr(0xE2),	#	ARABIC LETTER AIN, final form
-chr(0xE6),	#	ARABIC LETTER GHAIN, final form
-chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
-]
-
-ft_bidi_joiners_isolated = [
-chr(0xE1),	#	ARABIC LETTER AIN, isolated form
-chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
-chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
-]
-
-ft_bidi_joiners_initial_medial = [
-chr(0x8B),	#	ARABIC TATWEEL
-chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
-chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
-chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
-chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
-chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
-chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
-chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
-]
-
-ft_bidi_joiners_final_isolated = [
-chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
-chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
-chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
-chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
-chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
-chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
-chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
-chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
-]
-
-ft_right_joiners_final = [
-chr(0x91)	#	ARABIC LETTER ALEF, final form
-]
-
-ft_right_joiners_isolated = [
-chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x90)	#	ARABIC LETTER ALEF, isolated form
-]
-
-ft_right_joiners_final_isolated = [
-chr(0xA2),	#	ARABIC LETTER DAL
-chr(0xA3),	#	ARABIC LETTER THAL
-chr(0xA4),	#	ARABIC LETTER REH
-chr(0xA5),	#	ARABIC LETTER ZAIN
-chr(0xA6),	#	ARABIC LETTER JEH
-chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
-chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF8)	#	ARABIC LETTER WAW
-]
-
-
-table_FT_UN = {
-chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
-chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
-chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
-chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
-chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
-chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
-chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
-chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
-chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
-chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
-chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
-chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
-chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
-chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
-chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
-chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
-chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
-chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
-chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
-chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
-chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
-chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
-chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
-chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
-chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
-chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
-chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
-chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
-chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
-chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
-chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
-chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
-chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
-chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
-chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
-chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
-chr(0xB5) : [u'\u0023'],	# * #
-chr(0xB6) : [u'\u0024'],	# * $
-chr(0xB7) : [u'\u0025'],	# * %
-chr(0xB8) : [u'\u0026'],	# * &
-chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
-chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
-chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
-chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
-chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
-chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
-chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
-chr(0xC5) : [u'\u002D'],	# * -
-chr(0xC6) : [u'\u002E'],	# * FULL STOP
-chr(0xC7) : [u'\u002F'],	# * /
-chr(0xC8) : [u'\u002A'],	# * *
-chr(0xC9) : [u'\u007E'],	# * ~
-chr(0xCA) : [u'\u003A'],	# * COLON
-chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
-chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
-chr(0xCD) : [u'\u002B'],	# * +
-chr(0xCE) : [u'\u003D'],	# * =
-chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
-# chr(0xD0) : [u'\u0040'],	# * @
-chr(0xD0) : [u''],	        # * @
-chr(0xD1) : [u'\u005D'],	# * [
-chr(0xD2) : [u'\u005C'],	# * \
-chr(0xD3) : [u'\u005B'],	# * ]
-chr(0xD4) : [u'\u005E'],	# * ^
-chr(0xD5) : [u'\u005F'],	# * _
-chr(0xD6) : [u'\u0060'],	# * `
-chr(0xD7) : [u'\u007D'],	# * {
-chr(0xD8) : [u'\u007C'],	# * |
-chr(0xDA) : [u'\u0020'],	# * SPACE
-chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
-chr(0xDE) : [u'\u007B'],	# * }
-chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
-chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
-chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
-chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
-chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
-chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
-chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
-chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
-chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
-chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
-chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
-chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
-chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
-chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
-chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
-chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
-chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
-chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
-}
-
-F_SLASH = chr(0xD2)
-F_PRNT_OPEN = chr(0xDE)
-F_AT_SIGN = chr(0xD0)
-
-# latex and farsitex commands whose first parameter does not need \lr{...}
-commands = [ "begin", 
-"end",
-"input", "include", "includeonly",
-"hspace", "vspace", "hspace*", "vspace*",
-"label", "ref", "cite",
-"bibliographystyle",
-"parbox",
-"newenvironment", "newtheorem",
-"persianmathdigitsfamily",
-"fontfamily", "fontseries", "fontshape",
-"rmdefault", "sfdefault", "ttdefault",
-"bfdefault", "itdefault", "sldefault", "scdefault",
-"pagenumbering", "pagestyle", "thispagestyle",
-"setcounter", "stepcounter", "setlength", "addtolength"
-]
-
-
-def ft_is_numeric(ch):
-	if ((ch in ft_numerical) or 
-	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
-		return 1
-	return 0
-
-def ft_can_join_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_final) or
-	    (ch in ft_bidi_joiners_isolated) or
-	    (ch in ft_bidi_joiners_initial_medial) or
-	    (ch in ft_bidi_joiners_final_isolated)):
-    		return 1
-	return 0
-
-def ft_can_join_right(ch):
-	if (ft_can_join_left(ch) or 
-	    (ch in ft_right_joiners_final) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_right_joiners_final_isolated)):
-		return 1
-	return 0
-
-def ft_joining_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or 
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_initial_medial)):
-		return 1
-	return 0
-
-
-def ft_joining_right(ch):
-	if ((ch in ft_right_joiners_final) or
-	    (ch in ft_bidi_joiners_medial) or 
-	    (ch in ft_bidi_joiners_final)):
-		return 1
-	return 0
-
-def ft_not_right_joined(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_bidi_joiners_isolated)):
-		return 1
-	return 0
-
-def ft_adjust_shaping(text, i):
-	current = text[i]
-	u = u''
-	try:
-		u = table_FT_UN[current][0]
-	except KeyError:
-		return u''
-
-	#if you don't want shaping remove the following comment
-	#return u
-
-	if ((current in ft_vowels) or (ft_is_numeric(current))):
-		return u
-
-	#find next non-vowel character on the left
-	text_len = len(text)
-	next_index = i+1
-	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
-		next_index += 1
-
-	if (next_index == text_len):
-		next = ''
-	else:
-		next = text[next_index]
-
-	# if current letter is joining from left but next letter is or can not joining
-	if (ft_joining_left(current)):
-		if (not ft_can_join_right(next)):
-			u += u'\u200D' #ZWJ
-		elif (ft_not_right_joined(next)):
-			u += u'\u200D\u200C' #ZWJ+ZWNJ
-	# if current letter can join but next letter is joining from right
-	elif (ft_can_join_left(current)):
-		if (ft_joining_right(next)):
-			u += u'\u200C\u200D' #ZWNJ+ZWJ
-		elif (ft_can_join_right(next)):
-			u += u'\u200C' #ZWNJ
-	return u
-
-def ft_adjust_number(text):
-	result = u''
-	i = len(text)-1
-	while (i >= 0):
-		result += ft_adjust_shaping(text, i)
-		i -= 1
-	return result
-
-
-def map_ft_unicode(text):
-	mapped_text = u''
-
-	i = 0
-	while (i < len(text)):
-		if (ft_is_numeric(text[i])):
-			next_index = i
-			while ((next_index+1 < len(text)) and
-			       (ft_is_numeric(text[next_index+1]))):
-				next_index += 1
-			mapped_text += ft_adjust_number(text[i:next_index+1])
-			i = next_index+1
-			continue
-
-		mapped_text += ft_adjust_shaping(text, i)
-		i += 1
-	return mapped_text
-
-# Finds next token all of the same language
-def ft_next_part(line, i):
-	j = i
-	language_flag = (line[j]<chr(0x80))
-	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
-		j += 1
-	return j
-
-# Main body of the program 
-if len(sys.argv) <= 2:
-	print 'usage: python undk in_filename out_filename'
-	exit(0)
-
-###################################
-# Begin of main body of the program
-###################################
-filename = sys.argv[1]
-outfile = sys.argv[2]
-
-try:
-	f = open(filename, 'r')
-except IOError:
-	print "Can not open the input file: " + filename
-	exit(0)
-
-try:
-	of = codecs.open(outfile, encoding='utf-8', mode='w')
-except IOError:
-	print "Can not open the output file: " + outfile
-	exit(0)
-
-line_number = 0
-for line in f:
-	line_number += 1
-	output_line = u''
-	line_len = len(line)
-	
-	# remove new-line characters from end of line
-	if (line_len>1 and line[line_len-1] == '\n'):
-		line_len-=1
-	if (line_len>1 and line[line_len-1] == '\r'):
-		line_len-=1
-
-	# check line-direction character
-	line_direction_rtl = (line[0] == '<')
-	if (line[0] != '>') and (line[0] != '<'):
-		print "FORMAT ERROR AT LINE: " + str(line_number)
-		exit(0)
-
-	i = 1
-
-	while (i<line_len):
-		next_part_index = ft_next_part(line, i)
-		next_part = line[i:next_part_index]
-		next_part_latin = (line[i]<chr(0x80))
-		
-		# see if we should put \lr{...} for the current english expression
-		if line_direction_rtl and next_part_latin:
-			is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
-			is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
-			is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
-		
-			cmd_index = 0
-			while cmd_index < len(commands):
-				len_cmd = len(commands[cmd_index])+2
-				if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
-					break
-				cmd_index += 1
-			is_commands_group = cmd_index < len(commands)
-			is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
-
-		if next_part_latin:
-			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
-				output_line += u'\\lr{'
-			
-			output_line += next_part.encode( 'utf-8' )
-			
-			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
-				output_line += u'}'
-		else:
-			if ( not line_direction_rtl):
-				output_line += u'\\rl{'
-				
-			output_line += map_ft_unicode(next_part)
-			
-			if (not line_direction_rtl):
-				output_line += u'}'
-				
-		i = next_part_index
-	# end of while			
-	
-	# write the processed line
-	output_line += u'\n'
-	of.write(output_line)
-	# end of line processing
-# end of file processing
-
-of.close()
-f.close()	
%</ftxe-0.1.py>
 %<*thesis-sample.tex>
 \documentclass[a4paper,11pt]{xepersian-thesis}
 \usepackage{graphicx}



From vafa at mail.berlios.de  Fri Jun  5 16:52:51 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Fri, 5 Jun 2009 16:52:51 +0200
Subject: [Xepersian-development] r54 - trunk
Message-ID: <200906051452.n55EqpAp009836@sheep.berlios.de>

Author: vafa
Date: 2009-06-05 16:52:46 +0200 (Fri, 05 Jun 2009)
New Revision: 54

Modified:
   trunk/xepersian.dtx
Log:
updated the txt2maths mapping file

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-05 14:43:28 UTC (rev 53)
+++ trunk/xepersian.dtx	2009-06-05 14:52:46 UTC (rev 54)
@@ -155,7 +155,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 51}
+\def\xepersianrevision{revision 54}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -8165,15 +8165,10 @@
 U+003E U+003E	<>	U+00BB	; >> -> RIGHT POINTING GUILLEMET
 %</parsidigits.map>
 %<*txt2maths.map>
-EncodingName "XePersian-2009"
-DescriptiveName "VAFA KHALIGHI"
-Version "0.1"
-Contact "mailto:vafa.khalighi at students.mq.edu.au"
-RegistrationAuthority "VAFA KHALIGHI"
-RegistrationName "CONVERSION OF TEXT CHARACTERS TO THEIR CORRESPONDING MATHS CHARACTERS"
-Copyright "(c)2009 VAFA KHALIGHI"
-LHSFlags ()
-RHSFlags (ExpectsNFD GeneratesNFD)
+; Vafa Khalighi ... 
+LHSName	"Digits"
+RHSName	"txt2maths"
+
 Pass(Unicode)
 U+002E <> U+066B ; convert dot to Persian decimal separator
 U+002D <> U+2212 ; convert hyphen to minus sign



From vafa at mail.berlios.de  Fri Jun  5 17:01:33 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Fri, 5 Jun 2009 17:01:33 +0200
Subject: [Xepersian-development] r55 - trunk
Message-ID: <200906051501.n55F1XmF010787@sheep.berlios.de>

Author: vafa
Date: 2009-06-05 17:01:28 +0200 (Fri, 05 Jun 2009)
New Revision: 55

Modified:
   trunk/xepersian.dtx
Log:
updated my email and the http address of XePersian

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-05 14:52:46 UTC (rev 54)
+++ trunk/xepersian.dtx	2009-06-05 15:01:28 UTC (rev 55)
@@ -155,7 +155,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 54}
+\def\xepersianrevision{revision 55}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -3226,7 +3226,7 @@
 
 FUNCTION{bst.file.version} { "0.3" }
 FUNCTION{bst.file.date} { "2009/02/12" }
-FUNCTION{bst.file.website} { "http://parsilatex.org/" }
+FUNCTION{bst.file.website} { "http://developer.berlios.de/projects/xepersian" }
 FUNCTION{bst.file.authors} {"M.Amintoosi and M.Vahedi" }
 
 FUNCTION {banner.message}
@@ -4576,7 +4576,7 @@
 
 FUNCTION{bst.file.version} { "0.3" }
 FUNCTION{bst.file.date} { "2009/02/12" }
-FUNCTION{bst.file.website} { "http://parsilatex.org/" }
+FUNCTION{bst.file.website} { "http://developer.berlios.de/projects/xepersian" }
 FUNCTION{bst.file.authors} {"M.Amintoosi and M.Vahedi" }
 
 FUNCTION {banner.message}
@@ -5746,7 +5746,7 @@
 
 FUNCTION{bst.file.version} { "0.2" }
 FUNCTION{bst.file.date} { "2009/02/09" }
-FUNCTION{bst.file.website} { "http://parsilatex.org/" }
+FUNCTION{bst.file.website} { "http://developer.berlios.de/projects/xepersian" }
 FUNCTION{bst.file.authors} {"M.Amintoosi and M.Vahedi" }
 
 FUNCTION {banner.message}
@@ -7045,7 +7045,7 @@
 
 FUNCTION{bst.file.version} { "0.22" }
 FUNCTION{bst.file.date} { "2009/02/09" }
-FUNCTION{bst.file.website} { "http://parsilatex.org/" }
+FUNCTION{bst.file.website} { "http://developer.berlios.de/projects/xepersian" }
 FUNCTION{bst.file.authors} {"M.Amintoosi and M.Vahedi" }
 
 FUNCTION {banner.message}
@@ -8297,7 +8297,7 @@
 \customlogo{????? ????????}
 \customminilogo{????? ????????}
 \custommagazinename{????? ????????}
-\customwwwTxt{http://parsilatex.org}
+\customwwwTxt{http://developer.berlios.de/projects/xepersian}
 \begin{document}
 \begin{frontpage}
 \firstimage{img/ireland.jpg}{??? ??????? ????? ???? ?? ????? ??? ???.}
@@ -8339,8 +8339,8 @@
 
 ??? ?????? ???? ??????? ? ????? ?????
 
-\texttt{vafa at aol.com.au\\[5pt]
-http://parsilatex.org}\\
+\texttt{vafa at users.berlios.de\\[5pt]
+http://developer.berlios.de/projects/xepersian}\\
 \end{authorblock}
 \end{frontpage}
 \newsection{???? ???}
@@ -8778,7 +8778,7 @@
 @MISC{???????????????,
   AUTHOR =       {\noopsort{?????,???}{?????,???}  and ???????, ???? and  ?????,?????.},
   TITLE =        {???????? (\lr{\XePersian}): ???? ????? ???? ????????? ?? \lr{\LaTeX2e}},
-  HOWPUBLISHED =    {\lr{http://wiki.parsilatex.org}},
+  HOWPUBLISHED =    {\lr{http://developer.berlios.de/projects/xepersian}},
   YEAR =         {????},  
   LANGUAGE =     {Persian}
   }



From vafa at mail.berlios.de  Sun Jun  7 12:53:03 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Sun, 7 Jun 2009 12:53:03 +0200
Subject: [Xepersian-development] r56 - trunk
Message-ID: <200906071053.n57Ar3sH020873@sheep.berlios.de>

Author: vafa
Date: 2009-06-07 12:52:57 +0200 (Sun, 07 Jun 2009)
New Revision: 56

Modified:
   trunk/xepersian.dtx
Log:
added support for memoir class

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-05 15:01:28 UTC (rev 55)
+++ trunk/xepersian.dtx	2009-06-07 10:52:57 UTC (rev 56)
@@ -84,6 +84,7 @@
 \generate{\file{extbook-xepersian.def}{\from{xepersian.dtx}{extbook-xepersian.def}}}
 \generate{\file{kashida-xepersian.def}{\from{xepersian.dtx}{kashida-xepersian.def}}}
 \generate{\file{listings-xepersian.def}{\from{xepersian.dtx}{listings-xepersian.def}}}
+\generate{\file{memoir-xepersian.def}{\from{xepersian.dtx}{memoir-xepersian.def}}}
 \generate{\file{misccommandsenvironments-ltx.def}{\from{xepersian.dtx}{misccommandsenvironments-ltx.def}}}
 \generate{\file{refrep-xepersian.def}{\from{xepersian.dtx}{refrep-xepersian.def}}}
 \generate{\file{report-xepersian.def}{\from{xepersian.dtx}{report-xepersian.def}}}
@@ -155,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 55}
+\def\xepersianrevision{revision 56}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -1656,6 +1657,22 @@
 %    \end{macrocode}
 % \iffalse
 %</listings-xepersian.def>
+%<*memoir-xepersian.def>
+% \fi
+% \part{memoir-xepersian.def}
+%    \begin{macrocode}
+\renewcommand{\@memfront}{%
+  \@smemfront\pagenumbering{harfi}}
+\renewcommand*{\thepart}{\@tartibi\c at part}
+\renewcommand{\appendix}{\par
+  \setcounter{chapter}{0}%
+  \setcounter{section}{0}%
+  \gdef\@chapapp{\appendixname}%
+  \gdef\thechapter{\@harfi\c at chapter}%
+  \anappendixtrue}
+%    \end{macrocode}
+% \iffalse
+%</memoir-xepersian.def>
 %<*misccommandsenvironments-ltx.def>
 % \fi
 % \part{misccommandsenvironments-ltx.def}



From vafa at mail.berlios.de  Sun Jun  7 13:02:20 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Sun, 7 Jun 2009 13:02:20 +0200
Subject: [Xepersian-development] r57 - trunk
Message-ID: <200906071102.n57B2KE1030386@sheep.berlios.de>

Author: vafa
Date: 2009-06-07 13:02:11 +0200 (Sun, 07 Jun 2009)
New Revision: 57

Modified:
   trunk/xepersian.dtx
Log:
I forgot to load memoir-xepersian.def in xepersian.sty

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-07 10:52:57 UTC (rev 56)
+++ trunk/xepersian.dtx	2009-06-07 11:02:11 UTC (rev 57)
@@ -156,7 +156,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 56}
+\def\xepersianrevision{revision 57}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -393,6 +393,7 @@
 \@ifclassloaded{book}{\input{book-xepersian.def}}{}
 \@ifclassloaded{refrep}{\input{refrep-xepersian.def}}{}
 \@ifclassloaded{beamer}{\input{beamer-xepersian.def}}{}
+\@ifclassloaded{memoir}{\input{memoir-xepersian.def}}{}
 %    \end{macrocode}
 % \iffalse
 %</xepersian.sty>



From vafa at mail.berlios.de  Sun Jun  7 19:12:50 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Sun, 7 Jun 2009 19:12:50 +0200
Subject: [Xepersian-development] r58 - trunk
Message-ID: <200906071712.n57HCovL025608@sheep.berlios.de>

Author: vafa
Date: 2009-06-07 19:12:35 +0200 (Sun, 07 Jun 2009)
New Revision: 58

Modified:
   trunk/xepersian.dtx
Log:
added support for tocloft

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-07 11:02:11 UTC (rev 57)
+++ trunk/xepersian.dtx	2009-06-07 17:12:35 UTC (rev 58)
@@ -88,6 +88,7 @@
 \generate{\file{misccommandsenvironments-ltx.def}{\from{xepersian.dtx}{misccommandsenvironments-ltx.def}}}
 \generate{\file{refrep-xepersian.def}{\from{xepersian.dtx}{refrep-xepersian.def}}}
 \generate{\file{report-xepersian.def}{\from{xepersian.dtx}{report-xepersian.def}}}
+\generate{\file{tocloft-xepersian.def}{\from{xepersian.dtx}{tocloft-xepersian.def}}}
 \generate{\file{xepersian-magazine.cls}{\from{xepersian.dtx}{xepersian-magazine.cls}}}
 \generate{\file{xepersian-mathsdigitspec.sty}{\from{xepersian.dtx}{xepersian-mathsdigitspec.sty}}}
 \generate{\file{xepersian-multiplechoice.sty}{\from{xepersian.dtx}{xepersian-multiplechoice.sty}}}
@@ -156,7 +157,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 57}
+\def\xepersianrevision{revision 58}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -382,6 +383,7 @@
 \@ifpackageloaded{algorithm}{\input{algorithm-xepersian.def}}{}
 \@ifpackageloaded{bidi}{\input{footnote-bidi-xepersian.def}}{}
 \@ifpackageloaded{enumerate}{\input{enumerate-xepersian.def}}{}
+\@ifpackageloaded{tocloft}{\input{tocloft-xepersian.def}}{}
 \@ifclassloaded{article}{\input{article-xepersian.def}}{}
 \@ifclassloaded{amsart}{\input{amsart-xepersian.def}}{}
 \@ifclassloaded{bidimoderncv}{\input{bidimoderncv-xepersian.def}}{}
@@ -1713,6 +1715,23 @@
 %    \end{macrocode}
 % \iffalse
 %</report-xepersian.def>
+%<*tocloft-xepersian.def>
+% \fi
+% \part{tocloft-xepersian.def}
+%    \begin{macrocode}
+\renewcommand*{\cftchapname}{\if at RTL ???\else chapter\fi}
+\renewcommand*{\cftsecname}{\if at RTL ????\else section\fi}
+\renewcommand*{\cftsubsecname}{\if at RTL ???????\else subsection\fi}
+\renewcommand*{\cftsubsubsecname}{\if at RTL ??????????\else subsubsection\fi}
+\renewcommand*{\cftparaname}{\if at RTL ????????\else paragraph\fi}
+\renewcommand*{\cftsubparaname}{\if at RTL ???????????\else subparagraph\fi}
+\renewcommand*{\cftfigname}{\if at RTL ???\else figure\fi}
+\renewcommand*{\cftsubfigname}{\if at RTL ??????\else subfigure\fi}
+\renewcommand*{\cfttabname}{\if at RTL ????\else table\fi}
+\renewcommand*{\cftsubtabname}{\if at RTL ???????\else subtable\fi}
+%    \end{macrocode}
+% \iffalse
+%</tocloft-xepersian.def>
 %<*xepersian-magazine.cls>
 % \fi
 % \part{xepersian-magazine.cls}



From vafa at mail.berlios.de  Tue Jun  9 09:14:49 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 9 Jun 2009 09:14:49 +0200
Subject: [Xepersian-development] r59 - trunk
Message-ID: <200906090714.n597EnPi000894@sheep.berlios.de>

Author: vafa
Date: 2009-06-09 09:14:33 +0200 (Tue, 09 Jun 2009)
New Revision: 59

Added:
   trunk/ftxe-0.2.py
Removed:
   trunk/ftxe-0.1.py
Log:
new version of ftxe per Mostafa is added

Deleted: trunk/ftxe-0.1.py
===================================================================
--- trunk/ftxe-0.1.py	2009-06-07 17:12:35 UTC (rev 58)
+++ trunk/ftxe-0.1.py	2009-06-09 07:14:33 UTC (rev 59)
@@ -1,490 +0,0 @@
-#########################################
-#       General Public License          #
-#       Author:  Mostafa Vahedi         #
-#       Date:    21 May 2009            #
-#       Version  0.1                    #
-#########################################
-
-import codecs
-
-import sys
-
-
-ft_numerical = [
-chr(0xB9),	# 	Arabic Thoushads Seperator
-chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
-]
-
-
-ft_vowels = [
-chr(0xB0),	#	ARABIC FATHA
-chr(0xB1),	#	ARABIC KASRA
-chr(0xB2),	#	ARABIC DAMMA
-chr(0xB3),	#	ARABIC FATHATAN
-chr(0xB4),	#	ARABIC SHADDA
-chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB),	#	ARABIC HAMZA ABOVE
-chr(0xC4) 	#	ARABIC SUKUN
-]
-
-ft_non_joiners = [
-chr(0x8F)	#	ARABIC LETTER HAMZA
-]
-
-ft_bidi_joiners_initial = [
-chr(0xE4),	#	ARABIC LETTER AIN, initial form
-chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
-chr(0xFB) 	#	ARABIC LETTER HEH, initial form
-]
-
-ft_bidi_joiners_medial = [
-chr(0xE3),	#	ARABIC LETTER AIN, medial form
-chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
-chr(0xFA) 	#	ARABIC LETTER HEH, medial form
-]
-
-ft_bidi_joiners_final = [
-chr(0xE2),	#	ARABIC LETTER AIN, final form
-chr(0xE6),	#	ARABIC LETTER GHAIN, final form
-chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
-]
-
-ft_bidi_joiners_isolated = [
-chr(0xE1),	#	ARABIC LETTER AIN, isolated form
-chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
-chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
-]
-
-ft_bidi_joiners_initial_medial = [
-chr(0x8B),	#	ARABIC TATWEEL
-chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
-chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
-chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
-chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
-chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
-chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
-chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
-]
-
-ft_bidi_joiners_final_isolated = [
-chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
-chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
-chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
-chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
-chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
-chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
-chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
-chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
-]
-
-ft_right_joiners_final = [
-chr(0x91)	#	ARABIC LETTER ALEF, final form
-]
-
-ft_right_joiners_isolated = [
-chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x90)	#	ARABIC LETTER ALEF, isolated form
-]
-
-ft_right_joiners_final_isolated = [
-chr(0xA2),	#	ARABIC LETTER DAL
-chr(0xA3),	#	ARABIC LETTER THAL
-chr(0xA4),	#	ARABIC LETTER REH
-chr(0xA5),	#	ARABIC LETTER ZAIN
-chr(0xA6),	#	ARABIC LETTER JEH
-chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
-chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF8)	#	ARABIC LETTER WAW
-]
-
-
-table_FT_UN = {
-chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
-chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
-chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
-chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
-chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
-chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
-chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
-chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
-chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
-chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
-chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
-chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
-chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
-chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
-chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
-chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
-chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
-chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
-chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
-chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
-chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
-chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
-chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
-chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
-chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
-chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
-chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
-chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
-chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
-chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
-chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
-chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
-chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
-chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
-chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
-chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
-chr(0xB5) : [u'\u0023'],	# * #
-chr(0xB6) : [u'\u0024'],	# * $
-chr(0xB7) : [u'\u0025'],	# * %
-chr(0xB8) : [u'\u0026'],	# * &
-chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
-chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
-chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
-chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
-chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
-chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
-chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
-chr(0xC5) : [u'\u002D'],	# * -
-chr(0xC6) : [u'\u002E'],	# * FULL STOP
-chr(0xC7) : [u'\u002F'],	# * /
-chr(0xC8) : [u'\u002A'],	# * *
-chr(0xC9) : [u'\u007E'],	# * ~
-chr(0xCA) : [u'\u003A'],	# * COLON
-chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
-chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
-chr(0xCD) : [u'\u002B'],	# * +
-chr(0xCE) : [u'\u003D'],	# * =
-chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
-# chr(0xD0) : [u'\u0040'],	# * @
-chr(0xD0) : [u''],	        # * @
-chr(0xD1) : [u'\u005D'],	# * [
-chr(0xD2) : [u'\u005C'],	# * \
-chr(0xD3) : [u'\u005B'],	# * ]
-chr(0xD4) : [u'\u005E'],	# * ^
-chr(0xD5) : [u'\u005F'],	# * _
-chr(0xD6) : [u'\u0060'],	# * `
-chr(0xD7) : [u'\u007D'],	# * {
-chr(0xD8) : [u'\u007C'],	# * |
-chr(0xDA) : [u'\u0020'],	# * SPACE
-chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
-chr(0xDE) : [u'\u007B'],	# * }
-chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
-chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
-chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
-chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
-chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
-chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
-chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
-chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
-chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
-chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
-chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
-chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
-chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
-chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
-chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
-chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
-chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
-chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
-}
-
-F_SLASH = chr(0xD2)
-F_PRNT_OPEN = chr(0xDE)
-F_AT_SIGN = chr(0xD0)
-
-# latex and farsitex commands whose first parameter does not need \lr{...}
-commands = [ "begin", 
-"end",
-"input", "include", "includeonly",
-"hspace", "vspace", "hspace*", "vspace*",
-"label", "ref", "cite",
-"bibliographystyle",
-"parbox",
-"newenvironment", "newtheorem",
-"persianmathdigitsfamily",
-"fontfamily", "fontseries", "fontshape",
-"rmdefault", "sfdefault", "ttdefault",
-"bfdefault", "itdefault", "sldefault", "scdefault",
-"pagenumbering", "pagestyle", "thispagestyle",
-"setcounter", "stepcounter", "setlength", "addtolength"
-]
-
-
-def ft_is_numeric(ch):
-	if ((ch in ft_numerical) or 
-	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
-		return 1
-	return 0
-
-def ft_can_join_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_final) or
-	    (ch in ft_bidi_joiners_isolated) or
-	    (ch in ft_bidi_joiners_initial_medial) or
-	    (ch in ft_bidi_joiners_final_isolated)):
-    		return 1
-	return 0
-
-def ft_can_join_right(ch):
-	if (ft_can_join_left(ch) or 
-	    (ch in ft_right_joiners_final) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_right_joiners_final_isolated)):
-		return 1
-	return 0
-
-def ft_joining_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or 
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_initial_medial)):
-		return 1
-	return 0
-
-
-def ft_joining_right(ch):
-	if ((ch in ft_right_joiners_final) or
-	    (ch in ft_bidi_joiners_medial) or 
-	    (ch in ft_bidi_joiners_final)):
-		return 1
-	return 0
-
-def ft_not_right_joined(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_bidi_joiners_isolated)):
-		return 1
-	return 0
-
-def ft_adjust_shaping(text, i):
-	current = text[i]
-	u = u''
-	try:
-		u = table_FT_UN[current][0]
-	except KeyError:
-		return u''
-
-	#if you don't want shaping remove the following comment
-	#return u
-
-	if ((current in ft_vowels) or (ft_is_numeric(current))):
-		return u
-
-	#find next non-vowel character on the left
-	text_len = len(text)
-	next_index = i+1
-	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
-		next_index += 1
-
-	if (next_index == text_len):
-		next = ''
-	else:
-		next = text[next_index]
-
-	# if current letter is joining from left but next letter is or can not joining
-	if (ft_joining_left(current)):
-		if (not ft_can_join_right(next)):
-			u += u'\u200D' #ZWJ
-		elif (ft_not_right_joined(next)):
-			u += u'\u200D\u200C' #ZWJ+ZWNJ
-	# if current letter can join but next letter is joining from right
-	elif (ft_can_join_left(current)):
-		if (ft_joining_right(next)):
-			u += u'\u200C\u200D' #ZWNJ+ZWJ
-		elif (ft_can_join_right(next)):
-			u += u'\u200C' #ZWNJ
-	return u
-
-def ft_adjust_number(text):
-	result = u''
-	i = len(text)-1
-	while (i >= 0):
-		result += ft_adjust_shaping(text, i)
-		i -= 1
-	return result
-
-
-def map_ft_unicode(text):
-	mapped_text = u''
-
-	i = 0
-	while (i < len(text)):
-		if (ft_is_numeric(text[i])):
-			next_index = i
-			while ((next_index+1 < len(text)) and
-			       (ft_is_numeric(text[next_index+1]))):
-				next_index += 1
-			mapped_text += ft_adjust_number(text[i:next_index+1])
-			i = next_index+1
-			continue
-
-		mapped_text += ft_adjust_shaping(text, i)
-		i += 1
-	return mapped_text
-
-# Finds next token all of the same language
-def ft_next_part(line, i):
-	j = i
-	language_flag = (line[j]<chr(0x80))
-	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
-		j += 1
-	return j
-
-# Main body of the program 
-if len(sys.argv) <= 2:
-	print 'usage: python undk in_filename out_filename'
-	exit(0)
-
-###################################
-# Begin of main body of the program
-###################################
-filename = sys.argv[1]
-outfile = sys.argv[2]
-
-try:
-	f = open(filename, 'r')
-except IOError:
-	print "Can not open the input file: " + filename
-	exit(0)
-
-try:
-	of = codecs.open(outfile, encoding='utf-8', mode='w')
-except IOError:
-	print "Can not open the output file: " + outfile
-	exit(0)
-
-line_number = 0
-for line in f:
-	line_number += 1
-	output_line = u''
-	line_len = len(line)
-	
-	# remove new-line characters from end of line
-	if (line_len>1 and line[line_len-1] == '\n'):
-		line_len-=1
-	if (line_len>1 and line[line_len-1] == '\r'):
-		line_len-=1
-
-	# check line-direction character
-	line_direction_rtl = (line[0] == '<')
-	if (line[0] != '>') and (line[0] != '<'):
-		print "FORMAT ERROR AT LINE: " + str(line_number)
-		exit(0)
-
-	i = 1
-
-	while (i<line_len):
-		next_part_index = ft_next_part(line, i)
-		next_part = line[i:next_part_index]
-		next_part_latin = (line[i]<chr(0x80))
-		
-		# see if we should put \lr{...} for the current english expression
-		if line_direction_rtl and next_part_latin:
-			is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
-			is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
-			is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
-		
-			cmd_index = 0
-			while cmd_index < len(commands):
-				len_cmd = len(commands[cmd_index])+2
-				if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
-					break
-				cmd_index += 1
-			is_commands_group = cmd_index < len(commands)
-			is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
-
-		if next_part_latin:
-			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
-				output_line += u'\\lr{'
-			
-			output_line += next_part.encode( 'utf-8' )
-			
-			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
-				output_line += u'}'
-		else:
-			if ( not line_direction_rtl):
-				output_line += u'\\rl{'
-				
-			output_line += map_ft_unicode(next_part)
-			
-			if (not line_direction_rtl):
-				output_line += u'}'
-				
-		i = next_part_index
-	# end of while			
-	
-	# write the processed line
-	output_line += u'\n'
-	of.write(output_line)
-	# end of line processing
-# end of file processing
-
-of.close()
-f.close()	

Added: trunk/ftxe-0.2.py
===================================================================
--- trunk/ftxe-0.2.py	2009-06-07 17:12:35 UTC (rev 58)
+++ trunk/ftxe-0.2.py	2009-06-09 07:14:33 UTC (rev 59)
@@ -0,0 +1,490 @@
+#########################################
+#       General Public License          #
+#       Author:  Mostafa Vahedi         #
+#       Date:    8 June 2009            #
+#       Version  0.2                    #
+#########################################
+
+import codecs
+
+import sys
+
+
+ft_numerical = [
+chr(0xB9),	# 	Arabic Thoushads Seperator
+chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
+]
+
+
+ft_vowels = [
+chr(0xB0),	#	ARABIC FATHA
+chr(0xB1),	#	ARABIC KASRA
+chr(0xB2),	#	ARABIC DAMMA
+chr(0xB3),	#	ARABIC FATHATAN
+chr(0xB4),	#	ARABIC SHADDA
+chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB),	#	ARABIC HAMZA ABOVE
+chr(0xC4) 	#	ARABIC SUKUN
+]
+
+ft_non_joiners = [
+chr(0x8F)	#	ARABIC LETTER HAMZA
+]
+
+ft_bidi_joiners_initial = [
+chr(0xE4),	#	ARABIC LETTER AIN, initial form
+chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
+chr(0xFB) 	#	ARABIC LETTER HEH, initial form
+]
+
+ft_bidi_joiners_medial = [
+chr(0xE3),	#	ARABIC LETTER AIN, medial form
+chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
+chr(0xFA) 	#	ARABIC LETTER HEH, medial form
+]
+
+ft_bidi_joiners_final = [
+chr(0xE2),	#	ARABIC LETTER AIN, final form
+chr(0xE6),	#	ARABIC LETTER GHAIN, final form
+chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
+]
+
+ft_bidi_joiners_isolated = [
+chr(0xE1),	#	ARABIC LETTER AIN, isolated form
+chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
+chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
+]
+
+ft_bidi_joiners_initial_medial = [
+chr(0x8B),	#	ARABIC TATWEEL
+chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
+chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
+chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
+chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
+chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
+chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
+chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
+]
+
+ft_bidi_joiners_final_isolated = [
+chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
+chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
+chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
+chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
+chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
+chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
+chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
+chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
+]
+
+ft_right_joiners_final = [
+chr(0x91)	#	ARABIC LETTER ALEF, final form
+]
+
+ft_right_joiners_isolated = [
+chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x90)	#	ARABIC LETTER ALEF, isolated form
+]
+
+ft_right_joiners_final_isolated = [
+chr(0xA2),	#	ARABIC LETTER DAL
+chr(0xA3),	#	ARABIC LETTER THAL
+chr(0xA4),	#	ARABIC LETTER REH
+chr(0xA5),	#	ARABIC LETTER ZAIN
+chr(0xA6),	#	ARABIC LETTER JEH
+chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
+chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF8)	#	ARABIC LETTER WAW
+]
+
+
+table_FT_UN = {
+chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
+chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
+chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
+chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
+chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
+chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
+chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
+chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
+chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
+chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
+chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
+chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
+chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
+chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
+chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
+chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
+chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
+chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
+chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
+chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
+chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
+chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
+chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
+chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
+chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
+chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
+chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
+chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
+chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
+chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
+chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
+chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
+chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
+chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
+chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
+chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
+chr(0xB5) : [u'\u0023'],	# * #
+chr(0xB6) : [u'\u0024'],	# * $
+chr(0xB7) : [u'\u0025'],	# * %
+chr(0xB8) : [u'\u0026'],	# * &
+chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
+chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
+chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
+chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
+chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
+chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
+chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
+chr(0xC5) : [u'\u002D'],	# * -
+chr(0xC6) : [u'\u002E'],	# * FULL STOP
+chr(0xC7) : [u'\u002F'],	# * /
+chr(0xC8) : [u'\u002A'],	# * *
+chr(0xC9) : [u'\u007E'],	# * ~
+chr(0xCA) : [u'\u003A'],	# * COLON
+chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
+chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
+chr(0xCD) : [u'\u002B'],	# * +
+chr(0xCE) : [u'\u003D'],	# * =
+chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
+# chr(0xD0) : [u'\u0040'],	# * @
+chr(0xD0) : [u''],	        # * @
+chr(0xD1) : [u'\u005D'],	# * [
+chr(0xD2) : [u'\u005C'],	# * \
+chr(0xD3) : [u'\u005B'],	# * ]
+chr(0xD4) : [u'\u005E'],	# * ^
+chr(0xD5) : [u'\u005F'],	# * _
+chr(0xD6) : [u'\u0060'],	# * `
+chr(0xD7) : [u'\u007D'],	# * {
+chr(0xD8) : [u'\u007C'],	# * |
+chr(0xDA) : [u'\u0020'],	# * SPACE
+chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
+chr(0xDE) : [u'\u007B'],	# * }
+chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
+chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
+chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
+chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
+chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
+chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
+chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
+chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
+chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
+chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
+chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
+chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
+chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
+chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
+chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
+chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
+chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
+chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
+}
+
+F_SLASH = chr(0xD2)
+F_PRNT_OPEN = chr(0xDE)
+F_AT_SIGN = chr(0xD0)
+
+# latex and farsitex commands whose first parameter does not need \lr{...}
+commands = [ "begin", 
+"end",
+"input", "include", "includeonly",
+"hspace", "vspace", "hspace*", "vspace*",
+"label", "ref", "cite", "bibitem",
+"bibliographystyle",
+"parbox",
+"newenvironment", "newtheorem",
+"persianmathdigitsfamily",
+"fontfamily", "fontseries", "fontshape",
+"rmdefault", "sfdefault", "ttdefault",
+"bfdefault", "itdefault", "sldefault", "scdefault",
+"pagenumbering", "pagestyle", "thispagestyle",
+"setcounter", "stepcounter", "setlength", "addtolength"
+]
+
+
+def ft_is_numeric(ch):
+	if ((ch in ft_numerical) or 
+	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
+		return 1
+	return 0
+
+def ft_can_join_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_final) or
+	    (ch in ft_bidi_joiners_isolated) or
+	    (ch in ft_bidi_joiners_initial_medial) or
+	    (ch in ft_bidi_joiners_final_isolated)):
+    		return 1
+	return 0
+
+def ft_can_join_right(ch):
+	if (ft_can_join_left(ch) or 
+	    (ch in ft_right_joiners_final) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_right_joiners_final_isolated)):
+		return 1
+	return 0
+
+def ft_joining_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or 
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_initial_medial)):
+		return 1
+	return 0
+
+
+def ft_joining_right(ch):
+	if ((ch in ft_right_joiners_final) or
+	    (ch in ft_bidi_joiners_medial) or 
+	    (ch in ft_bidi_joiners_final)):
+		return 1
+	return 0
+
+def ft_not_right_joined(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_bidi_joiners_isolated)):
+		return 1
+	return 0
+
+def ft_adjust_shaping(text, i):
+	current = text[i]
+	u = u''
+	try:
+		u = table_FT_UN[current][0]
+	except KeyError:
+		return u''
+
+	#if you don't want shaping remove the following comment
+	#return u
+
+	if ((current in ft_vowels) or (ft_is_numeric(current))):
+		return u
+
+	#find next non-vowel character on the left
+	text_len = len(text)
+	next_index = i+1
+	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
+		next_index += 1
+
+	if (next_index == text_len):
+		next = ''
+	else:
+		next = text[next_index]
+
+	# if current letter is joining from left but next letter is or can not joining
+	if (ft_joining_left(current)):
+		if (not ft_can_join_right(next)):
+			u += u'\u200D' #ZWJ
+		elif (ft_not_right_joined(next)):
+			u += u'\u200D\u200C' #ZWJ+ZWNJ
+	# if current letter can join but next letter is joining from right
+	elif (ft_can_join_left(current)):
+		if (ft_joining_right(next)):
+			u += u'\u200C\u200D' #ZWNJ+ZWJ
+		elif (ft_can_join_right(next)):
+			u += u'\u200C' #ZWNJ
+	return u
+
+def ft_adjust_number(text):
+	result = u''
+	i = len(text)-1
+	while (i >= 0):
+		result += ft_adjust_shaping(text, i)
+		i -= 1
+	return result
+
+
+def map_ft_unicode(text):
+	mapped_text = u''
+
+	i = 0
+	while (i < len(text)):
+		if (ft_is_numeric(text[i])):
+			next_index = i
+			while ((next_index+1 < len(text)) and
+			       (ft_is_numeric(text[next_index+1]))):
+				next_index += 1
+			mapped_text += ft_adjust_number(text[i:next_index+1])
+			i = next_index+1
+			continue
+
+		mapped_text += ft_adjust_shaping(text, i)
+		i += 1
+	return mapped_text
+
+# Finds next token all of the same language
+def ft_next_part(line, i):
+	j = i
+	language_flag = (line[j]<chr(0x80))
+	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
+		j += 1
+	return j
+
+# Main body of the program 
+if len(sys.argv) <= 2:
+	print 'usage: python undk in_filename out_filename'
+	exit(0)
+
+###################################
+# Begin of main body of the program
+###################################
+filename = sys.argv[1]
+outfile = sys.argv[2]
+
+try:
+	f = open(filename, 'r')
+except IOError:
+	print "Can not open the input file: " + filename
+	exit(0)
+
+try:
+	of = codecs.open(outfile, encoding='utf-8', mode='w')
+except IOError:
+	print "Can not open the output file: " + outfile
+	exit(0)
+
+line_number = 0
+for line in f:
+	line_number += 1
+	output_line = u''
+	line_len = len(line)
+	
+	# remove new-line characters from end of line
+	if (line_len>1 and line[line_len-1] == '\n'):
+		line_len-=1
+	if (line_len>1 and line[line_len-1] == '\r'):
+		line_len-=1
+
+	# check line-direction character
+	line_direction_rtl = (line[0] == '<')
+	if (line[0] != '>') and (line[0] != '<'):
+		print "FORMAT ERROR AT LINE: " + str(line_number)
+		exit(0)
+
+	i = 1
+
+	while (i<line_len):
+		next_part_index = ft_next_part(line, i)
+		next_part = line[i:next_part_index]
+		next_part_latin = (line[i]<chr(0x80))
+		
+		# see if we should put \lr{...} for the current english expression
+		if line_direction_rtl and next_part_latin:
+			is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
+			is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
+			is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
+		
+			cmd_index = 0
+			while cmd_index < len(commands):
+				len_cmd = len(commands[cmd_index])+2
+				if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
+					break
+				cmd_index += 1
+			is_commands_group = cmd_index < len(commands)
+			is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
+
+		if next_part_latin:
+			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
+				output_line += u'\\lr{'
+			
+			output_line += next_part.encode( 'utf-8' )
+			
+			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
+				output_line += u'}'
+		else:
+			if ( not line_direction_rtl):
+				output_line += u'\\rl{'
+				
+			output_line += map_ft_unicode(next_part)
+			
+			if (not line_direction_rtl):
+				output_line += u'}'
+				
+		i = next_part_index
+	# end of while			
+	
+	# write the processed line
+	output_line += u'\n'
+	of.write(output_line)
+	# end of line processing
+# end of file processing
+
+of.close()
+f.close()	



From vafa at mail.berlios.de  Tue Jun  9 10:36:28 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 9 Jun 2009 10:36:28 +0200
Subject: [Xepersian-development] r60 - trunk
Message-ID: <200906090836.n598aSKD020405@sheep.berlios.de>

Author: vafa
Date: 2009-06-09 10:36:22 +0200 (Tue, 09 Jun 2009)
New Revision: 60

Modified:
   trunk/xepersian.dtx
Log:
replaced the support of memoir for bidimemoir class in addition to other corrections

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-09 07:14:33 UTC (rev 59)
+++ trunk/xepersian.dtx	2009-06-09 08:36:22 UTC (rev 60)
@@ -84,7 +84,7 @@
 \generate{\file{extbook-xepersian.def}{\from{xepersian.dtx}{extbook-xepersian.def}}}
 \generate{\file{kashida-xepersian.def}{\from{xepersian.dtx}{kashida-xepersian.def}}}
 \generate{\file{listings-xepersian.def}{\from{xepersian.dtx}{listings-xepersian.def}}}
-\generate{\file{memoir-xepersian.def}{\from{xepersian.dtx}{memoir-xepersian.def}}}
+\generate{\file{bidimemoir-xepersian.def}{\from{xepersian.dtx}{bidimemoir-xepersian.def}}}
 \generate{\file{misccommandsenvironments-ltx.def}{\from{xepersian.dtx}{misccommandsenvironments-ltx.def}}}
 \generate{\file{refrep-xepersian.def}{\from{xepersian.dtx}{refrep-xepersian.def}}}
 \generate{\file{report-xepersian.def}{\from{xepersian.dtx}{report-xepersian.def}}}
@@ -157,7 +157,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 58}
+\def\xepersianrevision{revision 60}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -395,7 +395,7 @@
 \@ifclassloaded{book}{\input{book-xepersian.def}}{}
 \@ifclassloaded{refrep}{\input{refrep-xepersian.def}}{}
 \@ifclassloaded{beamer}{\input{beamer-xepersian.def}}{}
-\@ifclassloaded{memoir}{\input{memoir-xepersian.def}}{}
+\@ifclassloaded{bidimemoir}{\input{bidimemoir-xepersian.def}}{}
 %    \end{macrocode}
 % \iffalse
 %</xepersian.sty>
@@ -1660,12 +1660,14 @@
 %    \end{macrocode}
 % \iffalse
 %</listings-xepersian.def>
-%<*memoir-xepersian.def>
+%<*bidimemoir-xepersian.def>
 % \fi
-% \part{memoir-xepersian.def}
+% \part{bidimemoir-xepersian.def}
 %    \begin{macrocode}
 \renewcommand{\@memfront}{%
   \@smemfront\pagenumbering{harfi}}
+\renewcommand{\setthesection}{\thechapter\@SepMark\harfi{section}}
+\renewcommand*{\thebook}{\@tartibi\c at book}
 \renewcommand*{\thepart}{\@tartibi\c at part}
 \renewcommand{\appendix}{\par
   \setcounter{chapter}{0}%
@@ -1675,7 +1677,7 @@
   \anappendixtrue}
 %    \end{macrocode}
 % \iffalse
-%</memoir-xepersian.def>
+%</bidimemoir-xepersian.def>
 %<*misccommandsenvironments-ltx.def>
 % \fi
 % \part{misccommandsenvironments-ltx.def}



From vafa at mail.berlios.de  Tue Jun  9 13:47:20 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 9 Jun 2009 13:47:20 +0200
Subject: [Xepersian-development] r61 - trunk
Message-ID: <200906091147.n59BlKVv016881@sheep.berlios.de>

Author: vafa
Date: 2009-06-09 13:47:15 +0200 (Tue, 09 Jun 2009)
New Revision: 61

Modified:
   trunk/xepersian.dtx
Log:
added support for scrartcl class

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-09 08:36:22 UTC (rev 60)
+++ trunk/xepersian.dtx	2009-06-09 11:47:15 UTC (rev 61)
@@ -88,6 +88,7 @@
 \generate{\file{misccommandsenvironments-ltx.def}{\from{xepersian.dtx}{misccommandsenvironments-ltx.def}}}
 \generate{\file{refrep-xepersian.def}{\from{xepersian.dtx}{refrep-xepersian.def}}}
 \generate{\file{report-xepersian.def}{\from{xepersian.dtx}{report-xepersian.def}}}
+\generate{\file{scrartcl-xepersian.def}{\from{xepersian.dtx}{scrartcl-xepersian.def}}}
 \generate{\file{tocloft-xepersian.def}{\from{xepersian.dtx}{tocloft-xepersian.def}}}
 \generate{\file{xepersian-magazine.cls}{\from{xepersian.dtx}{xepersian-magazine.cls}}}
 \generate{\file{xepersian-mathsdigitspec.sty}{\from{xepersian.dtx}{xepersian-mathsdigitspec.sty}}}
@@ -157,7 +158,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 60}
+\def\xepersianrevision{revision 61}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -388,6 +389,7 @@
 \@ifclassloaded{amsart}{\input{amsart-xepersian.def}}{}
 \@ifclassloaded{bidimoderncv}{\input{bidimoderncv-xepersian.def}}{}
 \@ifclassloaded{report}{\input{report-xepersian.def}}{}
+\@ifclassloaded{scrartcl}{\input{scrartcl-xepersian.def}}{}
 \@ifclassloaded{xepersian-thesis}{\input{xepersian-thesis-xepersian.def}}{}
 \@ifclassloaded{amsbook}{\input{amsbook-xepersian.def}}{}
 \@ifclassloaded{bookest}{\input{bookest-xepersian.def}}{}
@@ -1717,6 +1719,48 @@
 %    \end{macrocode}
 % \iffalse
 %</report-xepersian.def>
+%<*scrartcl-xepersian.def>
+% \fi
+% \part{scrartcl-xepersian.def}
+%    \begin{macrocode}
+\renewcommand*\descfont{\if at RTL\persiansffamily\else\sffamily\fi\bfseries}
+\DeclareOldFontCommand{\sf}{\normalfont\if at RTL\persiansffamily\else\sffamily\fi}{\mathsf}
+\DeclareOldFontCommand{\tt}{\normalfont\if at RTL\persianttfamily\else\ttfamily\fi}{\mathtt}
+\DeclareOldFontCommand{\sfb}{\normalfont\if at RTL\persiansffamily\else\sffamily\fi\bfseries}{%
+  \@nomath\sfb}
+\renewcommand*\sectfont{\normalcolor\if at RTL\persiansffamily\else\sffamily\fi\bfseries}
+\newkomafont{dictum-xepersian}{\normalfont\normalcolor\if at RTL\persiansffamily\else\sffamily\fi\small}
+\renewcommand*{\thepart}{\@tartibi\c at part}
+\renewcommand*\appendix{\par%
+  \setcounter{section}{0}%
+  \setcounter{subsection}{0}%
+  \gdef\thesection{\@harfi\c at section}%
+  \csname appendixmore\endcsname
+}
+\renewcommand*{\@@maybeautodot}[1]{%
+  \ifx #1\@stop\let\@@maybeautodot\relax
+  \else
+    \ifx #1\harfi \@autodottrue\fi
+    \ifx #1\adadi \@autodottrue\fi
+    \ifx #1\tartibi \@autodottrue\fi
+    \ifx #1\Alph \@autodottrue\fi
+    \ifx #1\alph \@autodottrue\fi
+    \ifx #1\Roman \@autodottrue\fi
+    \ifx #1\roman \@autodottrue\fi
+    \ifx #1\@harfi \@autodottrue\fi
+    \ifx #1\@adadi \@autodottrue\fi
+    \ifx #1\@tartibi \@autodottrue\fi
+    \ifx #1\@Alph \@autodottrue\fi
+    \ifx #1\@alph \@autodottrue\fi
+    \ifx #1\@Roman \@autodottrue\fi
+    \ifx #1\@roman \@autodottrue\fi
+    \ifx #1\romannumeral \@autodottrue\fi
+  \fi
+  \@@maybeautodot
+}
+%    \end{macrocode}
+% \iffalse
+%</scrartcl-xepersian.def>
 %<*tocloft-xepersian.def>
 % \fi
 % \part{tocloft-xepersian.def}



From vafa at mail.berlios.de  Tue Jun  9 16:09:00 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 9 Jun 2009 16:09:00 +0200
Subject: [Xepersian-development] r62 - trunk
Message-ID: <200906091409.n59E908O000099@sheep.berlios.de>

Author: vafa
Date: 2009-06-09 16:08:55 +0200 (Tue, 09 Jun 2009)
New Revision: 62

Modified:
   trunk/xepersian.dtx
Log:
added support for scrbook class

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-09 11:47:15 UTC (rev 61)
+++ trunk/xepersian.dtx	2009-06-09 14:08:55 UTC (rev 62)
@@ -89,6 +89,7 @@
 \generate{\file{refrep-xepersian.def}{\from{xepersian.dtx}{refrep-xepersian.def}}}
 \generate{\file{report-xepersian.def}{\from{xepersian.dtx}{report-xepersian.def}}}
 \generate{\file{scrartcl-xepersian.def}{\from{xepersian.dtx}{scrartcl-xepersian.def}}}
+\generate{\file{scrbook-xepersian.def}{\from{xepersian.dtx}{scrbook-xepersian.def}}}
 \generate{\file{tocloft-xepersian.def}{\from{xepersian.dtx}{tocloft-xepersian.def}}}
 \generate{\file{xepersian-magazine.cls}{\from{xepersian.dtx}{xepersian-magazine.cls}}}
 \generate{\file{xepersian-mathsdigitspec.sty}{\from{xepersian.dtx}{xepersian-mathsdigitspec.sty}}}
@@ -158,7 +159,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 61}
+\def\xepersianrevision{revision 62}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -390,6 +391,7 @@
 \@ifclassloaded{bidimoderncv}{\input{bidimoderncv-xepersian.def}}{}
 \@ifclassloaded{report}{\input{report-xepersian.def}}{}
 \@ifclassloaded{scrartcl}{\input{scrartcl-xepersian.def}}{}
+\@ifclassloaded{scrbook}{\input{scrbook-xepersian.def}}{}
 \@ifclassloaded{xepersian-thesis}{\input{xepersian-thesis-xepersian.def}}{}
 \@ifclassloaded{amsbook}{\input{amsbook-xepersian.def}}{}
 \@ifclassloaded{bookest}{\input{bookest-xepersian.def}}{}
@@ -1761,6 +1763,53 @@
 %    \end{macrocode}
 % \iffalse
 %</scrartcl-xepersian.def>
+%<*scrbook-xepersian.def>
+% \fi
+% \part{scrbook-xepersian.def}
+%    \begin{macrocode}
+\renewcommand*\descfont{\if at RTL\persiansffamily\else\sffamily\fi\bfseries}
+\DeclareOldFontCommand{\sf}{\normalfont\if at RTL\persiansffamily\else\sffamily\fi}{\mathsf}
+\DeclareOldFontCommand{\tt}{\normalfont\if at RTL\persianttfamily\else\ttfamily\fi}{\mathtt}
+\DeclareOldFontCommand{\sfb}{\normalfont\if at RTL\persiansffamily\else\sffamily\fi\bfseries}{%
+  \@nomath\sfb}
+\renewcommand*\sectfont{\normalcolor\if at RTL\persiansffamily\else\sffamily\fi\bfseries}
+\newkomafont{dictum-xepersian}{\normalfont\normalcolor\if at RTL\persiansffamily\else\sffamily\fi\small}
+\renewcommand*\frontmatter{%
+  \if at twoside\cleardoubleoddpage\else\clearpage\fi
+  \@mainmatterfalse\pagenumbering{harfi}%
+}
+\renewcommand*{\thepart}{\@tartibi\c at part}
+\renewcommand*\appendix{\par%
+  \setcounter{chapter}{0}%
+  \setcounter{section}{0}%
+  \gdef\@chapapp{\appendixname}%
+  \gdef\thechapter{\@harfi\c at chapter}%
+  \csname appendixmore\endcsname
+}
+\renewcommand*{\@@maybeautodot}[1]{%
+  \ifx #1\@stop\let\@@maybeautodot\relax
+  \else
+    \ifx #1\harfi \@autodottrue\fi
+    \ifx #1\adadi \@autodottrue\fi
+    \ifx #1\tartibi \@autodottrue\fi
+    \ifx #1\Alph \@autodottrue\fi
+    \ifx #1\alph \@autodottrue\fi
+    \ifx #1\Roman \@autodottrue\fi
+    \ifx #1\roman \@autodottrue\fi
+    \ifx #1\@harfi \@autodottrue\fi
+    \ifx #1\@adadi \@autodottrue\fi
+    \ifx #1\@tartibi \@autodottrue\fi
+    \ifx #1\@Alph \@autodottrue\fi
+    \ifx #1\@alph \@autodottrue\fi
+    \ifx #1\@Roman \@autodottrue\fi
+    \ifx #1\@roman \@autodottrue\fi
+    \ifx #1\romannumeral \@autodottrue\fi
+  \fi
+  \@@maybeautodot
+}
+%    \end{macrocode}
+% \iffalse
+%</scrbook-xepersian.def>
 %<*tocloft-xepersian.def>
 % \fi
 % \part{tocloft-xepersian.def}



From vafa at mail.berlios.de  Wed Jun 10 08:01:34 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Wed, 10 Jun 2009 08:01:34 +0200
Subject: [Xepersian-development] r63 - trunk
Message-ID: <200906100601.n5A61Ykk004697@sheep.berlios.de>

Author: vafa
Date: 2009-06-10 08:01:29 +0200 (Wed, 10 Jun 2009)
New Revision: 63

Modified:
   trunk/xepersian.dtx
Log:
added support for scrreprt

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-09 14:08:55 UTC (rev 62)
+++ trunk/xepersian.dtx	2009-06-10 06:01:29 UTC (rev 63)
@@ -90,6 +90,7 @@
 \generate{\file{report-xepersian.def}{\from{xepersian.dtx}{report-xepersian.def}}}
 \generate{\file{scrartcl-xepersian.def}{\from{xepersian.dtx}{scrartcl-xepersian.def}}}
 \generate{\file{scrbook-xepersian.def}{\from{xepersian.dtx}{scrbook-xepersian.def}}}
+\generate{\file{scrreprt-xepersian.def}{\from{xepersian.dtx}{scrreprt-xepersian.def}}}
 \generate{\file{tocloft-xepersian.def}{\from{xepersian.dtx}{tocloft-xepersian.def}}}
 \generate{\file{xepersian-magazine.cls}{\from{xepersian.dtx}{xepersian-magazine.cls}}}
 \generate{\file{xepersian-mathsdigitspec.sty}{\from{xepersian.dtx}{xepersian-mathsdigitspec.sty}}}
@@ -159,7 +160,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 62}
+\def\xepersianrevision{revision 63}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -392,6 +393,7 @@
 \@ifclassloaded{report}{\input{report-xepersian.def}}{}
 \@ifclassloaded{scrartcl}{\input{scrartcl-xepersian.def}}{}
 \@ifclassloaded{scrbook}{\input{scrbook-xepersian.def}}{}
+\@ifclassloaded{scrreprt}{\input{scrreprt-xepersian.def}}{}
 \@ifclassloaded{xepersian-thesis}{\input{xepersian-thesis-xepersian.def}}{}
 \@ifclassloaded{amsbook}{\input{amsbook-xepersian.def}}{}
 \@ifclassloaded{bookest}{\input{bookest-xepersian.def}}{}
@@ -1810,6 +1812,49 @@
 %    \end{macrocode}
 % \iffalse
 %</scrbook-xepersian.def>
+%<*scrreprt-xepersian.def>
+% \fi
+% \part{scrreprt-xepersian.def}
+%    \begin{macrocode}
+\renewcommand*\descfont{\if at RTL\persiansffamily\else\sffamily\fi\bfseries}
+\DeclareOldFontCommand{\sf}{\normalfont\if at RTL\persiansffamily\else\sffamily\fi}{\mathsf}
+\DeclareOldFontCommand{\tt}{\normalfont\if at RTL\persianttfamily\else\ttfamily\fi}{\mathtt}
+\DeclareOldFontCommand{\sfb}{\normalfont\if at RTL\persiansffamily\else\sffamily\fi\bfseries}{%
+  \@nomath\sfb}
+\renewcommand*\sectfont{\normalcolor\if at RTL\persiansffamily\else\sffamily\fi\bfseries}
+\newkomafont{dictum-xepersian}{\normalfont\normalcolor\if at RTL\persiansffamily\else\sffamily\fi\small}
+\renewcommand*{\thepart}{\@tartibi\c at part}
+\renewcommand*\appendix{\par%
+  \setcounter{chapter}{0}%
+  \setcounter{section}{0}%
+  \gdef\@chapapp{\appendixname}%
+  \gdef\thechapter{\@harfi\c at chapter}%
+  \csname appendixmore\endcsname
+}
+\renewcommand*{\@@maybeautodot}[1]{%
+  \ifx #1\@stop\let\@@maybeautodot\relax
+  \else
+    \ifx #1\harfi \@autodottrue\fi
+    \ifx #1\adadi \@autodottrue\fi
+    \ifx #1\tartibi \@autodottrue\fi
+    \ifx #1\Alph \@autodottrue\fi
+    \ifx #1\alph \@autodottrue\fi
+    \ifx #1\Roman \@autodottrue\fi
+    \ifx #1\roman \@autodottrue\fi
+    \ifx #1\@harfi \@autodottrue\fi
+    \ifx #1\@adadi \@autodottrue\fi
+    \ifx #1\@tartibi \@autodottrue\fi
+    \ifx #1\@Alph \@autodottrue\fi
+    \ifx #1\@alph \@autodottrue\fi
+    \ifx #1\@Roman \@autodottrue\fi
+    \ifx #1\@roman \@autodottrue\fi
+    \ifx #1\romannumeral \@autodottrue\fi
+  \fi
+  \@@maybeautodot
+}
+%    \end{macrocode}
+% \iffalse
+%</scrreprt-xepersian.def>
 %<*tocloft-xepersian.def>
 % \fi
 % \part{tocloft-xepersian.def}



From vafa at mail.berlios.de  Wed Jun 10 12:59:19 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Wed, 10 Jun 2009 12:59:19 +0200
Subject: [Xepersian-development] r64 - trunk
Message-ID: <200906101059.n5AAxJ6p016574@sheep.berlios.de>

Author: vafa
Date: 2009-06-10 12:59:12 +0200 (Wed, 10 Jun 2009)
New Revision: 64

Modified:
   trunk/xepersian.dtx
Log:
added support for minitoc

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-10 06:01:29 UTC (rev 63)
+++ trunk/xepersian.dtx	2009-06-10 10:59:12 UTC (rev 64)
@@ -85,6 +85,7 @@
 \generate{\file{kashida-xepersian.def}{\from{xepersian.dtx}{kashida-xepersian.def}}}
 \generate{\file{listings-xepersian.def}{\from{xepersian.dtx}{listings-xepersian.def}}}
 \generate{\file{bidimemoir-xepersian.def}{\from{xepersian.dtx}{bidimemoir-xepersian.def}}}
+\generate{\file{minitoc-xepersian.def}{\from{xepersian.dtx}{minitoc-xepersian.def}}}
 \generate{\file{misccommandsenvironments-ltx.def}{\from{xepersian.dtx}{misccommandsenvironments-ltx.def}}}
 \generate{\file{refrep-xepersian.def}{\from{xepersian.dtx}{refrep-xepersian.def}}}
 \generate{\file{report-xepersian.def}{\from{xepersian.dtx}{report-xepersian.def}}}
@@ -160,7 +161,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 63}
+\def\xepersianrevision{revision 64}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -386,6 +387,7 @@
 \@ifpackageloaded{algorithm}{\input{algorithm-xepersian.def}}{}
 \@ifpackageloaded{bidi}{\input{footnote-bidi-xepersian.def}}{}
 \@ifpackageloaded{enumerate}{\input{enumerate-xepersian.def}}{}
+\@ifpackageloaded{minitoc}{\input{minitoc-xepersian.def}}{}
 \@ifpackageloaded{tocloft}{\input{tocloft-xepersian.def}}{}
 \@ifclassloaded{article}{\input{article-xepersian.def}}{}
 \@ifclassloaded{amsart}{\input{amsart-xepersian.def}}{}
@@ -1509,6 +1511,22 @@
 %    \end{macrocode}
 % \iffalse
 %</enumerate-xepersian.def>
+%<*minitoc-xepersian.def>
+% \fi
+% \part{minitoc-xepersian.def}
+%    \begin{macrocode}
+\def\ptctitle{\if at RTL ????? ?????\else Table of Contents\fi}%
+\def\plftitle{\if at RTL ???? ??????\else List of Figures\fi}%
+\def\plttitle{\if at RTL ???? ?????\else List of Tables\fi}%
+\def\mtctitle{\if at RTL ??????\else Contents\fi}%
+\def\mlftitle{\if at RTL ?????\else Figures\fi}%
+\def\mlttitle{\if at RTL ?????\else Tables\fi}%
+\def\stctitle{\if at RTL ??????\else Contents\fi}%
+\def\slftitle{\if at RTL ?????\else Figures\fi}%
+\def\slttitle{\if at RTL ?????\else Tables\fi}%
+%    \end{macrocode}
+% \iffalse
+%</minitoc-xepersian.def>
 %<*environments-ltx.def>
 % \fi
 % \part{environments-ltx.def}



From vafa at mail.berlios.de  Wed Jun 10 16:44:41 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Wed, 10 Jun 2009 16:44:41 +0200
Subject: [Xepersian-development] r65 - trunk
Message-ID: <200906101444.n5AEifk3030882@sheep.berlios.de>

Author: vafa
Date: 2009-06-10 16:44:37 +0200 (Wed, 10 Jun 2009)
New Revision: 65

Modified:
   trunk/xepersian.dtx
Log:
added support for rapport3 class

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-10 10:59:12 UTC (rev 64)
+++ trunk/xepersian.dtx	2009-06-10 14:44:37 UTC (rev 65)
@@ -89,6 +89,7 @@
 \generate{\file{misccommandsenvironments-ltx.def}{\from{xepersian.dtx}{misccommandsenvironments-ltx.def}}}
 \generate{\file{refrep-xepersian.def}{\from{xepersian.dtx}{refrep-xepersian.def}}}
 \generate{\file{report-xepersian.def}{\from{xepersian.dtx}{report-xepersian.def}}}
+\generate{\file{rapport3-xepersian.def}{\from{xepersian.dtx}{rapport3-xepersian.def}}}
 \generate{\file{scrartcl-xepersian.def}{\from{xepersian.dtx}{scrartcl-xepersian.def}}}
 \generate{\file{scrbook-xepersian.def}{\from{xepersian.dtx}{scrbook-xepersian.def}}}
 \generate{\file{scrreprt-xepersian.def}{\from{xepersian.dtx}{scrreprt-xepersian.def}}}
@@ -161,7 +162,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 64}
+\def\xepersianrevision{revision 65}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -393,6 +394,7 @@
 \@ifclassloaded{amsart}{\input{amsart-xepersian.def}}{}
 \@ifclassloaded{bidimoderncv}{\input{bidimoderncv-xepersian.def}}{}
 \@ifclassloaded{report}{\input{report-xepersian.def}}{}
+\@ifclassloaded{rapport3}{\input{rapport3-xepersian.def}}{}
 \@ifclassloaded{scrartcl}{\input{scrartcl-xepersian.def}}{}
 \@ifclassloaded{scrbook}{\input{scrbook-xepersian.def}}{}
 \@ifclassloaded{scrreprt}{\input{scrreprt-xepersian.def}}{}
@@ -1741,6 +1743,19 @@
 %    \end{macrocode}
 % \iffalse
 %</report-xepersian.def>
+%<*rapport3-xepersian.def>
+% \fi
+% \part{rapport3-xepersian.def}
+%    \begin{macrocode}
+\renewcommand*\thepart{\@tartibi\c at part}
+\renewcommand*\appendix{\par
+  \setcounter{chapter}{0}%
+  \setcounter{section}{0}%
+  \gdef\@chapapp{\appendixname}%
+  \gdef\thechapter{\@harfi\c at chapter}}
+%    \end{macrocode}
+% \iffalse
+%</rapport3-xepersian.def>
 %<*scrartcl-xepersian.def>
 % \fi
 % \part{scrartcl-xepersian.def}



From vafa at mail.berlios.de  Sat Jun 13 10:04:49 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Sat, 13 Jun 2009 10:04:49 +0200
Subject: [Xepersian-development] r66 - trunk
Message-ID: <200906130804.n5D84nmj004993@sheep.berlios.de>

Author: vafa
Date: 2009-06-13 10:04:44 +0200 (Sat, 13 Jun 2009)
New Revision: 66

Modified:
   trunk/xepersian.dtx
Log:
added caption name for backref package

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-10 14:44:37 UTC (rev 65)
+++ trunk/xepersian.dtx	2009-06-13 08:04:44 UTC (rev 66)
@@ -70,6 +70,7 @@
 \generate{\file{amsart-xepersian.def}{\from{xepersian.dtx}{amsart-xepersian.def}}}
 \generate{\file{amsbook-xepersian.def}{\from{xepersian.dtx}{amsbook-xepersian.def}}}
 \generate{\file{article-xepersian.def}{\from{xepersian.dtx}{article-xepersian.def}}}
+\generate{\file{backref-xepersian.def}{\from{xepersian.dtx}{backref-xepersian.def}}}
 \generate{\file{beamer-xepersian.def}{\from{xepersian.dtx}{beamer-xepersian.def}}}
 \generate{\file{bidimoderncv-xepersian.def}{\from{xepersian.dtx}{bidimoderncv-xepersian.def}}}
 \generate{\file{bookest-xepersian.def}{\from{xepersian.dtx}{bookest-xepersian.def}}}
@@ -162,7 +163,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 65}
+\def\xepersianrevision{revision 66}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -386,6 +387,7 @@
 \@ifpackageloaded{listings}{\input{listings-xepersian.def}}{}
 \@ifpackageloaded{algorithmic}{\input{algorithmic-xepersian.def}}{}
 \@ifpackageloaded{algorithm}{\input{algorithm-xepersian.def}}{}
+\@ifpackageloaded{backref}{\input{backref-xepersian.def}}{}
 \@ifpackageloaded{bidi}{\input{footnote-bidi-xepersian.def}}{}
 \@ifpackageloaded{enumerate}{\input{enumerate-xepersian.def}}{}
 \@ifpackageloaded{minitoc}{\input{minitoc-xepersian.def}}{}
@@ -472,6 +474,14 @@
 %    \end{macrocode}
 % \iffalse
 %</article-xepersian.def>
+%<*backref-xepersian.def>
+% \fi
+% \part{backref-xepersian.def}
+%    \begin{macrocode}
+\def\backrefpagesname{\if at RTL ?????\else pages\fi}
+%    \end{macrocode}
+% \iffalse
+%</backref-xepersian.def>
 %<*beamer-xepersian.def>
 % \fi
 % \part{beamer-xepersian.def}



From vafa at mail.berlios.de  Sat Jun 13 15:42:05 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Sat, 13 Jun 2009 15:42:05 +0200
Subject: [Xepersian-development] r67 - trunk
Message-ID: <200906131342.n5DDg5tg020999@sheep.berlios.de>

Author: vafa
Date: 2009-06-13 15:42:00 +0200 (Sat, 13 Jun 2009)
New Revision: 67

Modified:
   trunk/xepersian.dtx
Log:
redefine logo macros so that they do not need to be inside \lr{...} macro

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-13 08:04:44 UTC (rev 66)
+++ trunk/xepersian.dtx	2009-06-13 13:42:00 UTC (rev 67)
@@ -163,7 +163,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 66}
+\def\xepersianrevision{revision 67}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -303,10 +303,15 @@
     \small
     \@starttoc{toc}%
   \end{multicols}}
-\def\reflect#1{{\setbox0=\hbox{#1}\rlap{\kern0.5\wd0
-  \special{x:gsave}\special{x:scale -1 1}}\box0 \special{x:grestore}}}
-\def\XePersian{\leavevmode$\smash{\hbox{X\lower.5ex
-  \hbox{\kern-.125em\reflect{E}}Persian}}$}
+\def\XePersian{\lr{\leavevmode$\smash{\hbox{X\lower.5ex
+  \hbox{\kern-.125em\reflect{E}}Persian}}$}}
+\def\TeX{\lr{\@@TeX}}
+\def\LaTeX{\lr{\@@LaTeX}}
+\def\LaTeXe{\lr{\@@LaTeXe}}
+\let\origin at XeTeX\XeTeX
+\def\XeTeX{\lr{\origin at XeTeX}}
+\let\origin at XeLaTeX\XeLaTeX
+\def\XeLaTeX{\lr{\origin at XeLaTeX}}
 \def\figurename{???}
 \def\tablename{????}
 \def\contentsname{????? ?????}



From vafa at mail.berlios.de  Sun Jun 14 11:26:20 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Sun, 14 Jun 2009 11:26:20 +0200
Subject: [Xepersian-development] r68 - trunk
Message-ID: <200906140926.n5E9QKa3007683@sheep.berlios.de>

Author: vafa
Date: 2009-06-14 11:26:16 +0200 (Sun, 14 Jun 2009)
New Revision: 68

Modified:
   trunk/xepersian.dtx
Log:
captions should be bilingual

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-13 13:42:00 UTC (rev 67)
+++ trunk/xepersian.dtx	2009-06-14 09:26:16 UTC (rev 68)
@@ -163,7 +163,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 67}
+\def\xepersianrevision{revision 68}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -312,24 +312,24 @@
 \def\XeTeX{\lr{\origin at XeTeX}}
 \let\origin at XeLaTeX\XeLaTeX
 \def\XeLaTeX{\lr{\origin at XeLaTeX}}
-\def\figurename{???}
-\def\tablename{????}
-\def\contentsname{????? ?????}
-\def\listfigurename{???? ??????}
-\def\listtablename{???? ?????}
-\def\appendixname{?????}
-\def\indexname{?????}
-\def\refname{?????}
-\def\abstractname{?????}
-\def\partname{???}
-\def\datename{?????:}
-\def\bibname{?????????}
-\def\chaptername{???}
-\def\ccname{??????}
-\def\enclname{?????}
-\def\pagename{????}
-\def\headtoname{??}
-\def\proofname{?????}
+\def\figurename{\if at RTL ???\else Figure\fi}
+\def\tablename{\if at RTL ????\else Table\fi}
+\def\contentsname{\if at RTL ????? ?????\else Contents\fi}
+\def\listfigurename{\if at RTL ???? ??????\else List of Figures\fi}
+\def\listtablename{\if at RTL ???? ?????\else List of Tables\fi}
+\def\appendixname{\if at RTL ?????\else Appendix\fi}
+\def\indexname{\if at RTL ?????\else Index\fi}
+\def\refname{\if at RTL ?????\else References\fi}
+\def\abstractname{\if at RTL ?????\else Abstract\fi}
+\def\partname{\if at RTL ???\else Part\fi}
+\def\datename{\if at RTL ?????:\else Date:\fi}
+\def\bibname{\if at RTL ?????????\else Bibliography\fi}
+\def\chaptername{\if at RTL ???\else Chapter\fi}
+\def\ccname{\if at RTL ??????\else cc\fi}
+\def\enclname{\if at RTL ?????\else encl\fi}
+\def\pagename{\if at RTL ????\else Page\fi}
+\def\headtoname{\if at RTL ??\else To\fi}
+\def\proofname{\if at RTL ?????\else Proof\fi}
 \def\@harfi#1{\ifcase#1\or ???\char"200D\or ?\or ?\or ?\or ?\or
 ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\or
 ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\or ?\else\@ctrerr\fi}
@@ -420,10 +420,8 @@
 % \fi
 % \part{algorithmic-xepersian.def}
 %    \begin{macrocode}
-\if at RTL%
-\def\algorithmicrequire{\textbf{?????:}}
-\def\algorithmicensure{\textbf{?????:}}
-\fi
+\def\algorithmicrequire{\if at RTL\textbf{?????:}\else\textbf{Require:}\fi}
+\def\algorithmicensure{\if at RTL\textbf{?????:}\else\textbf{Ensure:}\fi}
 %    \end{macrocode}
 % \iffalse
 %</algorithmic-xepersian.def>
@@ -431,11 +429,9 @@
 % \fi
 % \part{algorithm-xepersian.def}
 %    \begin{macrocode}
-\if at RTL%
-\def\ALG at name{????????}
+\def\ALG at name{\if at RTL ????????\else Algorithm\fi}
 \def\ALGS at name{???????????}
-\def\listalgorithmname{???? \ALGS at name}
-\fi
+\def\listalgorithmname{\if at RTL ???? \ALGS at name\else List of \ALG at name s\fi}
 %    \end{macrocode}
 % \iffalse
 %</algorithm-xepersian.def>



From vafa at mail.berlios.de  Mon Jun 15 01:31:18 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Mon, 15 Jun 2009 01:31:18 +0200
Subject: [Xepersian-development] r69 - trunk
Message-ID: <200906142331.n5ENVIpK021816@sheep.berlios.de>

Author: vafa
Date: 2009-06-15 01:30:51 +0200 (Mon, 15 Jun 2009)
New Revision: 69

Added:
   trunk/ftxe-0.3.py
Removed:
   trunk/ftxe-0.2.py
Log:
added the new version of farsitex-xepersian converter per Mostafa

Deleted: trunk/ftxe-0.2.py
===================================================================
--- trunk/ftxe-0.2.py	2009-06-14 09:26:16 UTC (rev 68)
+++ trunk/ftxe-0.2.py	2009-06-14 23:30:51 UTC (rev 69)
@@ -1,490 +0,0 @@
-#########################################
-#       General Public License          #
-#       Author:  Mostafa Vahedi         #
-#       Date:    8 June 2009            #
-#       Version  0.2                    #
-#########################################
-
-import codecs
-
-import sys
-
-
-ft_numerical = [
-chr(0xB9),	# 	Arabic Thoushads Seperator
-chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
-]
-
-
-ft_vowels = [
-chr(0xB0),	#	ARABIC FATHA
-chr(0xB1),	#	ARABIC KASRA
-chr(0xB2),	#	ARABIC DAMMA
-chr(0xB3),	#	ARABIC FATHATAN
-chr(0xB4),	#	ARABIC SHADDA
-chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB),	#	ARABIC HAMZA ABOVE
-chr(0xC4) 	#	ARABIC SUKUN
-]
-
-ft_non_joiners = [
-chr(0x8F)	#	ARABIC LETTER HAMZA
-]
-
-ft_bidi_joiners_initial = [
-chr(0xE4),	#	ARABIC LETTER AIN, initial form
-chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
-chr(0xFB) 	#	ARABIC LETTER HEH, initial form
-]
-
-ft_bidi_joiners_medial = [
-chr(0xE3),	#	ARABIC LETTER AIN, medial form
-chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
-chr(0xFA) 	#	ARABIC LETTER HEH, medial form
-]
-
-ft_bidi_joiners_final = [
-chr(0xE2),	#	ARABIC LETTER AIN, final form
-chr(0xE6),	#	ARABIC LETTER GHAIN, final form
-chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
-]
-
-ft_bidi_joiners_isolated = [
-chr(0xE1),	#	ARABIC LETTER AIN, isolated form
-chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
-chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
-]
-
-ft_bidi_joiners_initial_medial = [
-chr(0x8B),	#	ARABIC TATWEEL
-chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
-chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
-chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
-chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
-chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
-chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
-chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
-]
-
-ft_bidi_joiners_final_isolated = [
-chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
-chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
-chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
-chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
-chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
-chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
-chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
-chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
-]
-
-ft_right_joiners_final = [
-chr(0x91)	#	ARABIC LETTER ALEF, final form
-]
-
-ft_right_joiners_isolated = [
-chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x90)	#	ARABIC LETTER ALEF, isolated form
-]
-
-ft_right_joiners_final_isolated = [
-chr(0xA2),	#	ARABIC LETTER DAL
-chr(0xA3),	#	ARABIC LETTER THAL
-chr(0xA4),	#	ARABIC LETTER REH
-chr(0xA5),	#	ARABIC LETTER ZAIN
-chr(0xA6),	#	ARABIC LETTER JEH
-chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
-chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF8)	#	ARABIC LETTER WAW
-]
-
-
-table_FT_UN = {
-chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
-chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
-chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
-chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
-chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
-chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
-chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
-chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
-chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
-chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
-chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
-chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
-chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
-chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
-chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
-chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
-chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
-chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
-chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
-chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
-chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
-chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
-chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
-chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
-chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
-chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
-chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
-chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
-chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
-chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
-chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
-chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
-chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
-chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
-chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
-chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
-chr(0xB5) : [u'\u0023'],	# * #
-chr(0xB6) : [u'\u0024'],	# * $
-chr(0xB7) : [u'\u0025'],	# * %
-chr(0xB8) : [u'\u0026'],	# * &
-chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
-chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
-chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
-chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
-chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
-chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
-chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
-chr(0xC5) : [u'\u002D'],	# * -
-chr(0xC6) : [u'\u002E'],	# * FULL STOP
-chr(0xC7) : [u'\u002F'],	# * /
-chr(0xC8) : [u'\u002A'],	# * *
-chr(0xC9) : [u'\u007E'],	# * ~
-chr(0xCA) : [u'\u003A'],	# * COLON
-chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
-chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
-chr(0xCD) : [u'\u002B'],	# * +
-chr(0xCE) : [u'\u003D'],	# * =
-chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
-# chr(0xD0) : [u'\u0040'],	# * @
-chr(0xD0) : [u''],	        # * @
-chr(0xD1) : [u'\u005D'],	# * [
-chr(0xD2) : [u'\u005C'],	# * \
-chr(0xD3) : [u'\u005B'],	# * ]
-chr(0xD4) : [u'\u005E'],	# * ^
-chr(0xD5) : [u'\u005F'],	# * _
-chr(0xD6) : [u'\u0060'],	# * `
-chr(0xD7) : [u'\u007D'],	# * {
-chr(0xD8) : [u'\u007C'],	# * |
-chr(0xDA) : [u'\u0020'],	# * SPACE
-chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
-chr(0xDE) : [u'\u007B'],	# * }
-chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
-chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
-chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
-chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
-chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
-chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
-chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
-chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
-chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
-chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
-chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
-chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
-chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
-chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
-chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
-chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
-chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
-chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
-}
-
-F_SLASH = chr(0xD2)
-F_PRNT_OPEN = chr(0xDE)
-F_AT_SIGN = chr(0xD0)
-
-# latex and farsitex commands whose first parameter does not need \lr{...}
-commands = [ "begin", 
-"end",
-"input", "include", "includeonly",
-"hspace", "vspace", "hspace*", "vspace*",
-"label", "ref", "cite", "bibitem",
-"bibliographystyle",
-"parbox",
-"newenvironment", "newtheorem",
-"persianmathdigitsfamily",
-"fontfamily", "fontseries", "fontshape",
-"rmdefault", "sfdefault", "ttdefault",
-"bfdefault", "itdefault", "sldefault", "scdefault",
-"pagenumbering", "pagestyle", "thispagestyle",
-"setcounter", "stepcounter", "setlength", "addtolength"
-]
-
-
-def ft_is_numeric(ch):
-	if ((ch in ft_numerical) or 
-	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
-		return 1
-	return 0
-
-def ft_can_join_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_final) or
-	    (ch in ft_bidi_joiners_isolated) or
-	    (ch in ft_bidi_joiners_initial_medial) or
-	    (ch in ft_bidi_joiners_final_isolated)):
-    		return 1
-	return 0
-
-def ft_can_join_right(ch):
-	if (ft_can_join_left(ch) or 
-	    (ch in ft_right_joiners_final) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_right_joiners_final_isolated)):
-		return 1
-	return 0
-
-def ft_joining_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or 
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_initial_medial)):
-		return 1
-	return 0
-
-
-def ft_joining_right(ch):
-	if ((ch in ft_right_joiners_final) or
-	    (ch in ft_bidi_joiners_medial) or 
-	    (ch in ft_bidi_joiners_final)):
-		return 1
-	return 0
-
-def ft_not_right_joined(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_bidi_joiners_isolated)):
-		return 1
-	return 0
-
-def ft_adjust_shaping(text, i):
-	current = text[i]
-	u = u''
-	try:
-		u = table_FT_UN[current][0]
-	except KeyError:
-		return u''
-
-	#if you don't want shaping remove the following comment
-	#return u
-
-	if ((current in ft_vowels) or (ft_is_numeric(current))):
-		return u
-
-	#find next non-vowel character on the left
-	text_len = len(text)
-	next_index = i+1
-	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
-		next_index += 1
-
-	if (next_index == text_len):
-		next = ''
-	else:
-		next = text[next_index]
-
-	# if current letter is joining from left but next letter is or can not joining
-	if (ft_joining_left(current)):
-		if (not ft_can_join_right(next)):
-			u += u'\u200D' #ZWJ
-		elif (ft_not_right_joined(next)):
-			u += u'\u200D\u200C' #ZWJ+ZWNJ
-	# if current letter can join but next letter is joining from right
-	elif (ft_can_join_left(current)):
-		if (ft_joining_right(next)):
-			u += u'\u200C\u200D' #ZWNJ+ZWJ
-		elif (ft_can_join_right(next)):
-			u += u'\u200C' #ZWNJ
-	return u
-
-def ft_adjust_number(text):
-	result = u''
-	i = len(text)-1
-	while (i >= 0):
-		result += ft_adjust_shaping(text, i)
-		i -= 1
-	return result
-
-
-def map_ft_unicode(text):
-	mapped_text = u''
-
-	i = 0
-	while (i < len(text)):
-		if (ft_is_numeric(text[i])):
-			next_index = i
-			while ((next_index+1 < len(text)) and
-			       (ft_is_numeric(text[next_index+1]))):
-				next_index += 1
-			mapped_text += ft_adjust_number(text[i:next_index+1])
-			i = next_index+1
-			continue
-
-		mapped_text += ft_adjust_shaping(text, i)
-		i += 1
-	return mapped_text
-
-# Finds next token all of the same language
-def ft_next_part(line, i):
-	j = i
-	language_flag = (line[j]<chr(0x80))
-	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
-		j += 1
-	return j
-
-# Main body of the program 
-if len(sys.argv) <= 2:
-	print 'usage: python undk in_filename out_filename'
-	exit(0)
-
-###################################
-# Begin of main body of the program
-###################################
-filename = sys.argv[1]
-outfile = sys.argv[2]
-
-try:
-	f = open(filename, 'r')
-except IOError:
-	print "Can not open the input file: " + filename
-	exit(0)
-
-try:
-	of = codecs.open(outfile, encoding='utf-8', mode='w')
-except IOError:
-	print "Can not open the output file: " + outfile
-	exit(0)
-
-line_number = 0
-for line in f:
-	line_number += 1
-	output_line = u''
-	line_len = len(line)
-	
-	# remove new-line characters from end of line
-	if (line_len>1 and line[line_len-1] == '\n'):
-		line_len-=1
-	if (line_len>1 and line[line_len-1] == '\r'):
-		line_len-=1
-
-	# check line-direction character
-	line_direction_rtl = (line[0] == '<')
-	if (line[0] != '>') and (line[0] != '<'):
-		print "FORMAT ERROR AT LINE: " + str(line_number)
-		exit(0)
-
-	i = 1
-
-	while (i<line_len):
-		next_part_index = ft_next_part(line, i)
-		next_part = line[i:next_part_index]
-		next_part_latin = (line[i]<chr(0x80))
-		
-		# see if we should put \lr{...} for the current english expression
-		if line_direction_rtl and next_part_latin:
-			is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
-			is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
-			is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
-		
-			cmd_index = 0
-			while cmd_index < len(commands):
-				len_cmd = len(commands[cmd_index])+2
-				if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
-					break
-				cmd_index += 1
-			is_commands_group = cmd_index < len(commands)
-			is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
-
-		if next_part_latin:
-			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
-				output_line += u'\\lr{'
-			
-			output_line += next_part.encode( 'utf-8' )
-			
-			if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd) ):
-				output_line += u'}'
-		else:
-			if ( not line_direction_rtl):
-				output_line += u'\\rl{'
-				
-			output_line += map_ft_unicode(next_part)
-			
-			if (not line_direction_rtl):
-				output_line += u'}'
-				
-		i = next_part_index
-	# end of while			
-	
-	# write the processed line
-	output_line += u'\n'
-	of.write(output_line)
-	# end of line processing
-# end of file processing
-
-of.close()
-f.close()	

Added: trunk/ftxe-0.3.py
===================================================================
--- trunk/ftxe-0.3.py	2009-06-14 09:26:16 UTC (rev 68)
+++ trunk/ftxe-0.3.py	2009-06-14 23:30:51 UTC (rev 69)
@@ -0,0 +1,787 @@
+#########################################
+#       General Public License          #
+#       Author:  Mostafa Vahedi         #
+#       Date:    14 June 2009           #
+#       Version  0.3                    #
+#########################################
+
+import codecs
+
+import sys
+
+
+ft_numerical = [
+chr(0xB9),	# 	Arabic Thoushads Seperator
+chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
+]
+
+
+ft_vowels = [
+chr(0xB0),	#	ARABIC FATHA
+chr(0xB1),	#	ARABIC KASRA
+chr(0xB2),	#	ARABIC DAMMA
+chr(0xB3),	#	ARABIC FATHATAN
+chr(0xB4),	#	ARABIC SHADDA
+chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB),	#	ARABIC HAMZA ABOVE
+chr(0xC4) 	#	ARABIC SUKUN
+]
+
+ft_non_joiners = [
+chr(0x8F)	#	ARABIC LETTER HAMZA
+]
+
+ft_bidi_joiners_initial = [
+chr(0xE4),	#	ARABIC LETTER AIN, initial form
+chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
+chr(0xFB) 	#	ARABIC LETTER HEH, initial form
+]
+
+ft_bidi_joiners_medial = [
+chr(0xE3),	#	ARABIC LETTER AIN, medial form
+chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
+chr(0xFA) 	#	ARABIC LETTER HEH, medial form
+]
+
+ft_bidi_joiners_final = [
+chr(0xE2),	#	ARABIC LETTER AIN, final form
+chr(0xE6),	#	ARABIC LETTER GHAIN, final form
+chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
+]
+
+ft_bidi_joiners_isolated = [
+chr(0xE1),	#	ARABIC LETTER AIN, isolated form
+chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
+chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
+]
+
+ft_bidi_joiners_initial_medial = [
+chr(0x8B),	#	ARABIC TATWEEL
+chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
+chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
+chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
+chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
+chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
+chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
+chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
+]
+
+ft_bidi_joiners_final_isolated = [
+chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
+chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
+chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
+chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
+chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
+chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
+chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
+chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
+]
+
+ft_right_joiners_final = [
+chr(0x91)	#	ARABIC LETTER ALEF, final form
+]
+
+ft_right_joiners_isolated = [
+chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x90)	#	ARABIC LETTER ALEF, isolated form
+]
+
+ft_right_joiners_final_isolated = [
+chr(0xA2),	#	ARABIC LETTER DAL
+chr(0xA3),	#	ARABIC LETTER THAL
+chr(0xA4),	#	ARABIC LETTER REH
+chr(0xA5),	#	ARABIC LETTER ZAIN
+chr(0xA6),	#	ARABIC LETTER JEH
+chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
+chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF8)	#	ARABIC LETTER WAW
+]
+
+
+table_FT_UN = {
+chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
+chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
+chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
+chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
+chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
+chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
+chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
+chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
+chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
+chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
+chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
+chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
+chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
+chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
+chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
+chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
+chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
+chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
+chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
+chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
+chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
+chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
+chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
+chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
+chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
+chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
+chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
+chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
+chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
+chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
+chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
+chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
+chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
+chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
+chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
+chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
+chr(0xB5) : [u'\u0023'],	# * #
+chr(0xB6) : [u'\u0024'],	# * $
+chr(0xB7) : [u'\u0025'],	# * %
+chr(0xB8) : [u'\u0026'],	# * &
+chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
+chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
+chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
+chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
+chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
+chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
+chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
+chr(0xC5) : [u'\u002D'],	# * -
+chr(0xC6) : [u'\u002E'],	# * FULL STOP
+chr(0xC7) : [u'\u002F'],	# * /
+chr(0xC8) : [u'\u002A'],	# * *
+chr(0xC9) : [u'\u007E'],	# * ~
+chr(0xCA) : [u'\u003A'],	# * COLON
+chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
+chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
+chr(0xCD) : [u'\u002B'],	# * +
+chr(0xCE) : [u'\u003D'],	# * =
+chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
+# chr(0xD0) : [u'\u0040'],	# * @
+chr(0xD0) : [u''],	        # * @
+chr(0xD1) : [u'\u005D'],	# * [
+chr(0xD2) : [u'\u005C'],	# * \
+chr(0xD3) : [u'\u005B'],	# * ]
+chr(0xD4) : [u'\u005E'],	# * ^
+chr(0xD5) : [u'\u005F'],	# * _
+chr(0xD6) : [u'\u0060'],	# * `
+chr(0xD7) : [u'\u007D'],	# * {
+chr(0xD8) : [u'\u007C'],	# * |
+chr(0xDA) : [u'\u0020'],	# * SPACE
+chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
+chr(0xDE) : [u'\u007B'],	# * }
+chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
+chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
+chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
+chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
+chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
+chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
+chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
+chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
+chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
+chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
+chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
+chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
+chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
+chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
+chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
+chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
+chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
+chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
+}
+
+F_SLASH = chr(0xD2)
+F_PRNT_OPEN = chr(0xDE)
+F_AT_SIGN = chr(0xD0)
+
+# latex and farsitex commands whose first parameter does not need \lr{...}
+commands = [ "begin", 
+"end",
+"input", "include", "includeonly",
+"hspace", "vspace", "hspace*", "vspace*",
+"label", "ref", "cite", "bibitem",
+"bibliographystyle",
+"parbox",
+"newenvironment", "newtheorem",
+"persianmathdigitsfamily",
+"fontfamily", "fontseries", "fontshape",
+"rmdefault", "sfdefault", "ttdefault",
+"bfdefault", "itdefault", "sldefault", "scdefault",
+"pagenumbering", "pagestyle", "thispagestyle",
+"setcounter", "stepcounter", "setlength", "addtolength"
+]
+
+
+def ft_is_numeric(ch):
+	if ((ch in ft_numerical) or 
+	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
+		return 1
+	return 0
+
+def ft_can_join_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_final) or
+	    (ch in ft_bidi_joiners_isolated) or
+	    (ch in ft_bidi_joiners_initial_medial) or
+	    (ch in ft_bidi_joiners_final_isolated)):
+    		return 1
+	return 0
+
+def ft_can_join_right(ch):
+	if (ft_can_join_left(ch) or 
+	    (ch in ft_right_joiners_final) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_right_joiners_final_isolated)):
+		return 1
+	return 0
+
+def ft_joining_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or 
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_initial_medial)):
+		return 1
+	return 0
+
+
+def ft_joining_right(ch):
+	if ((ch in ft_right_joiners_final) or
+	    (ch in ft_bidi_joiners_medial) or 
+	    (ch in ft_bidi_joiners_final)):
+		return 1
+	return 0
+
+def ft_not_right_joined(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_bidi_joiners_isolated)):
+		return 1
+	return 0
+
+def ft_adjust_shaping(text, i):
+	current = text[i]
+	u = u''
+	try:
+		u = table_FT_UN[current][0]
+	except KeyError:
+		return u''
+
+	#if you don't want shaping remove the following comment
+	#return u
+
+	if ((current in ft_vowels) or (ft_is_numeric(current))):
+		return u
+
+	#find next non-vowel character on the left
+	text_len = len(text)
+	next_index = i+1
+	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
+		next_index += 1
+
+	if (next_index == text_len):
+		next = ''
+	else:
+		next = text[next_index]
+
+	# if current letter is joining from left but next letter is or can not joining
+	if (ft_joining_left(current)):
+		if (not ft_can_join_right(next)):
+			u += u'\u200D' #ZWJ
+		elif (ft_not_right_joined(next)):
+			u += u'\u200D\u200C' #ZWJ+ZWNJ
+	# if current letter can join but next letter is joining from right
+	elif (ft_can_join_left(current)):
+		if (ft_joining_right(next)):
+			u += u'\u200C\u200D' #ZWNJ+ZWJ
+		elif (ft_can_join_right(next)):
+			u += u'\u200C' #ZWNJ
+	return u
+
+def ft_adjust_number(text):
+	result = u''
+	i = len(text)-1
+	while (i >= 0):
+		result += ft_adjust_shaping(text, i)
+		i -= 1
+	return result
+
+
+def map_ft_unicode(text):
+	mapped_text = u''
+
+	i = 0
+	while (i < len(text)):
+		if (ft_is_numeric(text[i])):
+			next_index = i
+			while ((next_index+1 < len(text)) and
+			       (ft_is_numeric(text[next_index+1]))):
+				next_index += 1
+			mapped_text += ft_adjust_number(text[i:next_index+1])
+			i = next_index+1
+			continue
+
+		mapped_text += ft_adjust_shaping(text, i)
+		i += 1
+	return mapped_text
+
+# Finds next token all of the same language
+def ft_next_part(line, i, line_len):
+	j = i
+	language_flag = (line[j]<chr(0x80))
+	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
+		j += 1
+	return j
+
+###############################################
+# from here all functions are used to translate
+# farsitex commands to xepersian commands
+###############################################
+
+def read_size(input,index,last_index):
+	dim_index = -1 
+	inch_index = input.find(u'in', index)
+	if (inch_index != -1):
+		dim_index = inch_index
+	mm_index = input.find(u'mm', index)
+	if (mm_index != -1):
+		if (dim_index == -1 or mm_index < index):
+			dim_index = mm_index
+	cm_index = input.find(u'cm', index)
+	if (cm_index != -1):
+		if (dim_index == -1 or cm_index < dim_index):
+			dim_index = cm_index
+	pt_index = input.find(u'pt', index)
+	if (pt_index != -1):
+		if (dim_index == -1 or pt_index < dim_index):
+			dim_index = pt_index
+	next_cmd = input.find(u'\\', index)
+	if (next_cmd == -1 and dim_index == -1):
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+	elif (next_cmd == -1 or (dim_index != -1 and next_cmd > dim_index)):
+		epsfxsize = input[index:dim_index+2]
+		return dim_index+2
+	elif (next_cmd != -1):
+		end_cmd = next_cmd+1
+		while (end_cmd < last_index and input[end_cmd].isalpha()):
+			end_cmd += 1
+		return end_cmd
+	else:
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+
+
+latex_options=[u'a4paper', u'a5paper', u'b5paper', 
+			   u'letterpaper', u'legalpaper', u'executivepaper', 
+			   u'landscape', u'10pt', u'11pt', u'12pt', 
+			   u'oneside', u'twoside', u'draft', 
+			   u'final', u'titlepage', u'notitlepage',
+			   u'onecolumn', u'twocolumn',
+			   u'leqno', u'fleqn']
+
+table_eq_packages = {
+u'poem'     : u'persianpoem',
+u'fmakeidx' : u'makeidx',
+u'ffancyhe' : u'fancyhdr',
+u'fmultico' : u'multicol'
+}
+
+farsitex_ignore_options = [u'persian', u'farsi', u'epsf', u'fgraphix']
+
+xepersian_preamble = u'\n\\usepackage{xepersian}\n\\usepackage{url}\n\\usepackage{fancyvrb}\n\\usepackage{setspace}\\onehalfspace\n\\settextfont[Scale=1]{XB Zar}\n\\setromantextfont[Scale=1]{Times New Roman}\n\\setdigitfont{XB Zar}\n\\let\\iranic\\it\n\\let\\siah\\bf\n\\let\\khabide\\sl\n\\def\\siahir{\\siah\\iranic}\n\\def\\siahkh{\\siah\\khabide}\n\\let\\farsi\\Persian\n\\let\\english\\Roman\n\\let\\farmbox\\mbox\n\\newcommand{\\ftxepmatrix}[1]{\\begin{pmatrix}#1\\end{pmatrix}}\n\\def\\FarsiTeX{\\lr{FarsiTeX}}\n'
+
+
+
+def find_eq_cmd(keyword):
+	try:
+		eq_cmd = table_eq_packages[keyword]
+	except KeyError:
+		eq_cmd = u''
+	return eq_cmd
+
+# \sayedar \tookhali
+# \verb|| -> \item[\verb||] or \section{\verb||}
+# \url{} -> does not show numbers
+# \kasre{} \alef{} ...
+# persian number as parameter: \multicolumn{8}, \addtocounter{page}{1}
+# pagenumbers are in english
+def translate_cmds(output_line):
+	global last_epsfxsize
+	global last_epsfxsize_line
+	global last_epsfysize
+	global last_epsfysize_line
+	global state
+
+	result = u''
+	line_len = len(output_line)
+	index = 0
+	if (state == 1): #\begin{verbatim}
+		end_verbatim = output_line.find('\\end{verbatim}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+14]
+		index = end_verbatim+14
+		state = 0
+	elif (state == 2): #\begin{verbatim*}
+		end_verbatim = output_line.find('\\end{verbatim*}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+15]
+		index = end_verbatim+15
+		state = 0
+	elif (output_line[0:14] == "\\documentstyle"):
+		result += u'\\documentclass'
+		#process options
+		last_index = output_line.find(u']')
+		index = 15
+		first_option = 1
+		preamble = xepersian_preamble
+		document_class = u''
+		while (index < last_index):
+			next_comma = output_line.find(u',',index,last_index)
+			if (next_comma == -1):
+				next_comma = last_index
+			option = output_line[index:next_comma]
+			index = next_comma+1
+			eq_cmd = find_eq_cmd(option)
+			if (eq_cmd != u''):
+				preamble += u'\\usepackage{' + eq_cmd + u'}\n'
+				continue
+			elif (option in farsitex_ignore_options):
+				continue
+			elif (option == u'sharifth'):
+				document_class = u'xepersian-thesis'
+				continue
+			elif (not option in latex_options):
+				preamble += u'\\usepackage{' + option + u'}\n'
+				continue
+	
+			if (first_option):
+				result += u'['
+			else:
+				result += u','
+			result += option
+			first_option = 0
+		#end while
+		if (not first_option):
+			result += u']'
+		index = output_line.find(u'}',last_index)
+		if (document_class == u''):
+			result += output_line[last_index+1:index+1]
+		else:
+			result += u'{' + document_class + u'}'
+		# I assume that nothing important is after
+		# \documentstyle[]{}, otherwise it may conflict
+		# with our preamble
+		if (index != -1):
+			result += output_line[index+1:]
+		result += preamble
+		return result
+	#end elif "documentstyle"
+
+	while (index < line_len):
+		next_index = output_line.find(u'\\', index)
+		comment_index = output_line.find(u'%', index)
+		if (next_index == -1):
+			result += output_line[index:]
+			break
+		elif (state == 1):
+			if (output_line[next_index:next_index+14] == u'\\end{verbatim}'):
+				result += output_line[index:next_index+14]
+				index = next_index+14
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (state == 2):
+			if (output_line[next_index:next_index+15] == u'\\end{verbatim*}'):
+				result += output_line[index:next_index+15]
+				index = next_index+15
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (comment_index != -1 and comment_index < next_index):
+			result += output_line[index:]
+			break
+		elif (output_line[next_index:next_index+14] == u"\\input{amssym}"):
+			result += u'\\usepackage{amssymb}'
+			index = next_index+14
+		elif (output_line[next_index:next_index+12] == u"\\input{epsf}"):
+			index = next_index+12
+		elif (output_line[next_index:next_index+15] == u"\\includeepspdf{"):
+			result += u'\\includegraphics{'
+			index = next_index+15
+		elif (output_line[next_index:next_index+16] == u"\\begin{verbatim}"):
+			result += output_line[index:next_index+16]
+			index = next_index+16
+			state = 1
+		elif (output_line[next_index:next_index+17] == u"\\begin{verbatim*}"):
+			result += output_line[index:next_index+17]
+			index = next_index+17
+			state = 2
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\headrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\headrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\footrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\footrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+10] == u"\\epsffile{"):
+			result += output_line[index:next_index]
+			result += u'\\includegraphics'
+			size_options = u''
+			if (line_number - last_epsfxsize_line <= 3):
+				size_options = u'width=' + last_epsfxsize
+			if (line_number - last_epsfysize_line <= 3):
+				if (size_options != u''):
+					size_options += u','
+				size_options += u'height=' + last_epsfysize
+			if (size_options != u''):
+				result += u'[' + size_options + u']'
+			end_prn = output_line.find(u'.eps}', next_index+9)
+
+			if (end_prn != -1):
+				result += output_line[next_index+9:end_prn] + u'}'
+				index = end_prn+5
+			else:
+				end_prn = output_line.find(u'.ps}', next_index+9)
+				if (end_prn != -1):
+					result += output_line[next_index+9:end_prn] + u'}'
+					index = end_prn+4
+				else:
+					end_prn = output_line.find(u'}', next_index+9)
+					result += output_line[next_index+9:end_prn+1]
+					index = end_prn+1
+		# I assume all the parameter of \epsfxsize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfxsize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfxsize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfxsize_line = line_number
+		# I assume all the parameter of \epsfysize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfysize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfysize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfysize_line = line_number
+		elif (output_line[next_index:next_index+6] == u"\\verb*"):
+			end_verb = output_line.find(output_line[next_index+6], next_index+7)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+5] == u"\\verb"):
+			end_verb = output_line.find(output_line[next_index+5], next_index+6)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+9] == u"\\pmatrix{"):
+			result += u'\\ftxepmatrix{'
+			index = next_index+9
+		elif (output_line[next_index:next_index+16] == u"\\begin{document}"):
+			result += u'\\begin{document}\n\\VerbatimFootnotes'
+			index = next_index+16
+		else:
+			result += output_line[index:next_index+2]
+			index = next_index+2
+	#end while
+	return result
+
+def convert_file(f, of, convert_cmds):
+	global state
+	global line_number
+	global last_epsfysize_line
+	global last_epsfxsize_line
+	global last_epsfxsize
+	global last_epsfysize
+
+	state = 0
+	line_number = 0
+	last_epsfysize_line = 0
+	last_epsfxsize_line = 0
+	last_epsfxsize = u''
+	last_epsfysize = u''
+
+	for line in f:
+		line_number += 1
+		print line_number
+		output_line = u''
+		line_len = len(line)
+		
+		# remove new-line characters from end of line
+		if (line_len>1 and line[line_len-1] == '\n'):
+			line_len-=1
+		if (line_len>1 and line[line_len-1] == '\r'):
+			line_len-=1
+		
+		# check line-direction character
+		line_direction_rtl = (line[0] == '<')
+		if (line[0] != '>') and (line[0] != '<'):
+			print "FORMAT ERROR AT LINE: " + str(line_number)
+			exit(0)
+	
+		i = 1
+	
+		while (i<line_len):
+			next_part_index = ft_next_part(line, i, line_len)
+			next_part = line[i:next_part_index]
+			next_part_latin = (line[i]<chr(0x80))
+			
+			# see if we should put \lr{...} for the current english expression
+			if line_direction_rtl and next_part_latin:
+				is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
+				is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
+				is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
+				is_verb_parameter = ( (line[i-6:i] == F_SLASH+"verb") and not isalpha(line[i]))
+				is_verb = (next_part_latin and (line[i:i+5]=='\\verb' or line[i:i+6]==' \\verb'))
+			
+				cmd_index = 0
+				while cmd_index < len(commands):
+					len_cmd = len(commands[cmd_index])+2
+					if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
+						break
+					cmd_index += 1
+				is_commands_group = cmd_index < len(commands)
+				is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
+	
+			if next_part_latin:
+				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
+					output_line += u'\\lr{'
+				if ( line_direction_rtl and is_verb):
+					output_line += u'\\beginL{}'
+				
+				output_line += next_part.encode( 'utf-8' )
+				
+				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
+					output_line += u'}'
+				if ( line_direction_rtl and is_verb):
+					output_line += u'\\endL{}'
+			else:
+				if ( not line_direction_rtl):
+					output_line += u'\\rl{'
+					
+				output_line += map_ft_unicode(next_part)
+				
+				if (not line_direction_rtl):
+					output_line += u'}'
+					
+			i = next_part_index
+		# end of while			
+		
+		# convert some of the FarsiTeX commands to XePersian commands
+		# only if it is requested
+		if (convert_cmds):
+			result = translate_cmds(output_line) 
+		else:
+			result = output_line
+		output_line = result + u'\n'
+		# write the processed line
+		of.write(output_line)
+		# end of line processing
+	# end of file processing
+
+###################################
+# Begin of main body of the program
+###################################
+
+# global variables
+line_number = 0
+last_epsfxsize = u''
+last_epsfxsize_line = 0
+last_epsfysize = u''
+last_epsfysize_line = 0
+state = 0
+
+if len(sys.argv) <= 2:
+	print 'usage: python undk in_filename out_filename'
+	exit(0)
+
+filename = sys.argv[1]
+outfile = sys.argv[2]
+
+try:
+	f = open(filename, 'r')
+except IOError:
+	print "Can not open the input file: " + filename
+	exit(0)
+
+try:
+	of = codecs.open(outfile, encoding='utf-8', mode='w')
+except IOError:
+	print "Can not open the output file: " + outfile
+	exit(0)
+
+convert_file(f, of, 1)
+	
+of.close()
+f.close()	



From vafa at mail.berlios.de  Tue Jun 16 02:28:19 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 16 Jun 2009 02:28:19 +0200
Subject: [Xepersian-development] r70 - trunk
Message-ID: <200906160028.n5G0SJEj028542@sheep.berlios.de>

Author: vafa
Date: 2009-06-16 02:28:13 +0200 (Tue, 16 Jun 2009)
New Revision: 70

Added:
   trunk/ftxe-0.4.py
Removed:
   trunk/ftxe-0.3.py
Log:
new version of farsitex-xepersian converter is added per Mostafa

Deleted: trunk/ftxe-0.3.py
===================================================================
--- trunk/ftxe-0.3.py	2009-06-14 23:30:51 UTC (rev 69)
+++ trunk/ftxe-0.3.py	2009-06-16 00:28:13 UTC (rev 70)
@@ -1,787 +0,0 @@
-#########################################
-#       General Public License          #
-#       Author:  Mostafa Vahedi         #
-#       Date:    14 June 2009           #
-#       Version  0.3                    #
-#########################################
-
-import codecs
-
-import sys
-
-
-ft_numerical = [
-chr(0xB9),	# 	Arabic Thoushads Seperator
-chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
-]
-
-
-ft_vowels = [
-chr(0xB0),	#	ARABIC FATHA
-chr(0xB1),	#	ARABIC KASRA
-chr(0xB2),	#	ARABIC DAMMA
-chr(0xB3),	#	ARABIC FATHATAN
-chr(0xB4),	#	ARABIC SHADDA
-chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB),	#	ARABIC HAMZA ABOVE
-chr(0xC4) 	#	ARABIC SUKUN
-]
-
-ft_non_joiners = [
-chr(0x8F)	#	ARABIC LETTER HAMZA
-]
-
-ft_bidi_joiners_initial = [
-chr(0xE4),	#	ARABIC LETTER AIN, initial form
-chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
-chr(0xFB) 	#	ARABIC LETTER HEH, initial form
-]
-
-ft_bidi_joiners_medial = [
-chr(0xE3),	#	ARABIC LETTER AIN, medial form
-chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
-chr(0xFA) 	#	ARABIC LETTER HEH, medial form
-]
-
-ft_bidi_joiners_final = [
-chr(0xE2),	#	ARABIC LETTER AIN, final form
-chr(0xE6),	#	ARABIC LETTER GHAIN, final form
-chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
-]
-
-ft_bidi_joiners_isolated = [
-chr(0xE1),	#	ARABIC LETTER AIN, isolated form
-chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
-chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
-]
-
-ft_bidi_joiners_initial_medial = [
-chr(0x8B),	#	ARABIC TATWEEL
-chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
-chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
-chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
-chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
-chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
-chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
-chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
-]
-
-ft_bidi_joiners_final_isolated = [
-chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
-chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
-chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
-chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
-chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
-chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
-chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
-chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
-]
-
-ft_right_joiners_final = [
-chr(0x91)	#	ARABIC LETTER ALEF, final form
-]
-
-ft_right_joiners_isolated = [
-chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x90)	#	ARABIC LETTER ALEF, isolated form
-]
-
-ft_right_joiners_final_isolated = [
-chr(0xA2),	#	ARABIC LETTER DAL
-chr(0xA3),	#	ARABIC LETTER THAL
-chr(0xA4),	#	ARABIC LETTER REH
-chr(0xA5),	#	ARABIC LETTER ZAIN
-chr(0xA6),	#	ARABIC LETTER JEH
-chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
-chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF8)	#	ARABIC LETTER WAW
-]
-
-
-table_FT_UN = {
-chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
-chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
-chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
-chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
-chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
-chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
-chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
-chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
-chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
-chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
-chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
-chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
-chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
-chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
-chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
-chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
-chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
-chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
-chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
-chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
-chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
-chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
-chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
-chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
-chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
-chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
-chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
-chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
-chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
-chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
-chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
-chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
-chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
-chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
-chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
-chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
-chr(0xB5) : [u'\u0023'],	# * #
-chr(0xB6) : [u'\u0024'],	# * $
-chr(0xB7) : [u'\u0025'],	# * %
-chr(0xB8) : [u'\u0026'],	# * &
-chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
-chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
-chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
-chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
-chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
-chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
-chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
-chr(0xC5) : [u'\u002D'],	# * -
-chr(0xC6) : [u'\u002E'],	# * FULL STOP
-chr(0xC7) : [u'\u002F'],	# * /
-chr(0xC8) : [u'\u002A'],	# * *
-chr(0xC9) : [u'\u007E'],	# * ~
-chr(0xCA) : [u'\u003A'],	# * COLON
-chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
-chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
-chr(0xCD) : [u'\u002B'],	# * +
-chr(0xCE) : [u'\u003D'],	# * =
-chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
-# chr(0xD0) : [u'\u0040'],	# * @
-chr(0xD0) : [u''],	        # * @
-chr(0xD1) : [u'\u005D'],	# * [
-chr(0xD2) : [u'\u005C'],	# * \
-chr(0xD3) : [u'\u005B'],	# * ]
-chr(0xD4) : [u'\u005E'],	# * ^
-chr(0xD5) : [u'\u005F'],	# * _
-chr(0xD6) : [u'\u0060'],	# * `
-chr(0xD7) : [u'\u007D'],	# * {
-chr(0xD8) : [u'\u007C'],	# * |
-chr(0xDA) : [u'\u0020'],	# * SPACE
-chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
-chr(0xDE) : [u'\u007B'],	# * }
-chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
-chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
-chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
-chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
-chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
-chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
-chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
-chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
-chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
-chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
-chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
-chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
-chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
-chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
-chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
-chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
-chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
-chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
-}
-
-F_SLASH = chr(0xD2)
-F_PRNT_OPEN = chr(0xDE)
-F_AT_SIGN = chr(0xD0)
-
-# latex and farsitex commands whose first parameter does not need \lr{...}
-commands = [ "begin", 
-"end",
-"input", "include", "includeonly",
-"hspace", "vspace", "hspace*", "vspace*",
-"label", "ref", "cite", "bibitem",
-"bibliographystyle",
-"parbox",
-"newenvironment", "newtheorem",
-"persianmathdigitsfamily",
-"fontfamily", "fontseries", "fontshape",
-"rmdefault", "sfdefault", "ttdefault",
-"bfdefault", "itdefault", "sldefault", "scdefault",
-"pagenumbering", "pagestyle", "thispagestyle",
-"setcounter", "stepcounter", "setlength", "addtolength"
-]
-
-
-def ft_is_numeric(ch):
-	if ((ch in ft_numerical) or 
-	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
-		return 1
-	return 0
-
-def ft_can_join_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_final) or
-	    (ch in ft_bidi_joiners_isolated) or
-	    (ch in ft_bidi_joiners_initial_medial) or
-	    (ch in ft_bidi_joiners_final_isolated)):
-    		return 1
-	return 0
-
-def ft_can_join_right(ch):
-	if (ft_can_join_left(ch) or 
-	    (ch in ft_right_joiners_final) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_right_joiners_final_isolated)):
-		return 1
-	return 0
-
-def ft_joining_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or 
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_initial_medial)):
-		return 1
-	return 0
-
-
-def ft_joining_right(ch):
-	if ((ch in ft_right_joiners_final) or
-	    (ch in ft_bidi_joiners_medial) or 
-	    (ch in ft_bidi_joiners_final)):
-		return 1
-	return 0
-
-def ft_not_right_joined(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_bidi_joiners_isolated)):
-		return 1
-	return 0
-
-def ft_adjust_shaping(text, i):
-	current = text[i]
-	u = u''
-	try:
-		u = table_FT_UN[current][0]
-	except KeyError:
-		return u''
-
-	#if you don't want shaping remove the following comment
-	#return u
-
-	if ((current in ft_vowels) or (ft_is_numeric(current))):
-		return u
-
-	#find next non-vowel character on the left
-	text_len = len(text)
-	next_index = i+1
-	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
-		next_index += 1
-
-	if (next_index == text_len):
-		next = ''
-	else:
-		next = text[next_index]
-
-	# if current letter is joining from left but next letter is or can not joining
-	if (ft_joining_left(current)):
-		if (not ft_can_join_right(next)):
-			u += u'\u200D' #ZWJ
-		elif (ft_not_right_joined(next)):
-			u += u'\u200D\u200C' #ZWJ+ZWNJ
-	# if current letter can join but next letter is joining from right
-	elif (ft_can_join_left(current)):
-		if (ft_joining_right(next)):
-			u += u'\u200C\u200D' #ZWNJ+ZWJ
-		elif (ft_can_join_right(next)):
-			u += u'\u200C' #ZWNJ
-	return u
-
-def ft_adjust_number(text):
-	result = u''
-	i = len(text)-1
-	while (i >= 0):
-		result += ft_adjust_shaping(text, i)
-		i -= 1
-	return result
-
-
-def map_ft_unicode(text):
-	mapped_text = u''
-
-	i = 0
-	while (i < len(text)):
-		if (ft_is_numeric(text[i])):
-			next_index = i
-			while ((next_index+1 < len(text)) and
-			       (ft_is_numeric(text[next_index+1]))):
-				next_index += 1
-			mapped_text += ft_adjust_number(text[i:next_index+1])
-			i = next_index+1
-			continue
-
-		mapped_text += ft_adjust_shaping(text, i)
-		i += 1
-	return mapped_text
-
-# Finds next token all of the same language
-def ft_next_part(line, i, line_len):
-	j = i
-	language_flag = (line[j]<chr(0x80))
-	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
-		j += 1
-	return j
-
-###############################################
-# from here all functions are used to translate
-# farsitex commands to xepersian commands
-###############################################
-
-def read_size(input,index,last_index):
-	dim_index = -1 
-	inch_index = input.find(u'in', index)
-	if (inch_index != -1):
-		dim_index = inch_index
-	mm_index = input.find(u'mm', index)
-	if (mm_index != -1):
-		if (dim_index == -1 or mm_index < index):
-			dim_index = mm_index
-	cm_index = input.find(u'cm', index)
-	if (cm_index != -1):
-		if (dim_index == -1 or cm_index < dim_index):
-			dim_index = cm_index
-	pt_index = input.find(u'pt', index)
-	if (pt_index != -1):
-		if (dim_index == -1 or pt_index < dim_index):
-			dim_index = pt_index
-	next_cmd = input.find(u'\\', index)
-	if (next_cmd == -1 and dim_index == -1):
-		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
-		return -1
-	elif (next_cmd == -1 or (dim_index != -1 and next_cmd > dim_index)):
-		epsfxsize = input[index:dim_index+2]
-		return dim_index+2
-	elif (next_cmd != -1):
-		end_cmd = next_cmd+1
-		while (end_cmd < last_index and input[end_cmd].isalpha()):
-			end_cmd += 1
-		return end_cmd
-	else:
-		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
-		return -1
-
-
-latex_options=[u'a4paper', u'a5paper', u'b5paper', 
-			   u'letterpaper', u'legalpaper', u'executivepaper', 
-			   u'landscape', u'10pt', u'11pt', u'12pt', 
-			   u'oneside', u'twoside', u'draft', 
-			   u'final', u'titlepage', u'notitlepage',
-			   u'onecolumn', u'twocolumn',
-			   u'leqno', u'fleqn']
-
-table_eq_packages = {
-u'poem'     : u'persianpoem',
-u'fmakeidx' : u'makeidx',
-u'ffancyhe' : u'fancyhdr',
-u'fmultico' : u'multicol'
-}
-
-farsitex_ignore_options = [u'persian', u'farsi', u'epsf', u'fgraphix']
-
-xepersian_preamble = u'\n\\usepackage{xepersian}\n\\usepackage{url}\n\\usepackage{fancyvrb}\n\\usepackage{setspace}\\onehalfspace\n\\settextfont[Scale=1]{XB Zar}\n\\setromantextfont[Scale=1]{Times New Roman}\n\\setdigitfont{XB Zar}\n\\let\\iranic\\it\n\\let\\siah\\bf\n\\let\\khabide\\sl\n\\def\\siahir{\\siah\\iranic}\n\\def\\siahkh{\\siah\\khabide}\n\\let\\farsi\\Persian\n\\let\\english\\Roman\n\\let\\farmbox\\mbox\n\\newcommand{\\ftxepmatrix}[1]{\\begin{pmatrix}#1\\end{pmatrix}}\n\\def\\FarsiTeX{\\lr{FarsiTeX}}\n'
-
-
-
-def find_eq_cmd(keyword):
-	try:
-		eq_cmd = table_eq_packages[keyword]
-	except KeyError:
-		eq_cmd = u''
-	return eq_cmd
-
-# \sayedar \tookhali
-# \verb|| -> \item[\verb||] or \section{\verb||}
-# \url{} -> does not show numbers
-# \kasre{} \alef{} ...
-# persian number as parameter: \multicolumn{8}, \addtocounter{page}{1}
-# pagenumbers are in english
-def translate_cmds(output_line):
-	global last_epsfxsize
-	global last_epsfxsize_line
-	global last_epsfysize
-	global last_epsfysize_line
-	global state
-
-	result = u''
-	line_len = len(output_line)
-	index = 0
-	if (state == 1): #\begin{verbatim}
-		end_verbatim = output_line.find('\\end{verbatim}')
-		if (end_verbatim == -1):
-			return output_line
-		result += output_line[0:end_verbatim+14]
-		index = end_verbatim+14
-		state = 0
-	elif (state == 2): #\begin{verbatim*}
-		end_verbatim = output_line.find('\\end{verbatim*}')
-		if (end_verbatim == -1):
-			return output_line
-		result += output_line[0:end_verbatim+15]
-		index = end_verbatim+15
-		state = 0
-	elif (output_line[0:14] == "\\documentstyle"):
-		result += u'\\documentclass'
-		#process options
-		last_index = output_line.find(u']')
-		index = 15
-		first_option = 1
-		preamble = xepersian_preamble
-		document_class = u''
-		while (index < last_index):
-			next_comma = output_line.find(u',',index,last_index)
-			if (next_comma == -1):
-				next_comma = last_index
-			option = output_line[index:next_comma]
-			index = next_comma+1
-			eq_cmd = find_eq_cmd(option)
-			if (eq_cmd != u''):
-				preamble += u'\\usepackage{' + eq_cmd + u'}\n'
-				continue
-			elif (option in farsitex_ignore_options):
-				continue
-			elif (option == u'sharifth'):
-				document_class = u'xepersian-thesis'
-				continue
-			elif (not option in latex_options):
-				preamble += u'\\usepackage{' + option + u'}\n'
-				continue
-	
-			if (first_option):
-				result += u'['
-			else:
-				result += u','
-			result += option
-			first_option = 0
-		#end while
-		if (not first_option):
-			result += u']'
-		index = output_line.find(u'}',last_index)
-		if (document_class == u''):
-			result += output_line[last_index+1:index+1]
-		else:
-			result += u'{' + document_class + u'}'
-		# I assume that nothing important is after
-		# \documentstyle[]{}, otherwise it may conflict
-		# with our preamble
-		if (index != -1):
-			result += output_line[index+1:]
-		result += preamble
-		return result
-	#end elif "documentstyle"
-
-	while (index < line_len):
-		next_index = output_line.find(u'\\', index)
-		comment_index = output_line.find(u'%', index)
-		if (next_index == -1):
-			result += output_line[index:]
-			break
-		elif (state == 1):
-			if (output_line[next_index:next_index+14] == u'\\end{verbatim}'):
-				result += output_line[index:next_index+14]
-				index = next_index+14
-				state = 0
-			else:
-				result += output_line[index:next_index+1]
-				index = next_index+1
-		elif (state == 2):
-			if (output_line[next_index:next_index+15] == u'\\end{verbatim*}'):
-				result += output_line[index:next_index+15]
-				index = next_index+15
-				state = 0
-			else:
-				result += output_line[index:next_index+1]
-				index = next_index+1
-		elif (comment_index != -1 and comment_index < next_index):
-			result += output_line[index:]
-			break
-		elif (output_line[next_index:next_index+14] == u"\\input{amssym}"):
-			result += u'\\usepackage{amssymb}'
-			index = next_index+14
-		elif (output_line[next_index:next_index+12] == u"\\input{epsf}"):
-			index = next_index+12
-		elif (output_line[next_index:next_index+15] == u"\\includeepspdf{"):
-			result += u'\\includegraphics{'
-			index = next_index+15
-		elif (output_line[next_index:next_index+16] == u"\\begin{verbatim}"):
-			result += output_line[index:next_index+16]
-			index = next_index+16
-			state = 1
-		elif (output_line[next_index:next_index+17] == u"\\begin{verbatim*}"):
-			result += output_line[index:next_index+17]
-			index = next_index+17
-			state = 2
-		elif (output_line[next_index:next_index+26] == u'\\setlength{\\headrulewidth}'):
-			end_cmd = output_line.find('}', next_index+26)
-			result += u'\\renewcommand{\\headrulewidth}' + output_line[next_index+26:end_cmd+1]
-			index = end_cmd+1
-		elif (output_line[next_index:next_index+26] == u'\\setlength{\\footrulewidth}'):
-			end_cmd = output_line.find('}', next_index+26)
-			result += u'\\renewcommand{\\footrulewidth}' + output_line[next_index+26:end_cmd+1]
-			index = end_cmd+1
-		elif (output_line[next_index:next_index+10] == u"\\epsffile{"):
-			result += output_line[index:next_index]
-			result += u'\\includegraphics'
-			size_options = u''
-			if (line_number - last_epsfxsize_line <= 3):
-				size_options = u'width=' + last_epsfxsize
-			if (line_number - last_epsfysize_line <= 3):
-				if (size_options != u''):
-					size_options += u','
-				size_options += u'height=' + last_epsfysize
-			if (size_options != u''):
-				result += u'[' + size_options + u']'
-			end_prn = output_line.find(u'.eps}', next_index+9)
-
-			if (end_prn != -1):
-				result += output_line[next_index+9:end_prn] + u'}'
-				index = end_prn+5
-			else:
-				end_prn = output_line.find(u'.ps}', next_index+9)
-				if (end_prn != -1):
-					result += output_line[next_index+9:end_prn] + u'}'
-					index = end_prn+4
-				else:
-					end_prn = output_line.find(u'}', next_index+9)
-					result += output_line[next_index+9:end_prn+1]
-					index = end_prn+1
-		# I assume all the parameter of \epsfxsize comes in one line
-		elif (output_line[next_index:next_index+11] == u"\\epsfxsize="):
-			end_size = read_size(output_line, next_index+11, line_len)
-			if (end_size != -1):
-				last_epsfxsize = output_line[next_index+11:end_size]
-				index = end_size
-			else:
-				index = next_index+11
-			last_epsfxsize_line = line_number
-		# I assume all the parameter of \epsfysize comes in one line
-		elif (output_line[next_index:next_index+11] == u"\\epsfysize="):
-			end_size = read_size(output_line, next_index+11, line_len)
-			if (end_size != -1):
-				last_epsfysize = output_line[next_index+11:end_size]
-				index = end_size
-			else:
-				index = next_index+11
-			last_epsfysize_line = line_number
-		elif (output_line[next_index:next_index+6] == u"\\verb*"):
-			end_verb = output_line.find(output_line[next_index+6], next_index+7)
-			result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+5] == u"\\verb"):
-			end_verb = output_line.find(output_line[next_index+5], next_index+6)
-			result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+9] == u"\\pmatrix{"):
-			result += u'\\ftxepmatrix{'
-			index = next_index+9
-		elif (output_line[next_index:next_index+16] == u"\\begin{document}"):
-			result += u'\\begin{document}\n\\VerbatimFootnotes'
-			index = next_index+16
-		else:
-			result += output_line[index:next_index+2]
-			index = next_index+2
-	#end while
-	return result
-
-def convert_file(f, of, convert_cmds):
-	global state
-	global line_number
-	global last_epsfysize_line
-	global last_epsfxsize_line
-	global last_epsfxsize
-	global last_epsfysize
-
-	state = 0
-	line_number = 0
-	last_epsfysize_line = 0
-	last_epsfxsize_line = 0
-	last_epsfxsize = u''
-	last_epsfysize = u''
-
-	for line in f:
-		line_number += 1
-		print line_number
-		output_line = u''
-		line_len = len(line)
-		
-		# remove new-line characters from end of line
-		if (line_len>1 and line[line_len-1] == '\n'):
-			line_len-=1
-		if (line_len>1 and line[line_len-1] == '\r'):
-			line_len-=1
-		
-		# check line-direction character
-		line_direction_rtl = (line[0] == '<')
-		if (line[0] != '>') and (line[0] != '<'):
-			print "FORMAT ERROR AT LINE: " + str(line_number)
-			exit(0)
-	
-		i = 1
-	
-		while (i<line_len):
-			next_part_index = ft_next_part(line, i, line_len)
-			next_part = line[i:next_part_index]
-			next_part_latin = (line[i]<chr(0x80))
-			
-			# see if we should put \lr{...} for the current english expression
-			if line_direction_rtl and next_part_latin:
-				is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
-				is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
-				is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
-				is_verb_parameter = ( (line[i-6:i] == F_SLASH+"verb") and not isalpha(line[i]))
-				is_verb = (next_part_latin and (line[i:i+5]=='\\verb' or line[i:i+6]==' \\verb'))
-			
-				cmd_index = 0
-				while cmd_index < len(commands):
-					len_cmd = len(commands[cmd_index])+2
-					if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
-						break
-					cmd_index += 1
-				is_commands_group = cmd_index < len(commands)
-				is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
-	
-			if next_part_latin:
-				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
-					output_line += u'\\lr{'
-				if ( line_direction_rtl and is_verb):
-					output_line += u'\\beginL{}'
-				
-				output_line += next_part.encode( 'utf-8' )
-				
-				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
-					output_line += u'}'
-				if ( line_direction_rtl and is_verb):
-					output_line += u'\\endL{}'
-			else:
-				if ( not line_direction_rtl):
-					output_line += u'\\rl{'
-					
-				output_line += map_ft_unicode(next_part)
-				
-				if (not line_direction_rtl):
-					output_line += u'}'
-					
-			i = next_part_index
-		# end of while			
-		
-		# convert some of the FarsiTeX commands to XePersian commands
-		# only if it is requested
-		if (convert_cmds):
-			result = translate_cmds(output_line) 
-		else:
-			result = output_line
-		output_line = result + u'\n'
-		# write the processed line
-		of.write(output_line)
-		# end of line processing
-	# end of file processing
-
-###################################
-# Begin of main body of the program
-###################################
-
-# global variables
-line_number = 0
-last_epsfxsize = u''
-last_epsfxsize_line = 0
-last_epsfysize = u''
-last_epsfysize_line = 0
-state = 0
-
-if len(sys.argv) <= 2:
-	print 'usage: python undk in_filename out_filename'
-	exit(0)
-
-filename = sys.argv[1]
-outfile = sys.argv[2]
-
-try:
-	f = open(filename, 'r')
-except IOError:
-	print "Can not open the input file: " + filename
-	exit(0)
-
-try:
-	of = codecs.open(outfile, encoding='utf-8', mode='w')
-except IOError:
-	print "Can not open the output file: " + outfile
-	exit(0)
-
-convert_file(f, of, 1)
-	
-of.close()
-f.close()	

Added: trunk/ftxe-0.4.py
===================================================================
--- trunk/ftxe-0.4.py	2009-06-14 23:30:51 UTC (rev 69)
+++ trunk/ftxe-0.4.py	2009-06-16 00:28:13 UTC (rev 70)
@@ -0,0 +1,790 @@
+?#########################################
+#       General Public License          #
+#       Author:  Mostafa Vahedi         #
+#       Date:    15 June 2009           #
+#       Version  0.4                    #
+#########################################
+
+import codecs
+
+import sys
+
+
+ft_numerical = [
+chr(0xB9),	# 	Arabic Thoushads Seperator
+chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
+]
+
+
+ft_vowels = [
+chr(0xB0),	#	ARABIC FATHA
+chr(0xB1),	#	ARABIC KASRA
+chr(0xB2),	#	ARABIC DAMMA
+chr(0xB3),	#	ARABIC FATHATAN
+chr(0xB4),	#	ARABIC SHADDA
+chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB),	#	ARABIC HAMZA ABOVE
+chr(0xC4) 	#	ARABIC SUKUN
+]
+
+ft_non_joiners = [
+chr(0x8F)	#	ARABIC LETTER HAMZA
+]
+
+ft_bidi_joiners_initial = [
+chr(0xE4),	#	ARABIC LETTER AIN, initial form
+chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
+chr(0xFB) 	#	ARABIC LETTER HEH, initial form
+]
+
+ft_bidi_joiners_medial = [
+chr(0xE3),	#	ARABIC LETTER AIN, medial form
+chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
+chr(0xFA) 	#	ARABIC LETTER HEH, medial form
+]
+
+ft_bidi_joiners_final = [
+chr(0xE2),	#	ARABIC LETTER AIN, final form
+chr(0xE6),	#	ARABIC LETTER GHAIN, final form
+chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
+]
+
+ft_bidi_joiners_isolated = [
+chr(0xE1),	#	ARABIC LETTER AIN, isolated form
+chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
+chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
+]
+
+ft_bidi_joiners_initial_medial = [
+chr(0x8B),	#	ARABIC TATWEEL
+chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
+chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
+chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
+chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
+chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
+chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
+chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
+]
+
+ft_bidi_joiners_final_isolated = [
+chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
+chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
+chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
+chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
+chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
+chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
+chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
+chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
+]
+
+ft_right_joiners_final = [
+chr(0x91)	#	ARABIC LETTER ALEF, final form
+]
+
+ft_right_joiners_isolated = [
+chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x90)	#	ARABIC LETTER ALEF, isolated form
+]
+
+ft_right_joiners_final_isolated = [
+chr(0xA2),	#	ARABIC LETTER DAL
+chr(0xA3),	#	ARABIC LETTER THAL
+chr(0xA4),	#	ARABIC LETTER REH
+chr(0xA5),	#	ARABIC LETTER ZAIN
+chr(0xA6),	#	ARABIC LETTER JEH
+chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
+chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF8)	#	ARABIC LETTER WAW
+]
+
+
+table_FT_UN = {
+chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
+chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
+chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
+chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
+chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
+chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
+chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
+chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
+chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
+chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
+chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
+chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
+chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
+chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
+chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
+chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
+chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
+chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
+chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
+chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
+chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
+chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
+chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
+chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
+chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
+chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
+chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
+chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
+chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
+chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
+chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
+chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
+chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
+chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
+chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
+chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
+chr(0xB5) : [u'\u0023'],	# * #
+chr(0xB6) : [u'\u0024'],	# * $
+chr(0xB7) : [u'\u0025'],	# * %
+chr(0xB8) : [u'\u0026'],	# * &
+chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
+chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
+chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
+chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
+chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
+chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
+chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
+chr(0xC5) : [u'\u002D'],	# * -
+chr(0xC6) : [u'\u002E'],	# * FULL STOP
+chr(0xC7) : [u'\u002F'],	# * /
+chr(0xC8) : [u'\u002A'],	# * *
+chr(0xC9) : [u'\u007E'],	# * ~
+chr(0xCA) : [u'\u003A'],	# * COLON
+chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
+chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
+chr(0xCD) : [u'\u002B'],	# * +
+chr(0xCE) : [u'\u003D'],	# * =
+chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
+# chr(0xD0) : [u'\u0040'],	# * @
+chr(0xD0) : [u''],	        # * @
+chr(0xD1) : [u'\u005D'],	# * [
+chr(0xD2) : [u'\u005C'],	# * \
+chr(0xD3) : [u'\u005B'],	# * ]
+chr(0xD4) : [u'\u005E'],	# * ^
+chr(0xD5) : [u'\u005F'],	# * _
+chr(0xD6) : [u'\u0060'],	# * `
+chr(0xD7) : [u'\u007D'],	# * {
+chr(0xD8) : [u'\u007C'],	# * |
+chr(0xDA) : [u'\u0020'],	# * SPACE
+chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
+chr(0xDE) : [u'\u007B'],	# * }
+chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
+chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
+chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
+chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
+chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
+chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
+chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
+chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
+chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
+chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
+chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
+chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
+chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
+chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
+chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
+chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
+chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
+chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
+}
+
+F_SLASH = chr(0xD2)
+F_PRNT_OPEN = chr(0xDE)
+F_AT_SIGN = chr(0xD0)
+
+# latex and farsitex commands whose first parameter does not need \lr{...}
+commands = [ "begin", 
+"end",
+"input", "include", "includeonly",
+"hspace", "vspace", "hspace*", "vspace*",
+"label", "ref", "cite", "bibitem",
+"bibliographystyle",
+"parbox",
+"newenvironment", "newtheorem",
+"persianmathdigitsfamily",
+"fontfamily", "fontseries", "fontshape",
+"rmdefault", "sfdefault", "ttdefault",
+"bfdefault", "itdefault", "sldefault", "scdefault",
+"pagenumbering", "pagestyle", "thispagestyle",
+"setcounter", "stepcounter", "setlength", "addtolength"
+]
+
+
+def ft_is_numeric(ch):
+	if ((ch in ft_numerical) or 
+	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
+		return 1
+	return 0
+
+def ft_can_join_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_final) or
+	    (ch in ft_bidi_joiners_isolated) or
+	    (ch in ft_bidi_joiners_initial_medial) or
+	    (ch in ft_bidi_joiners_final_isolated)):
+    		return 1
+	return 0
+
+def ft_can_join_right(ch):
+	if (ft_can_join_left(ch) or 
+	    (ch in ft_right_joiners_final) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_right_joiners_final_isolated)):
+		return 1
+	return 0
+
+def ft_joining_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or 
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_initial_medial)):
+		return 1
+	return 0
+
+
+def ft_joining_right(ch):
+	if ((ch in ft_right_joiners_final) or
+	    (ch in ft_bidi_joiners_medial) or 
+	    (ch in ft_bidi_joiners_final)):
+		return 1
+	return 0
+
+def ft_not_right_joined(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_bidi_joiners_isolated)):
+		return 1
+	return 0
+
+def ft_adjust_shaping(text, i):
+	current = text[i]
+	u = u''
+	try:
+		u = table_FT_UN[current][0]
+	except KeyError:
+		return u''
+
+	#if you don't want shaping remove the following comment
+	#return u
+
+	if ((current in ft_vowels) or (ft_is_numeric(current))):
+		return u
+
+	#find next non-vowel character on the left
+	text_len = len(text)
+	next_index = i+1
+	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
+		next_index += 1
+
+	if (next_index == text_len):
+		next = ''
+	else:
+		next = text[next_index]
+
+	# if current letter is joining from left but next letter is or can not joining
+	if (ft_joining_left(current)):
+		if (not ft_can_join_right(next)):
+			u += u'\u200D' #ZWJ
+		elif (ft_not_right_joined(next)):
+			u += u'\u200D\u200C' #ZWJ+ZWNJ
+	# if current letter can join but next letter is joining from right
+	elif (ft_can_join_left(current)):
+		if (ft_joining_right(next)):
+			u += u'\u200C\u200D' #ZWNJ+ZWJ
+		elif (ft_can_join_right(next)):
+			u += u'\u200C' #ZWNJ
+	return u
+
+def ft_adjust_number(text):
+	result = u''
+	i = len(text)-1
+	while (i >= 0):
+		result += ft_adjust_shaping(text, i)
+		i -= 1
+	return result
+
+
+def map_ft_unicode(text):
+	mapped_text = u''
+
+	i = 0
+	while (i < len(text)):
+		if (ft_is_numeric(text[i])):
+			next_index = i
+			while ((next_index+1 < len(text)) and
+			       (ft_is_numeric(text[next_index+1]))):
+				next_index += 1
+			mapped_text += ft_adjust_number(text[i:next_index+1])
+			i = next_index+1
+			continue
+
+		mapped_text += ft_adjust_shaping(text, i)
+		i += 1
+	return mapped_text
+
+# Finds next token all of the same language
+def ft_next_part(line, i, line_len):
+	j = i
+	language_flag = (line[j]<chr(0x80))
+	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
+		j += 1
+	return j
+
+###############################################
+# from here all functions are used to translate
+# farsitex commands to xepersian commands
+###############################################
+
+def read_size(input,index,last_index):
+	dim_index = -1 
+	inch_index = input.find(u'in', index)
+	if (inch_index != -1):
+		dim_index = inch_index
+	mm_index = input.find(u'mm', index)
+	if (mm_index != -1):
+		if (dim_index == -1 or mm_index < index):
+			dim_index = mm_index
+	cm_index = input.find(u'cm', index)
+	if (cm_index != -1):
+		if (dim_index == -1 or cm_index < dim_index):
+			dim_index = cm_index
+	pt_index = input.find(u'pt', index)
+	if (pt_index != -1):
+		if (dim_index == -1 or pt_index < dim_index):
+			dim_index = pt_index
+	next_cmd = input.find(u'\\', index)
+	if (next_cmd == -1 and dim_index == -1):
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+	elif (next_cmd == -1 or (dim_index != -1 and next_cmd > dim_index)):
+		epsfxsize = input[index:dim_index+2]
+		return dim_index+2
+	elif (next_cmd != -1):
+		end_cmd = next_cmd+1
+		while (end_cmd < last_index and input[end_cmd].isalpha()):
+			end_cmd += 1
+		return end_cmd
+	else:
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+
+
+latex_options=[u'a4paper', u'a5paper', u'b5paper', 
+			   u'letterpaper', u'legalpaper', u'executivepaper', 
+			   u'landscape', u'10pt', u'11pt', u'12pt', 
+			   u'oneside', u'twoside', u'draft', 
+			   u'final', u'titlepage', u'notitlepage',
+			   u'onecolumn', u'twocolumn',
+			   u'leqno', u'fleqn']
+
+table_eq_packages = {
+u'poem'     : u'persianpoem',
+u'fmakeidx' : u'makeidx',
+u'ffancyhe' : u'fancyhdr',
+u'fmultico' : u'multicol'
+}
+
+farsitex_ignore_options = [u'persian', u'farsi', u'epsf', u'fgraphix']
+
+xepersian_packages = u'\n\\usepackage{url}\n\\usepackage{fancyvrb}\n\\usepackage{setspace}\\onehalfspace\n\\usepackage{graphicx}\n'
+xepersian_preamble = u'\\settextfont[Scale=1]{XB Zar}\n\\setlatintextfont[Scale=1]{Times New Roman}\n\\setdigitfont{XB Zar}\n\\let\\iranic\\it\n\\let\\siah\\bf\n\\let\\khabide\\sl\n\\def\\siahir{\\siah\\iranic}\n\\def\\siahkh{\\siah\\khabide}\n\\let\\farsi\\Persian\n\\let\\english\\Latin\n\\let\\farmbox\\mbox\n\\newcommand{\\ftxepmatrix}[1]{\\begin{pmatrix}#1\\end{pmatrix}}\n\\def\\FarsiTeX{\\lr{FarsiTeX}}\n\\def\\????????{\\rl{?????????}}\n'
+
+
+
+def find_eq_cmd(keyword):
+	try:
+		eq_cmd = table_eq_packages[keyword]
+	except KeyError:
+		eq_cmd = u''
+	return eq_cmd
+
+# \sayedar \tookhali
+# \verb|| -> \item[\verb||] or \section{\verb||}
+# \url{} -> does not show numbers
+# \kasre{} \alef{} ...
+# persian number as parameter: \multicolumn{8}, \addtocounter{page}{1}
+# pagenumbers are in english
+def translate_cmds(output_line):
+	global last_epsfxsize
+	global last_epsfxsize_line
+	global last_epsfysize
+	global last_epsfysize_line
+	global state
+
+	result = u''
+	line_len = len(output_line)
+	index = 0
+	if (state == 1): #\begin{verbatim}
+		end_verbatim = output_line.find('\\end{verbatim}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+14]
+		index = end_verbatim+14
+		state = 0
+	elif (state == 2): #\begin{verbatim*}
+		end_verbatim = output_line.find('\\end{verbatim*}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+15]
+		index = end_verbatim+15
+		state = 0
+	elif (output_line[0:14] == "\\documentstyle"):
+		result += u'\\documentclass'
+		#process options
+		last_index = output_line.find(u']')
+		index = 15
+		first_option = 1
+		preamble = xepersian_preamble
+		packages = xepersian_packages
+		document_class = u''
+		while (index < last_index):
+			next_comma = output_line.find(u',',index,last_index)
+			if (next_comma == -1):
+				next_comma = last_index
+			option = output_line[index:next_comma]
+			index = next_comma+1
+			eq_cmd = find_eq_cmd(option)
+			if (eq_cmd != u''):
+				packages += u'\\usepackage{' + eq_cmd + u'}\n'
+				continue
+			elif (option in farsitex_ignore_options):
+				continue
+			elif (option == u'sharifth'):
+				document_class = u'xepersian-thesis'
+				continue
+			elif (not option in latex_options):
+				packages += u'\\usepackage{' + option + u'}\n'
+				continue
+	
+			if (first_option):
+				result += u'['
+			else:
+				result += u','
+			result += option
+			first_option = 0
+		#end while
+		if (not first_option):
+			result += u']'
+		index = output_line.find(u'}',last_index)
+		if (document_class == u''):
+			result += output_line[last_index+1:index+1]
+		else:
+			result += u'{' + document_class + u'}'
+		# I assume that nothing important is after
+		# \documentstyle[]{}, otherwise it may conflict
+		# with our preamble
+		if (index != -1):
+			result += output_line[index+1:]
+		result += packages + u'\\usepackage{xepersian}\n'
+		result += preamble
+		return result
+	#end elif "documentstyle"
+
+	while (index < line_len):
+		next_index = output_line.find(u'\\', index)
+		comment_index = output_line.find(u'%', index)
+		if (next_index == -1):
+			result += output_line[index:]
+			break
+		elif (state == 1):
+			if (output_line[next_index:next_index+14] == u'\\end{verbatim}'):
+				result += output_line[index:next_index+14]
+				index = next_index+14
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (state == 2):
+			if (output_line[next_index:next_index+15] == u'\\end{verbatim*}'):
+				result += output_line[index:next_index+15]
+				index = next_index+15
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (comment_index != -1 and comment_index < next_index):
+			result += output_line[index:]
+			break
+		elif (output_line[next_index:next_index+14] == u"\\input{amssym}"):
+			result += u'\\usepackage{amssymb}'
+			index = next_index+14
+		elif (output_line[next_index:next_index+12] == u"\\input{epsf}"):
+			index = next_index+12
+		elif (output_line[next_index:next_index+15] == u"\\includeepspdf{"):
+			result += u'\\includegraphics{'
+			index = next_index+15
+		elif (output_line[next_index:next_index+16] == u"\\begin{verbatim}"):
+			result += output_line[index:next_index+16]
+			index = next_index+16
+			state = 1
+		elif (output_line[next_index:next_index+17] == u"\\begin{verbatim*}"):
+			result += output_line[index:next_index+17]
+			index = next_index+17
+			state = 2
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\headrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\headrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\footrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\footrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+10] == u"\\epsffile{"):
+			result += output_line[index:next_index]
+			result += u'\\includegraphics'
+			size_options = u''
+			if (line_number - last_epsfxsize_line <= 3):
+				size_options = u'width=' + last_epsfxsize
+			if (line_number - last_epsfysize_line <= 3):
+				if (size_options != u''):
+					size_options += u','
+				size_options += u'height=' + last_epsfysize
+			if (size_options != u''):
+				result += u'[' + size_options + u']'
+			end_prn = output_line.find(u'.eps}', next_index+9)
+
+			if (end_prn != -1):
+				result += output_line[next_index+9:end_prn] + u'}'
+				index = end_prn+5
+			else:
+				end_prn = output_line.find(u'.ps}', next_index+9)
+				if (end_prn != -1):
+					result += output_line[next_index+9:end_prn] + u'}'
+					index = end_prn+4
+				else:
+					end_prn = output_line.find(u'}', next_index+9)
+					result += output_line[next_index+9:end_prn+1]
+					index = end_prn+1
+		# I assume all the parameter of \epsfxsize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfxsize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfxsize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfxsize_line = line_number
+		# I assume all the parameter of \epsfysize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfysize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfysize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfysize_line = line_number
+		elif (output_line[next_index:next_index+6] == u"\\verb*"):
+			end_verb = output_line.find(output_line[next_index+6], next_index+7)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+5] == u"\\verb"):
+			end_verb = output_line.find(output_line[next_index+5], next_index+6)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+9] == u"\\pmatrix{"):
+			result += u'\\ftxepmatrix{'
+			index = next_index+9
+		elif (output_line[next_index:next_index+16] == u"\\begin{document}"):
+			result += u'\\begin{document}\n\\VerbatimFootnotes'
+			index = next_index+16
+		else:
+			result += output_line[index:next_index+2]
+			index = next_index+2
+	#end while
+	return result
+
+def convert_file(f, of, convert_cmds):
+	global state
+	global line_number
+	global last_epsfysize_line
+	global last_epsfxsize_line
+	global last_epsfxsize
+	global last_epsfysize
+
+	state = 0
+	line_number = 0
+	last_epsfysize_line = 0
+	last_epsfxsize_line = 0
+	last_epsfxsize = u''
+	last_epsfysize = u''
+
+	for line in f:
+		line_number += 1
+		print line_number
+		output_line = u''
+		line_len = len(line)
+		
+		# remove new-line characters from end of line
+		if (line_len>1 and line[line_len-1] == '\n'):
+			line_len-=1
+		if (line_len>1 and line[line_len-1] == '\r'):
+			line_len-=1
+		
+		# check line-direction character
+		line_direction_rtl = (line[0] == '<')
+		if (line[0] != '>') and (line[0] != '<'):
+			print "FORMAT ERROR AT LINE: " + str(line_number)
+			exit(0)
+	
+		i = 1
+	
+		while (i<line_len):
+			next_part_index = ft_next_part(line, i, line_len)
+			next_part = line[i:next_part_index]
+			next_part_latin = (line[i]<chr(0x80))
+			
+			# see if we should put \lr{...} for the current english expression
+			if line_direction_rtl and next_part_latin:
+				is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
+				is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
+				is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
+				is_verb_parameter = ( (line[i-6:i] == F_SLASH+"verb") and not isalpha(line[i]))
+				is_verb = (next_part_latin and (line[i:i+5]=='\\verb' or line[i:i+6]==' \\verb'))
+			
+				cmd_index = 0
+				while cmd_index < len(commands):
+					len_cmd = len(commands[cmd_index])+2
+					if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
+						break
+					cmd_index += 1
+				is_commands_group = cmd_index < len(commands)
+				is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
+	
+			if next_part_latin:
+				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
+					output_line += u'\\lr{'
+				if ( line_direction_rtl and is_verb):
+					output_line += u'\\LR{'
+				
+				output_line += next_part.encode( 'utf-8' )
+				
+				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
+					output_line += u'}'
+				if ( line_direction_rtl and is_verb):
+					output_line += u'}'
+			else:
+				if ( not line_direction_rtl):
+					output_line += u'\\rl{'
+					
+				output_line += map_ft_unicode(next_part)
+				
+				if (not line_direction_rtl):
+					output_line += u'}'
+					
+			i = next_part_index
+		# end of while			
+		
+		# convert some of the FarsiTeX commands to XePersian commands
+		# only if it is requested
+		if (convert_cmds):
+			result = translate_cmds(output_line) 
+		else:
+			result = output_line
+		output_line = result + u'\n'
+		# write the processed line
+		of.write(output_line)
+		# end of line processing
+	# end of file processing
+
+###################################
+# Begin of main body of the program
+###################################
+
+# global variables
+line_number = 0
+last_epsfxsize = u''
+last_epsfxsize_line = 0
+last_epsfysize = u''
+last_epsfysize_line = 0
+state = 0
+
+if len(sys.argv) <= 2:
+	print 'usage: python undk in_filename out_filename'
+	exit(0)
+
+filename = sys.argv[1]
+outfile = sys.argv[2]
+
+try:
+	f = open(filename, 'r')
+except IOError:
+	print "Can not open the input file: " + filename
+	exit(0)
+
+try:
+	of = codecs.open(outfile, encoding='utf-8', mode='w')
+except IOError:
+	print "Can not open the output file: " + outfile
+	exit(0)
+
+convert_file(f, of, 1)
+	
+of.close()
+f.close()	



From vafa at mail.berlios.de  Tue Jun 16 12:58:55 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Tue, 16 Jun 2009 12:58:55 +0200
Subject: [Xepersian-development] r71 - trunk
Message-ID: <200906161058.n5GAwtdU024512@sheep.berlios.de>

Author: vafa
Date: 2009-06-16 12:58:24 +0200 (Tue, 16 Jun 2009)
New Revision: 71

Modified:
   trunk/xepersian.dtx
Log:
added \plq and \prq macros

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-16 00:28:13 UTC (rev 70)
+++ trunk/xepersian.dtx	2009-06-16 10:58:24 UTC (rev 71)
@@ -163,7 +163,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 68}
+\def\xepersianrevision{revision 71}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -212,6 +212,8 @@
 }
 \gdef\@latexbug{%
   \@latex at error{This may be a XePersian bug}{Please inform the Author of XePersian}}
+\def\prq{?}
+\def\plq{?}
 \newfontscript{Persian}{arab}
 \newfontlanguage{Persian}{ARA}
 \newcommand*\settextfont[2][]{%



From vafa at mail.berlios.de  Wed Jun 17 06:11:10 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Wed, 17 Jun 2009 06:11:10 +0200
Subject: [Xepersian-development] r72 - trunk
Message-ID: <200906170411.n5H4BAhd016391@sheep.berlios.de>

Author: vafa
Date: 2009-06-17 06:11:03 +0200 (Wed, 17 Jun 2009)
New Revision: 72

Added:
   trunk/ftxe-0.5.py
Removed:
   trunk/ftxe-0.4.py
Log:
new version of farsitex-xepersian converter is added per Mostafa

Deleted: trunk/ftxe-0.4.py
===================================================================
--- trunk/ftxe-0.4.py	2009-06-16 10:58:24 UTC (rev 71)
+++ trunk/ftxe-0.4.py	2009-06-17 04:11:03 UTC (rev 72)
@@ -1,790 +0,0 @@
-?#########################################
-#       General Public License          #
-#       Author:  Mostafa Vahedi         #
-#       Date:    15 June 2009           #
-#       Version  0.4                    #
-#########################################
-
-import codecs
-
-import sys
-
-
-ft_numerical = [
-chr(0xB9),	# 	Arabic Thoushads Seperator
-chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
-]
-
-
-ft_vowels = [
-chr(0xB0),	#	ARABIC FATHA
-chr(0xB1),	#	ARABIC KASRA
-chr(0xB2),	#	ARABIC DAMMA
-chr(0xB3),	#	ARABIC FATHATAN
-chr(0xB4),	#	ARABIC SHADDA
-chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB),	#	ARABIC HAMZA ABOVE
-chr(0xC4) 	#	ARABIC SUKUN
-]
-
-ft_non_joiners = [
-chr(0x8F)	#	ARABIC LETTER HAMZA
-]
-
-ft_bidi_joiners_initial = [
-chr(0xE4),	#	ARABIC LETTER AIN, initial form
-chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
-chr(0xFB) 	#	ARABIC LETTER HEH, initial form
-]
-
-ft_bidi_joiners_medial = [
-chr(0xE3),	#	ARABIC LETTER AIN, medial form
-chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
-chr(0xFA) 	#	ARABIC LETTER HEH, medial form
-]
-
-ft_bidi_joiners_final = [
-chr(0xE2),	#	ARABIC LETTER AIN, final form
-chr(0xE6),	#	ARABIC LETTER GHAIN, final form
-chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
-]
-
-ft_bidi_joiners_isolated = [
-chr(0xE1),	#	ARABIC LETTER AIN, isolated form
-chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
-chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
-]
-
-ft_bidi_joiners_initial_medial = [
-chr(0x8B),	#	ARABIC TATWEEL
-chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
-chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
-chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
-chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
-chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
-chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
-chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
-]
-
-ft_bidi_joiners_final_isolated = [
-chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
-chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
-chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
-chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
-chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
-chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
-chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
-chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
-]
-
-ft_right_joiners_final = [
-chr(0x91)	#	ARABIC LETTER ALEF, final form
-]
-
-ft_right_joiners_isolated = [
-chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x90)	#	ARABIC LETTER ALEF, isolated form
-]
-
-ft_right_joiners_final_isolated = [
-chr(0xA2),	#	ARABIC LETTER DAL
-chr(0xA3),	#	ARABIC LETTER THAL
-chr(0xA4),	#	ARABIC LETTER REH
-chr(0xA5),	#	ARABIC LETTER ZAIN
-chr(0xA6),	#	ARABIC LETTER JEH
-chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
-chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF8)	#	ARABIC LETTER WAW
-]
-
-
-table_FT_UN = {
-chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
-chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
-chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
-chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
-chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
-chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
-chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
-chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
-chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
-chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
-chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
-chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
-chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
-chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
-chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
-chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
-chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
-chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
-chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
-chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
-chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
-chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
-chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
-chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
-chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
-chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
-chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
-chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
-chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
-chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
-chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
-chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
-chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
-chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
-chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
-chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
-chr(0xB5) : [u'\u0023'],	# * #
-chr(0xB6) : [u'\u0024'],	# * $
-chr(0xB7) : [u'\u0025'],	# * %
-chr(0xB8) : [u'\u0026'],	# * &
-chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
-chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
-chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
-chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
-chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
-chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
-chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
-chr(0xC5) : [u'\u002D'],	# * -
-chr(0xC6) : [u'\u002E'],	# * FULL STOP
-chr(0xC7) : [u'\u002F'],	# * /
-chr(0xC8) : [u'\u002A'],	# * *
-chr(0xC9) : [u'\u007E'],	# * ~
-chr(0xCA) : [u'\u003A'],	# * COLON
-chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
-chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
-chr(0xCD) : [u'\u002B'],	# * +
-chr(0xCE) : [u'\u003D'],	# * =
-chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
-# chr(0xD0) : [u'\u0040'],	# * @
-chr(0xD0) : [u''],	        # * @
-chr(0xD1) : [u'\u005D'],	# * [
-chr(0xD2) : [u'\u005C'],	# * \
-chr(0xD3) : [u'\u005B'],	# * ]
-chr(0xD4) : [u'\u005E'],	# * ^
-chr(0xD5) : [u'\u005F'],	# * _
-chr(0xD6) : [u'\u0060'],	# * `
-chr(0xD7) : [u'\u007D'],	# * {
-chr(0xD8) : [u'\u007C'],	# * |
-chr(0xDA) : [u'\u0020'],	# * SPACE
-chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
-chr(0xDE) : [u'\u007B'],	# * }
-chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
-chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
-chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
-chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
-chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
-chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
-chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
-chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
-chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
-chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
-chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
-chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
-chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
-chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
-chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
-chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
-chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
-chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
-}
-
-F_SLASH = chr(0xD2)
-F_PRNT_OPEN = chr(0xDE)
-F_AT_SIGN = chr(0xD0)
-
-# latex and farsitex commands whose first parameter does not need \lr{...}
-commands = [ "begin", 
-"end",
-"input", "include", "includeonly",
-"hspace", "vspace", "hspace*", "vspace*",
-"label", "ref", "cite", "bibitem",
-"bibliographystyle",
-"parbox",
-"newenvironment", "newtheorem",
-"persianmathdigitsfamily",
-"fontfamily", "fontseries", "fontshape",
-"rmdefault", "sfdefault", "ttdefault",
-"bfdefault", "itdefault", "sldefault", "scdefault",
-"pagenumbering", "pagestyle", "thispagestyle",
-"setcounter", "stepcounter", "setlength", "addtolength"
-]
-
-
-def ft_is_numeric(ch):
-	if ((ch in ft_numerical) or 
-	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
-		return 1
-	return 0
-
-def ft_can_join_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_final) or
-	    (ch in ft_bidi_joiners_isolated) or
-	    (ch in ft_bidi_joiners_initial_medial) or
-	    (ch in ft_bidi_joiners_final_isolated)):
-    		return 1
-	return 0
-
-def ft_can_join_right(ch):
-	if (ft_can_join_left(ch) or 
-	    (ch in ft_right_joiners_final) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_right_joiners_final_isolated)):
-		return 1
-	return 0
-
-def ft_joining_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or 
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_initial_medial)):
-		return 1
-	return 0
-
-
-def ft_joining_right(ch):
-	if ((ch in ft_right_joiners_final) or
-	    (ch in ft_bidi_joiners_medial) or 
-	    (ch in ft_bidi_joiners_final)):
-		return 1
-	return 0
-
-def ft_not_right_joined(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_bidi_joiners_isolated)):
-		return 1
-	return 0
-
-def ft_adjust_shaping(text, i):
-	current = text[i]
-	u = u''
-	try:
-		u = table_FT_UN[current][0]
-	except KeyError:
-		return u''
-
-	#if you don't want shaping remove the following comment
-	#return u
-
-	if ((current in ft_vowels) or (ft_is_numeric(current))):
-		return u
-
-	#find next non-vowel character on the left
-	text_len = len(text)
-	next_index = i+1
-	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
-		next_index += 1
-
-	if (next_index == text_len):
-		next = ''
-	else:
-		next = text[next_index]
-
-	# if current letter is joining from left but next letter is or can not joining
-	if (ft_joining_left(current)):
-		if (not ft_can_join_right(next)):
-			u += u'\u200D' #ZWJ
-		elif (ft_not_right_joined(next)):
-			u += u'\u200D\u200C' #ZWJ+ZWNJ
-	# if current letter can join but next letter is joining from right
-	elif (ft_can_join_left(current)):
-		if (ft_joining_right(next)):
-			u += u'\u200C\u200D' #ZWNJ+ZWJ
-		elif (ft_can_join_right(next)):
-			u += u'\u200C' #ZWNJ
-	return u
-
-def ft_adjust_number(text):
-	result = u''
-	i = len(text)-1
-	while (i >= 0):
-		result += ft_adjust_shaping(text, i)
-		i -= 1
-	return result
-
-
-def map_ft_unicode(text):
-	mapped_text = u''
-
-	i = 0
-	while (i < len(text)):
-		if (ft_is_numeric(text[i])):
-			next_index = i
-			while ((next_index+1 < len(text)) and
-			       (ft_is_numeric(text[next_index+1]))):
-				next_index += 1
-			mapped_text += ft_adjust_number(text[i:next_index+1])
-			i = next_index+1
-			continue
-
-		mapped_text += ft_adjust_shaping(text, i)
-		i += 1
-	return mapped_text
-
-# Finds next token all of the same language
-def ft_next_part(line, i, line_len):
-	j = i
-	language_flag = (line[j]<chr(0x80))
-	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
-		j += 1
-	return j
-
-###############################################
-# from here all functions are used to translate
-# farsitex commands to xepersian commands
-###############################################
-
-def read_size(input,index,last_index):
-	dim_index = -1 
-	inch_index = input.find(u'in', index)
-	if (inch_index != -1):
-		dim_index = inch_index
-	mm_index = input.find(u'mm', index)
-	if (mm_index != -1):
-		if (dim_index == -1 or mm_index < index):
-			dim_index = mm_index
-	cm_index = input.find(u'cm', index)
-	if (cm_index != -1):
-		if (dim_index == -1 or cm_index < dim_index):
-			dim_index = cm_index
-	pt_index = input.find(u'pt', index)
-	if (pt_index != -1):
-		if (dim_index == -1 or pt_index < dim_index):
-			dim_index = pt_index
-	next_cmd = input.find(u'\\', index)
-	if (next_cmd == -1 and dim_index == -1):
-		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
-		return -1
-	elif (next_cmd == -1 or (dim_index != -1 and next_cmd > dim_index)):
-		epsfxsize = input[index:dim_index+2]
-		return dim_index+2
-	elif (next_cmd != -1):
-		end_cmd = next_cmd+1
-		while (end_cmd < last_index and input[end_cmd].isalpha()):
-			end_cmd += 1
-		return end_cmd
-	else:
-		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
-		return -1
-
-
-latex_options=[u'a4paper', u'a5paper', u'b5paper', 
-			   u'letterpaper', u'legalpaper', u'executivepaper', 
-			   u'landscape', u'10pt', u'11pt', u'12pt', 
-			   u'oneside', u'twoside', u'draft', 
-			   u'final', u'titlepage', u'notitlepage',
-			   u'onecolumn', u'twocolumn',
-			   u'leqno', u'fleqn']
-
-table_eq_packages = {
-u'poem'     : u'persianpoem',
-u'fmakeidx' : u'makeidx',
-u'ffancyhe' : u'fancyhdr',
-u'fmultico' : u'multicol'
-}
-
-farsitex_ignore_options = [u'persian', u'farsi', u'epsf', u'fgraphix']
-
-xepersian_packages = u'\n\\usepackage{url}\n\\usepackage{fancyvrb}\n\\usepackage{setspace}\\onehalfspace\n\\usepackage{graphicx}\n'
-xepersian_preamble = u'\\settextfont[Scale=1]{XB Zar}\n\\setlatintextfont[Scale=1]{Times New Roman}\n\\setdigitfont{XB Zar}\n\\let\\iranic\\it\n\\let\\siah\\bf\n\\let\\khabide\\sl\n\\def\\siahir{\\siah\\iranic}\n\\def\\siahkh{\\siah\\khabide}\n\\let\\farsi\\Persian\n\\let\\english\\Latin\n\\let\\farmbox\\mbox\n\\newcommand{\\ftxepmatrix}[1]{\\begin{pmatrix}#1\\end{pmatrix}}\n\\def\\FarsiTeX{\\lr{FarsiTeX}}\n\\def\\????????{\\rl{?????????}}\n'
-
-
-
-def find_eq_cmd(keyword):
-	try:
-		eq_cmd = table_eq_packages[keyword]
-	except KeyError:
-		eq_cmd = u''
-	return eq_cmd
-
-# \sayedar \tookhali
-# \verb|| -> \item[\verb||] or \section{\verb||}
-# \url{} -> does not show numbers
-# \kasre{} \alef{} ...
-# persian number as parameter: \multicolumn{8}, \addtocounter{page}{1}
-# pagenumbers are in english
-def translate_cmds(output_line):
-	global last_epsfxsize
-	global last_epsfxsize_line
-	global last_epsfysize
-	global last_epsfysize_line
-	global state
-
-	result = u''
-	line_len = len(output_line)
-	index = 0
-	if (state == 1): #\begin{verbatim}
-		end_verbatim = output_line.find('\\end{verbatim}')
-		if (end_verbatim == -1):
-			return output_line
-		result += output_line[0:end_verbatim+14]
-		index = end_verbatim+14
-		state = 0
-	elif (state == 2): #\begin{verbatim*}
-		end_verbatim = output_line.find('\\end{verbatim*}')
-		if (end_verbatim == -1):
-			return output_line
-		result += output_line[0:end_verbatim+15]
-		index = end_verbatim+15
-		state = 0
-	elif (output_line[0:14] == "\\documentstyle"):
-		result += u'\\documentclass'
-		#process options
-		last_index = output_line.find(u']')
-		index = 15
-		first_option = 1
-		preamble = xepersian_preamble
-		packages = xepersian_packages
-		document_class = u''
-		while (index < last_index):
-			next_comma = output_line.find(u',',index,last_index)
-			if (next_comma == -1):
-				next_comma = last_index
-			option = output_line[index:next_comma]
-			index = next_comma+1
-			eq_cmd = find_eq_cmd(option)
-			if (eq_cmd != u''):
-				packages += u'\\usepackage{' + eq_cmd + u'}\n'
-				continue
-			elif (option in farsitex_ignore_options):
-				continue
-			elif (option == u'sharifth'):
-				document_class = u'xepersian-thesis'
-				continue
-			elif (not option in latex_options):
-				packages += u'\\usepackage{' + option + u'}\n'
-				continue
-	
-			if (first_option):
-				result += u'['
-			else:
-				result += u','
-			result += option
-			first_option = 0
-		#end while
-		if (not first_option):
-			result += u']'
-		index = output_line.find(u'}',last_index)
-		if (document_class == u''):
-			result += output_line[last_index+1:index+1]
-		else:
-			result += u'{' + document_class + u'}'
-		# I assume that nothing important is after
-		# \documentstyle[]{}, otherwise it may conflict
-		# with our preamble
-		if (index != -1):
-			result += output_line[index+1:]
-		result += packages + u'\\usepackage{xepersian}\n'
-		result += preamble
-		return result
-	#end elif "documentstyle"
-
-	while (index < line_len):
-		next_index = output_line.find(u'\\', index)
-		comment_index = output_line.find(u'%', index)
-		if (next_index == -1):
-			result += output_line[index:]
-			break
-		elif (state == 1):
-			if (output_line[next_index:next_index+14] == u'\\end{verbatim}'):
-				result += output_line[index:next_index+14]
-				index = next_index+14
-				state = 0
-			else:
-				result += output_line[index:next_index+1]
-				index = next_index+1
-		elif (state == 2):
-			if (output_line[next_index:next_index+15] == u'\\end{verbatim*}'):
-				result += output_line[index:next_index+15]
-				index = next_index+15
-				state = 0
-			else:
-				result += output_line[index:next_index+1]
-				index = next_index+1
-		elif (comment_index != -1 and comment_index < next_index):
-			result += output_line[index:]
-			break
-		elif (output_line[next_index:next_index+14] == u"\\input{amssym}"):
-			result += u'\\usepackage{amssymb}'
-			index = next_index+14
-		elif (output_line[next_index:next_index+12] == u"\\input{epsf}"):
-			index = next_index+12
-		elif (output_line[next_index:next_index+15] == u"\\includeepspdf{"):
-			result += u'\\includegraphics{'
-			index = next_index+15
-		elif (output_line[next_index:next_index+16] == u"\\begin{verbatim}"):
-			result += output_line[index:next_index+16]
-			index = next_index+16
-			state = 1
-		elif (output_line[next_index:next_index+17] == u"\\begin{verbatim*}"):
-			result += output_line[index:next_index+17]
-			index = next_index+17
-			state = 2
-		elif (output_line[next_index:next_index+26] == u'\\setlength{\\headrulewidth}'):
-			end_cmd = output_line.find('}', next_index+26)
-			result += u'\\renewcommand{\\headrulewidth}' + output_line[next_index+26:end_cmd+1]
-			index = end_cmd+1
-		elif (output_line[next_index:next_index+26] == u'\\setlength{\\footrulewidth}'):
-			end_cmd = output_line.find('}', next_index+26)
-			result += u'\\renewcommand{\\footrulewidth}' + output_line[next_index+26:end_cmd+1]
-			index = end_cmd+1
-		elif (output_line[next_index:next_index+10] == u"\\epsffile{"):
-			result += output_line[index:next_index]
-			result += u'\\includegraphics'
-			size_options = u''
-			if (line_number - last_epsfxsize_line <= 3):
-				size_options = u'width=' + last_epsfxsize
-			if (line_number - last_epsfysize_line <= 3):
-				if (size_options != u''):
-					size_options += u','
-				size_options += u'height=' + last_epsfysize
-			if (size_options != u''):
-				result += u'[' + size_options + u']'
-			end_prn = output_line.find(u'.eps}', next_index+9)
-
-			if (end_prn != -1):
-				result += output_line[next_index+9:end_prn] + u'}'
-				index = end_prn+5
-			else:
-				end_prn = output_line.find(u'.ps}', next_index+9)
-				if (end_prn != -1):
-					result += output_line[next_index+9:end_prn] + u'}'
-					index = end_prn+4
-				else:
-					end_prn = output_line.find(u'}', next_index+9)
-					result += output_line[next_index+9:end_prn+1]
-					index = end_prn+1
-		# I assume all the parameter of \epsfxsize comes in one line
-		elif (output_line[next_index:next_index+11] == u"\\epsfxsize="):
-			end_size = read_size(output_line, next_index+11, line_len)
-			if (end_size != -1):
-				last_epsfxsize = output_line[next_index+11:end_size]
-				index = end_size
-			else:
-				index = next_index+11
-			last_epsfxsize_line = line_number
-		# I assume all the parameter of \epsfysize comes in one line
-		elif (output_line[next_index:next_index+11] == u"\\epsfysize="):
-			end_size = read_size(output_line, next_index+11, line_len)
-			if (end_size != -1):
-				last_epsfysize = output_line[next_index+11:end_size]
-				index = end_size
-			else:
-				index = next_index+11
-			last_epsfysize_line = line_number
-		elif (output_line[next_index:next_index+6] == u"\\verb*"):
-			end_verb = output_line.find(output_line[next_index+6], next_index+7)
-			result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+5] == u"\\verb"):
-			end_verb = output_line.find(output_line[next_index+5], next_index+6)
-			result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+9] == u"\\pmatrix{"):
-			result += u'\\ftxepmatrix{'
-			index = next_index+9
-		elif (output_line[next_index:next_index+16] == u"\\begin{document}"):
-			result += u'\\begin{document}\n\\VerbatimFootnotes'
-			index = next_index+16
-		else:
-			result += output_line[index:next_index+2]
-			index = next_index+2
-	#end while
-	return result
-
-def convert_file(f, of, convert_cmds):
-	global state
-	global line_number
-	global last_epsfysize_line
-	global last_epsfxsize_line
-	global last_epsfxsize
-	global last_epsfysize
-
-	state = 0
-	line_number = 0
-	last_epsfysize_line = 0
-	last_epsfxsize_line = 0
-	last_epsfxsize = u''
-	last_epsfysize = u''
-
-	for line in f:
-		line_number += 1
-		print line_number
-		output_line = u''
-		line_len = len(line)
-		
-		# remove new-line characters from end of line
-		if (line_len>1 and line[line_len-1] == '\n'):
-			line_len-=1
-		if (line_len>1 and line[line_len-1] == '\r'):
-			line_len-=1
-		
-		# check line-direction character
-		line_direction_rtl = (line[0] == '<')
-		if (line[0] != '>') and (line[0] != '<'):
-			print "FORMAT ERROR AT LINE: " + str(line_number)
-			exit(0)
-	
-		i = 1
-	
-		while (i<line_len):
-			next_part_index = ft_next_part(line, i, line_len)
-			next_part = line[i:next_part_index]
-			next_part_latin = (line[i]<chr(0x80))
-			
-			# see if we should put \lr{...} for the current english expression
-			if line_direction_rtl and next_part_latin:
-				is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
-				is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
-				is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
-				is_verb_parameter = ( (line[i-6:i] == F_SLASH+"verb") and not isalpha(line[i]))
-				is_verb = (next_part_latin and (line[i:i+5]=='\\verb' or line[i:i+6]==' \\verb'))
-			
-				cmd_index = 0
-				while cmd_index < len(commands):
-					len_cmd = len(commands[cmd_index])+2
-					if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
-						break
-					cmd_index += 1
-				is_commands_group = cmd_index < len(commands)
-				is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
-	
-			if next_part_latin:
-				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
-					output_line += u'\\lr{'
-				if ( line_direction_rtl and is_verb):
-					output_line += u'\\LR{'
-				
-				output_line += next_part.encode( 'utf-8' )
-				
-				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
-					output_line += u'}'
-				if ( line_direction_rtl and is_verb):
-					output_line += u'}'
-			else:
-				if ( not line_direction_rtl):
-					output_line += u'\\rl{'
-					
-				output_line += map_ft_unicode(next_part)
-				
-				if (not line_direction_rtl):
-					output_line += u'}'
-					
-			i = next_part_index
-		# end of while			
-		
-		# convert some of the FarsiTeX commands to XePersian commands
-		# only if it is requested
-		if (convert_cmds):
-			result = translate_cmds(output_line) 
-		else:
-			result = output_line
-		output_line = result + u'\n'
-		# write the processed line
-		of.write(output_line)
-		# end of line processing
-	# end of file processing
-
-###################################
-# Begin of main body of the program
-###################################
-
-# global variables
-line_number = 0
-last_epsfxsize = u''
-last_epsfxsize_line = 0
-last_epsfysize = u''
-last_epsfysize_line = 0
-state = 0
-
-if len(sys.argv) <= 2:
-	print 'usage: python undk in_filename out_filename'
-	exit(0)
-
-filename = sys.argv[1]
-outfile = sys.argv[2]
-
-try:
-	f = open(filename, 'r')
-except IOError:
-	print "Can not open the input file: " + filename
-	exit(0)
-
-try:
-	of = codecs.open(outfile, encoding='utf-8', mode='w')
-except IOError:
-	print "Can not open the output file: " + outfile
-	exit(0)
-
-convert_file(f, of, 1)
-	
-of.close()
-f.close()	

Added: trunk/ftxe-0.5.py
===================================================================
--- trunk/ftxe-0.5.py	2009-06-16 10:58:24 UTC (rev 71)
+++ trunk/ftxe-0.5.py	2009-06-17 04:11:03 UTC (rev 72)
@@ -0,0 +1,859 @@
+?#########################################
+#       General Public License          #
+#       Author:  Mostafa Vahedi         #
+#       Date:    16 June 2009           #
+#       Version  0.5                    #
+#########################################
+
+import codecs
+
+import sys
+
+
+ft_numerical = [
+chr(0xB9),	# 	Arabic Thoushads Seperator
+chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
+]
+
+
+ft_vowels = [
+chr(0xB0),	#	ARABIC FATHA
+chr(0xB1),	#	ARABIC KASRA
+chr(0xB2),	#	ARABIC DAMMA
+chr(0xB3),	#	ARABIC FATHATAN
+chr(0xB4),	#	ARABIC SHADDA
+chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB),	#	ARABIC HAMZA ABOVE
+chr(0xC4) 	#	ARABIC SUKUN
+]
+
+ft_non_joiners = [
+chr(0x8F)	#	ARABIC LETTER HAMZA
+]
+
+ft_bidi_joiners_initial = [
+chr(0xE4),	#	ARABIC LETTER AIN, initial form
+chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
+chr(0xFB) 	#	ARABIC LETTER HEH, initial form
+]
+
+ft_bidi_joiners_medial = [
+chr(0xE3),	#	ARABIC LETTER AIN, medial form
+chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
+chr(0xFA) 	#	ARABIC LETTER HEH, medial form
+]
+
+ft_bidi_joiners_final = [
+chr(0xE2),	#	ARABIC LETTER AIN, final form
+chr(0xE6),	#	ARABIC LETTER GHAIN, final form
+chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
+]
+
+ft_bidi_joiners_isolated = [
+chr(0xE1),	#	ARABIC LETTER AIN, isolated form
+chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
+chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
+]
+
+ft_bidi_joiners_initial_medial = [
+chr(0x8B),	#	ARABIC TATWEEL
+chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
+chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
+chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
+chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
+chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
+chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
+chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
+]
+
+ft_bidi_joiners_final_isolated = [
+chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
+chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
+chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
+chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
+chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
+chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
+chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
+chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
+]
+
+ft_right_joiners_final = [
+chr(0x91)	#	ARABIC LETTER ALEF, final form
+]
+
+ft_right_joiners_isolated = [
+chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x90)	#	ARABIC LETTER ALEF, isolated form
+]
+
+ft_right_joiners_final_isolated = [
+chr(0xA2),	#	ARABIC LETTER DAL
+chr(0xA3),	#	ARABIC LETTER THAL
+chr(0xA4),	#	ARABIC LETTER REH
+chr(0xA5),	#	ARABIC LETTER ZAIN
+chr(0xA6),	#	ARABIC LETTER JEH
+chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
+chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF8)	#	ARABIC LETTER WAW
+]
+
+
+table_FT_UN = {
+chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
+chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
+chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
+chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
+chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
+chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
+chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
+chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
+chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
+chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
+chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
+chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
+chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
+chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
+chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
+chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
+chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
+chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
+chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
+chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
+chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
+chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
+chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
+chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
+chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
+chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
+chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
+chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
+chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
+chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
+chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
+chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
+chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
+chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
+chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
+chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
+chr(0xB5) : [u'\u0023'],	# * #
+chr(0xB6) : [u'\u0024'],	# * $
+chr(0xB7) : [u'\u0025'],	# * %
+chr(0xB8) : [u'\u0026'],	# * &
+chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
+chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
+chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
+chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
+chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
+chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
+chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
+chr(0xC5) : [u'\u002D'],	# * -
+chr(0xC6) : [u'\u002E'],	# * FULL STOP
+chr(0xC7) : [u'\u002F'],	# * /
+chr(0xC8) : [u'\u002A'],	# * *
+chr(0xC9) : [u'\u007E'],	# * ~
+chr(0xCA) : [u'\u003A'],	# * COLON
+chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
+chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
+chr(0xCD) : [u'\u002B'],	# * +
+chr(0xCE) : [u'\u003D'],	# * =
+chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
+# chr(0xD0) : [u'\u0040'],	# * @
+chr(0xD0) : [u''],	        # * @
+chr(0xD1) : [u'\u005D'],	# * [
+chr(0xD2) : [u'\u005C'],	# * \
+chr(0xD3) : [u'\u005B'],	# * ]
+chr(0xD4) : [u'\u005E'],	# * ^
+chr(0xD5) : [u'\u005F'],	# * _
+chr(0xD6) : [u'\u0060'],	# * `
+chr(0xD7) : [u'\u007D'],	# * {
+chr(0xD8) : [u'\u007C'],	# * |
+chr(0xDA) : [u'\u0020'],	# * SPACE
+chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
+chr(0xDE) : [u'\u007B'],	# * }
+chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
+chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
+chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
+chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
+chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
+chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
+chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
+chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
+chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
+chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
+chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
+chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
+chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
+chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
+chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
+chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
+chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
+chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
+}
+
+F_SLASH = chr(0xD2)
+F_PRNT_OPEN = chr(0xDE)
+F_AT_SIGN = chr(0xD0)
+
+# latex and farsitex commands whose first parameter does not need \lr{...}
+commands = [ "begin", 
+"end",
+"input", "include", "includeonly",
+"hspace", "vspace", "hspace*", "vspace*",
+"label", "ref", "cite", "bibitem",
+"bibliographystyle",
+"parbox",
+"newenvironment", "newtheorem",
+"persianmathdigitsfamily",
+"fontfamily", "fontseries", "fontshape",
+"rmdefault", "sfdefault", "ttdefault",
+"bfdefault", "itdefault", "sldefault", "scdefault",
+"pagenumbering", "pagestyle", "thispagestyle",
+"setcounter", "stepcounter", "setlength", "addtolength"
+]
+
+
+def ft_is_numeric(ch):
+	if ((ch in ft_numerical) or 
+	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
+		return 1
+	return 0
+
+def ft_can_join_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_final) or
+	    (ch in ft_bidi_joiners_isolated) or
+	    (ch in ft_bidi_joiners_initial_medial) or
+	    (ch in ft_bidi_joiners_final_isolated)):
+    		return 1
+	return 0
+
+def ft_can_join_right(ch):
+	if (ft_can_join_left(ch) or 
+	    (ch in ft_right_joiners_final) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_right_joiners_final_isolated)):
+		return 1
+	return 0
+
+def ft_joining_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or 
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_initial_medial)):
+		return 1
+	return 0
+
+
+def ft_joining_right(ch):
+	if ((ch in ft_right_joiners_final) or
+	    (ch in ft_bidi_joiners_medial) or 
+	    (ch in ft_bidi_joiners_final)):
+		return 1
+	return 0
+
+def ft_not_right_joined(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_bidi_joiners_isolated)):
+		return 1
+	return 0
+
+def ft_adjust_shaping(text, i):
+	current = text[i]
+	u = u''
+	try:
+		u = table_FT_UN[current][0]
+	except KeyError:
+		return u''
+
+	#if you don't want shaping remove the following comment
+	#return u
+
+	if ((current in ft_vowels) or (ft_is_numeric(current))):
+		return u
+
+	#find next non-vowel character on the left
+	text_len = len(text)
+	next_index = i+1
+	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
+		next_index += 1
+
+	if (next_index == text_len):
+		next = ''
+	else:
+		next = text[next_index]
+
+	# if current letter is joining from left but next letter is or can not joining
+	if (ft_joining_left(current)):
+		if (not ft_can_join_right(next)):
+			u += u'\u200D' #ZWJ
+		elif (ft_not_right_joined(next)):
+			u += u'\u200D\u200C' #ZWJ+ZWNJ
+	# if current letter can join but next letter is joining from right
+	elif (ft_can_join_left(current)):
+		if (ft_joining_right(next)):
+			u += u'\u200C\u200D' #ZWNJ+ZWJ
+		elif (ft_can_join_right(next)):
+			u += u'\u200C' #ZWNJ
+	return u
+
+def ft_adjust_number(text):
+	result = u''
+	i = len(text)-1
+	while (i >= 0):
+		result += ft_adjust_shaping(text, i)
+		i -= 1
+	return result
+
+
+def map_ft_unicode(text):
+	mapped_text = u''
+
+	i = 0
+	while (i < len(text)):
+		if (ft_is_numeric(text[i])):
+			next_index = i
+			while ((next_index+1 < len(text)) and
+			       (ft_is_numeric(text[next_index+1]))):
+				next_index += 1
+			mapped_text += ft_adjust_number(text[i:next_index+1])
+			i = next_index+1
+			continue
+
+		mapped_text += ft_adjust_shaping(text, i)
+		i += 1
+	return mapped_text
+
+# Finds next token all of the same language
+def ft_next_part(line, i, line_len):
+	j = i
+	language_flag = (line[j]<chr(0x80))
+	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
+		j += 1
+	return j
+
+###############################################
+# from here all functions are used to translate
+# farsitex commands to xepersian commands
+###############################################
+
+def read_size(input,index,last_index):
+	dim_index = -1 
+	inch_index = input.find(u'in', index)
+	if (inch_index != -1):
+		dim_index = inch_index
+	mm_index = input.find(u'mm', index)
+	if (mm_index != -1):
+		if (dim_index == -1 or mm_index < index):
+			dim_index = mm_index
+	cm_index = input.find(u'cm', index)
+	if (cm_index != -1):
+		if (dim_index == -1 or cm_index < dim_index):
+			dim_index = cm_index
+	pt_index = input.find(u'pt', index)
+	if (pt_index != -1):
+		if (dim_index == -1 or pt_index < dim_index):
+			dim_index = pt_index
+	next_cmd = input.find(u'\\', index)
+	if (next_cmd == -1 and dim_index == -1):
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+	elif (next_cmd == -1 or (dim_index != -1 and next_cmd > dim_index)):
+		epsfxsize = input[index:dim_index+2]
+		return dim_index+2
+	elif (next_cmd != -1):
+		end_cmd = next_cmd+1
+		while (end_cmd < last_index and input[end_cmd].isalpha()):
+			end_cmd += 1
+		return end_cmd
+	else:
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+
+
+latex_options=[u'a4paper', u'a5paper', u'b5paper', 
+			   u'letterpaper', u'legalpaper', u'executivepaper', 
+			   u'landscape', u'10pt', u'11pt', u'12pt', 
+			   u'oneside', u'twoside', u'draft', 
+			   u'final', u'titlepage', u'notitlepage',
+			   u'onecolumn', u'twocolumn',
+			   u'leqno', u'fleqn']
+
+table_eq_packages = {
+u'poem'     : u'persianpoem',
+u'fmakeidx' : u'makeidx',
+u'ffancyhe' : u'fancyhdr',
+u'fmultico' : u'multicol'
+}
+
+farsitex_ignore_options = [u'persian', u'farsi', u'epsf', u'fgraphix']
+
+xepersian_packages = u'\n\\usepackage{url}\n\\usepackage{fancyvrb}\n\\usepackage{setspace}\\doublespace\n\\usepackage{graphicx}\n'
+xepersian_preamble = u'\\settextfont[Scale=1.2]{XB Zar}\n\\setlatintextfont[Scale=1.1]{Times New Roman}\n\\setdigitfont{XB Zar}\n\\let\\iranic\\it\n\\let\\siah\\bf\n\\let\\khabide\\sl\n\\def\\siahir{\\siah\\iranic}\n\\def\\siahkh{\\siah\\khabide}\n\\setpookfont{XB Kayhan Pook}\\let\\tookhali\\pookfamily\n\\setsayehfont{XB Kayhan Sayeh}\\let\\sayedar\\sayehfamily\n\\let\\farsi\\Persian\n\\let\\english\\Latin\n\\let\\farmbox\\mbox\n\\newcommand{\\ftxepmatrix}[1]{\\begin{pmatrix}#1\\end{pmatrix}}\n\\def\\FarsiTeX{\\lr{FarsiTeX}}\n\\def\\????????{\\rl{?????????}}\n'
+
+def is_alpha_numeric_space(input):
+	input_len = len(input)
+	i = 0
+	while (i<input_len):
+		if (not (input[i].isalpha() or input[i].isdigit() or input[i]==u'.' or input[i]==u' ') ):
+			return 0
+		i+=1
+	return 1
+
+def is_alpha_numeric(input):
+	input_len = len(input)
+	i = 0
+	while (i<input_len):
+		if (not (input[i].isalpha() or input[i].isdigit() or input[i]=='.') ):
+			return 0
+		i+=1
+	return 1
+			
+def find_eq_cmd(keyword):
+	try:
+		eq_cmd = table_eq_packages[keyword]
+	except KeyError:
+		eq_cmd = u''
+	return eq_cmd
+
+def convert_persian_to_english(num):
+	result = u''
+	num_len = len(num)
+	index = 0
+	while (index < num_len):
+		if (ord(num[index]) >= ord(u'?') and ord(num[index]) <= ord(u'?')):
+			result += unichr(ord(num[index]) - ord(u'?') + ord(u'0'))
+		else:
+			result += num[index]
+		index += 1
+	return result
+
+# \sayedar \tookhali
+# \verb|| -> \item[\verb||] or \section{\verb||}
+# \url{} -> does not show numbers
+# \kasre{} \alef{} ...
+# persian number as parameter: \multicolumn{8}, \addtocounter{page}{1}
+# pagenumbers are in english
+def translate_cmds(output_line):
+	global last_epsfxsize
+	global last_epsfxsize_line
+	global last_epsfysize
+	global last_epsfysize_line
+	global state
+
+	result = u''
+	line_len = len(output_line)
+	index = 0
+	if (state == 1): #\begin{verbatim}
+		end_verbatim = output_line.find('\\end{verbatim}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+14]
+		index = end_verbatim+14
+		state = 0
+	elif (state == 2): #\begin{verbatim*}
+		end_verbatim = output_line.find('\\end{verbatim*}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+15]
+		index = end_verbatim+15
+		state = 0
+	elif (output_line[0:14] == "\\documentstyle"):
+		result += u'\\documentclass'
+		#process options
+		last_index = output_line.find(u']')
+		index = 15
+		first_option = 1
+		preamble = xepersian_preamble
+		packages = xepersian_packages
+		document_class = u''
+		while (index < last_index):
+			next_comma = output_line.find(u',',index,last_index)
+			if (next_comma == -1):
+				next_comma = last_index
+			option = output_line[index:next_comma]
+			index = next_comma+1
+			eq_cmd = find_eq_cmd(option)
+			if (eq_cmd != u''):
+				packages += u'\\usepackage{' + eq_cmd + u'}\n'
+				continue
+			elif (option in farsitex_ignore_options):
+				continue
+			elif (option == u'sharifth'):
+				document_class = u'xepersian-thesis'
+				continue
+			elif (not option in latex_options):
+				packages += u'\\usepackage{' + option + u'}\n'
+				continue
+	
+			if (first_option):
+				result += u'['
+			else:
+				result += u','
+			result += option
+			first_option = 0
+		#end while
+		if (not first_option):
+			result += u']'
+		index = output_line.find(u'}',last_index)
+		if (document_class == u''):
+			result += output_line[last_index+1:index+1]
+		else:
+			result += u'{' + document_class + u'}'
+		# I assume that nothing important is after
+		# \documentstyle[]{}, otherwise it may conflict
+		# with our preamble
+		if (index != -1):
+			result += output_line[index+1:]
+		result += packages + u'\\usepackage{xepersian}\n'
+		result += preamble
+		return result
+	#end elif "documentstyle"
+
+	while (index < line_len):
+		next_index = output_line.find(u'\\', index)
+		comment_index = output_line.find(u'%', index)
+		if (next_index == -1):
+			result += output_line[index:]
+			break
+		elif (state == 1):
+			if (output_line[next_index:next_index+14] == u'\\end{verbatim}'):
+				result += output_line[index:next_index+14]
+				index = next_index+14
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (state == 2):
+			if (output_line[next_index:next_index+15] == u'\\end{verbatim*}'):
+				result += output_line[index:next_index+15]
+				index = next_index+15
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (comment_index != -1 and comment_index < next_index):
+			result += output_line[index:]
+			break
+		elif (output_line[next_index:next_index+14] == u"\\input{amssym}"):
+			result += u'\\usepackage{amssymb}'
+			index = next_index+14
+		elif (output_line[next_index:next_index+12] == u"\\input{epsf}"):
+			index = next_index+12
+		elif (output_line[next_index:next_index+15] == u"\\includeepspdf{"):
+			result += u'\\includegraphics{'
+			index = next_index+15
+		elif (output_line[next_index:next_index+16] == u"\\begin{verbatim}"):
+			result += output_line[index:next_index+16]
+			index = next_index+16
+			state = 1
+		elif (output_line[next_index:next_index+17] == u"\\begin{verbatim*}"):
+			result += output_line[index:next_index+17]
+			index = next_index+17
+			state = 2
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\headrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\headrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\footrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\footrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+10] == u"\\epsffile{"):
+			result += output_line[index:next_index]
+			result += u'\\includegraphics'
+			size_options = u''
+			if (line_number - last_epsfxsize_line <= 3):
+				size_options = u'width=' + last_epsfxsize
+			if (line_number - last_epsfysize_line <= 3):
+				if (size_options != u''):
+					size_options += u','
+				size_options += u'height=' + last_epsfysize
+			if (size_options != u''):
+				result += u'[' + size_options + u']'
+			end_prn = output_line.find(u'.eps}', next_index+9)
+
+			if (end_prn != -1):
+				result += output_line[next_index+9:end_prn] + u'}'
+				index = end_prn+5
+			else:
+				end_prn = output_line.find(u'.ps}', next_index+9)
+				if (end_prn != -1):
+					result += output_line[next_index+9:end_prn] + u'}'
+					index = end_prn+4
+				else:
+					end_prn = output_line.find(u'}', next_index+9)
+					result += output_line[next_index+9:end_prn+1]
+					index = end_prn+1
+		# I assume all the parameter of \epsfxsize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfxsize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfxsize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfxsize_line = line_number
+		# I assume all the parameter of \epsfysize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfysize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfysize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfysize_line = line_number
+		elif (output_line[next_index:next_index+10] == u"\\LR{\\verb*"):
+			end_verb = output_line.find(output_line[next_index+10], next_index+11)
+			verb_param = output_line[next_index+11:end_verb]
+			if (is_alpha_numeric(verb_param)):
+				result += output_line[index:next_index]
+				result += u'\\lr{\\tt{}' + verb_param
+			else:
+				result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+9] == u"\\LR{\\verb"):
+			end_verb = output_line.find(output_line[next_index+9], next_index+10)
+			verb_param = output_line[next_index+10:end_verb]
+			if (is_alpha_numeric_space(verb_param)):
+				result += output_line[index:next_index]
+				result += u'\\lr{\\tt{}' + verb_param
+			else:
+				result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+6] == u"\\verb*"):
+			end_verb = output_line.find(output_line[next_index+6], next_index+7)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+5] == u"\\verb"):
+			end_verb = output_line.find(output_line[next_index+5], next_index+6)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+9] == u"\\pmatrix{"):
+			result += u'\\ftxepmatrix{'
+			index = next_index+9
+		elif (output_line[next_index:next_index+16] == u"\\begin{document}"):
+			result += u'\\begin{document}\n\\VerbatimFootnotes'
+			index = next_index+16
+		elif (output_line[next_index:next_index+12] == u'\\setcounter{'):
+			begin_num = output_line.find(u'{', next_index+12)
+			end_num = output_line.find(u'}', begin_num)
+			num = convert_persian_to_english(output_line[begin_num+1:end_num])
+			result += output_line[index:begin_num+1]
+			result += num + u'}'
+			index = end_num+1
+		elif (output_line[next_index:next_index+14] == u'\\addtocounter{'):
+			begin_num = output_line.find(u'{', next_index+14)
+			end_num = output_line.find(u'}', begin_num)
+			num = convert_persian_to_english(output_line[begin_num+1:end_num])
+			print 'HI:'
+			print num
+			result += output_line[index:begin_num+1]
+			result += num + u'}'
+			index = end_num+1
+		elif (output_line[next_index:next_index+13] == u'\\multicolumn{'):
+			begin_num = next_index+13
+			end_num = output_line.find(u'}', begin_num)
+			num = convert_persian_to_english(output_line[begin_num:end_num])
+			result += output_line[index:begin_num]
+			result += num + u'}'
+			index = end_num+1
+		else:
+			result += output_line[index:next_index+2]
+			index = next_index+2
+	#end while
+	return result
+
+def convert_file(f, of, convert_cmds):
+	global state
+	global line_number
+	global last_epsfysize_line
+	global last_epsfxsize_line
+	global last_epsfxsize
+	global last_epsfysize
+
+	state = 0
+	line_number = 0
+	last_epsfysize_line = 0
+	last_epsfxsize_line = 0
+	last_epsfxsize = u''
+	last_epsfysize = u''
+
+	for line in f:
+		line_number += 1
+		print line_number
+		output_line = u''
+		line_len = len(line)
+		
+		# remove new-line characters from end of line
+		if (line_len>1 and line[line_len-1] == '\n'):
+			line_len-=1
+		if (line_len>1 and line[line_len-1] == '\r'):
+			line_len-=1
+		
+		# check line-direction character
+		line_direction_rtl = (line[0] == '<')
+		if (line[0] != '>') and (line[0] != '<'):
+			print "FORMAT ERROR AT LINE: " + str(line_number)
+			exit(0)
+	
+		i = 1
+	
+		while (i<line_len):
+			next_part_index = ft_next_part(line, i, line_len)
+			next_part = line[i:next_part_index]
+			next_part_latin = (line[i]<chr(0x80))
+			
+			# see if we should put \lr{...} for the current english expression
+			if line_direction_rtl and next_part_latin:
+				is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
+				is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
+				is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
+				is_verb_parameter = ( (line[i-6:i] == F_SLASH+"verb") and not isalpha(line[i]))
+				is_verb = (next_part_latin and (line[i:i+5]=='\\verb' or line[i:i+6]==' \\verb'))
+			
+				cmd_index = 0
+				while cmd_index < len(commands):
+					len_cmd = len(commands[cmd_index])+2
+					if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
+						break
+					cmd_index += 1
+				is_commands_group = cmd_index < len(commands)
+				is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
+	
+			if next_part_latin:
+				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
+					output_line += u'\\lr{'
+				if ( line_direction_rtl and is_verb):
+					output_line += u'\\LR{'
+				
+				output_line += next_part.encode( 'utf-8' )
+				
+				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
+					output_line += u'}'
+				if ( line_direction_rtl and is_verb):
+					output_line += u'}'
+			else:
+				if ( not line_direction_rtl):
+					output_line += u'\\rl{'
+					
+				output_line += map_ft_unicode(next_part)
+				
+				if (not line_direction_rtl):
+					output_line += u'}'
+					
+			i = next_part_index
+		# end of while			
+		
+		# convert some of the FarsiTeX commands to XePersian commands
+		# only if it is requested
+		if (convert_cmds):
+			result = translate_cmds(output_line) 
+		else:
+			result = output_line
+		output_line = result + u'\n'
+		# write the processed line
+		of.write(output_line)
+		# end of line processing
+	# end of file processing
+
+###################################
+# Begin of main body of the program
+###################################
+
+# global variables
+line_number = 0
+last_epsfxsize = u''
+last_epsfxsize_line = 0
+last_epsfysize = u''
+last_epsfysize_line = 0
+state = 0
+
+if len(sys.argv) <= 2:
+	print 'usage: python undk in_filename out_filename'
+	exit(0)
+
+filename = sys.argv[1]
+outfile = sys.argv[2]
+
+try:
+	f = open(filename, 'r')
+except IOError:
+	print "Can not open the input file: " + filename
+	exit(0)
+
+try:
+	of = codecs.open(outfile, encoding='utf-8', mode='w')
+except IOError:
+	print "Can not open the output file: " + outfile
+	exit(0)
+
+convert_file(f, of, 1)
+	
+of.close()
+f.close()	



From vafa at mail.berlios.de  Thu Jun 18 02:49:17 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Thu, 18 Jun 2009 02:49:17 +0200
Subject: [Xepersian-development] r73 - trunk
Message-ID: <200906180049.n5I0nH3G029208@sheep.berlios.de>

Author: vafa
Date: 2009-06-18 02:49:05 +0200 (Thu, 18 Jun 2009)
New Revision: 73

Modified:
   trunk/xepersian.dtx
Log:
added persian caption for \@@and in ams classes

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-17 04:11:03 UTC (rev 72)
+++ trunk/xepersian.dtx	2009-06-18 00:49:05 UTC (rev 73)
@@ -163,7 +163,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 71}
+\def\xepersianrevision{revision 73}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]
@@ -325,6 +325,7 @@
 \def\abstractname{\if at RTL ?????\else Abstract\fi}
 \def\partname{\if at RTL ???\else Part\fi}
 \def\datename{\if at RTL ?????:\else Date:\fi}
+\def\@@and{\if at RTL ?\else and\fi}
 \def\bibname{\if at RTL ?????????\else Bibliography\fi}
 \def\chaptername{\if at RTL ???\else Chapter\fi}
 \def\ccname{\if at RTL ??????\else cc\fi}



From vafa at mail.berlios.de  Fri Jun 19 10:12:59 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Fri, 19 Jun 2009 10:12:59 +0200
Subject: [Xepersian-development] r74 - trunk
Message-ID: <200906190812.n5J8CxkQ018410@sheep.berlios.de>

Author: vafa
Date: 2009-06-19 10:12:47 +0200 (Fri, 19 Jun 2009)
New Revision: 74

Removed:
   trunk/parsidigits.tec
   trunk/txt2maths.tec
Log:
delete old tec files

Deleted: trunk/parsidigits.tec
===================================================================
(Binary files differ)

Deleted: trunk/txt2maths.tec
===================================================================
(Binary files differ)



From vafa at mail.berlios.de  Fri Jun 19 10:14:35 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Fri, 19 Jun 2009 10:14:35 +0200
Subject: [Xepersian-development] r75 - trunk
Message-ID: <200906190814.n5J8EZtU018496@sheep.berlios.de>

Author: vafa
Date: 2009-06-19 10:14:26 +0200 (Fri, 19 Jun 2009)
New Revision: 75

Added:
   trunk/parsidigits.tec
   trunk/txt2maths.tec
Modified:
   trunk/xepersian.dtx
Log:
added new tec files

Added: trunk/parsidigits.tec
===================================================================
(Binary files differ)


Property changes on: trunk/parsidigits.tec
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/txt2maths.tec
===================================================================
(Binary files differ)


Property changes on: trunk/txt2maths.tec
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/xepersian.dtx
===================================================================
--- trunk/xepersian.dtx	2009-06-19 08:12:47 UTC (rev 74)
+++ trunk/xepersian.dtx	2009-06-19 08:14:26 UTC (rev 75)
@@ -163,7 +163,7 @@
 %    \begin{macrocode}
 \NeedsTeXFormat{LaTeX2e}
 \def\xepersianversion{v1.0.1}
-\def\xepersianrevision{revision 73}
+\def\xepersianrevision{revision 75}
 \def\xepersiandate{2009/06/01}
 \ProvidesPackage{xepersian}[\xepersiandate\space \xepersianversion\space <\xepersianrevision>
 	Persian typesetting in XeLaTeX]



From vafa at mail.berlios.de  Wed Jun 24 06:37:30 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Wed, 24 Jun 2009 06:37:30 +0200
Subject: [Xepersian-development] r76 - trunk
Message-ID: <200906240437.n5O4bUq7029060@sheep.berlios.de>

Author: vafa
Date: 2009-06-24 06:37:11 +0200 (Wed, 24 Jun 2009)
New Revision: 76

Added:
   trunk/ftxe-0.6.py
Removed:
   trunk/ftxe-0.5.py
Log:
added new version of farsitex-unicode converter per Mostafa

Deleted: trunk/ftxe-0.5.py
===================================================================
--- trunk/ftxe-0.5.py	2009-06-19 08:14:26 UTC (rev 75)
+++ trunk/ftxe-0.5.py	2009-06-24 04:37:11 UTC (rev 76)
@@ -1,859 +0,0 @@
-?#########################################
-#       General Public License          #
-#       Author:  Mostafa Vahedi         #
-#       Date:    16 June 2009           #
-#       Version  0.5                    #
-#########################################
-
-import codecs
-
-import sys
-
-
-ft_numerical = [
-chr(0xB9),	# 	Arabic Thoushads Seperator
-chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
-]
-
-
-ft_vowels = [
-chr(0xB0),	#	ARABIC FATHA
-chr(0xB1),	#	ARABIC KASRA
-chr(0xB2),	#	ARABIC DAMMA
-chr(0xB3),	#	ARABIC FATHATAN
-chr(0xB4),	#	ARABIC SHADDA
-chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB),	#	ARABIC HAMZA ABOVE
-chr(0xC4) 	#	ARABIC SUKUN
-]
-
-ft_non_joiners = [
-chr(0x8F)	#	ARABIC LETTER HAMZA
-]
-
-ft_bidi_joiners_initial = [
-chr(0xE4),	#	ARABIC LETTER AIN, initial form
-chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
-chr(0xFB) 	#	ARABIC LETTER HEH, initial form
-]
-
-ft_bidi_joiners_medial = [
-chr(0xE3),	#	ARABIC LETTER AIN, medial form
-chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
-chr(0xFA) 	#	ARABIC LETTER HEH, medial form
-]
-
-ft_bidi_joiners_final = [
-chr(0xE2),	#	ARABIC LETTER AIN, final form
-chr(0xE6),	#	ARABIC LETTER GHAIN, final form
-chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
-]
-
-ft_bidi_joiners_isolated = [
-chr(0xE1),	#	ARABIC LETTER AIN, isolated form
-chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
-chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
-]
-
-ft_bidi_joiners_initial_medial = [
-chr(0x8B),	#	ARABIC TATWEEL
-chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
-chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
-chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
-chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
-chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
-chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
-chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
-]
-
-ft_bidi_joiners_final_isolated = [
-chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
-chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
-chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
-chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
-chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
-chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
-chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
-chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
-]
-
-ft_right_joiners_final = [
-chr(0x91)	#	ARABIC LETTER ALEF, final form
-]
-
-ft_right_joiners_isolated = [
-chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x90)	#	ARABIC LETTER ALEF, isolated form
-]
-
-ft_right_joiners_final_isolated = [
-chr(0xA2),	#	ARABIC LETTER DAL
-chr(0xA3),	#	ARABIC LETTER THAL
-chr(0xA4),	#	ARABIC LETTER REH
-chr(0xA5),	#	ARABIC LETTER ZAIN
-chr(0xA6),	#	ARABIC LETTER JEH
-chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
-chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF8)	#	ARABIC LETTER WAW
-]
-
-
-table_FT_UN = {
-chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
-chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
-chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
-chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
-chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
-chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
-chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
-chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
-chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
-chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
-chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
-chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
-chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
-chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
-chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
-chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
-chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
-chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
-chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
-chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
-chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
-chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
-chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
-chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
-chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
-chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
-chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
-chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
-chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
-chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
-chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
-chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
-chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
-chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
-chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
-chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
-chr(0xB5) : [u'\u0023'],	# * #
-chr(0xB6) : [u'\u0024'],	# * $
-chr(0xB7) : [u'\u0025'],	# * %
-chr(0xB8) : [u'\u0026'],	# * &
-chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
-chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
-chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
-chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
-chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
-chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
-chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
-chr(0xC5) : [u'\u002D'],	# * -
-chr(0xC6) : [u'\u002E'],	# * FULL STOP
-chr(0xC7) : [u'\u002F'],	# * /
-chr(0xC8) : [u'\u002A'],	# * *
-chr(0xC9) : [u'\u007E'],	# * ~
-chr(0xCA) : [u'\u003A'],	# * COLON
-chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
-chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
-chr(0xCD) : [u'\u002B'],	# * +
-chr(0xCE) : [u'\u003D'],	# * =
-chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
-# chr(0xD0) : [u'\u0040'],	# * @
-chr(0xD0) : [u''],	        # * @
-chr(0xD1) : [u'\u005D'],	# * [
-chr(0xD2) : [u'\u005C'],	# * \
-chr(0xD3) : [u'\u005B'],	# * ]
-chr(0xD4) : [u'\u005E'],	# * ^
-chr(0xD5) : [u'\u005F'],	# * _
-chr(0xD6) : [u'\u0060'],	# * `
-chr(0xD7) : [u'\u007D'],	# * {
-chr(0xD8) : [u'\u007C'],	# * |
-chr(0xDA) : [u'\u0020'],	# * SPACE
-chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
-chr(0xDE) : [u'\u007B'],	# * }
-chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
-chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
-chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
-chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
-chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
-chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
-chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
-chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
-chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
-chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
-chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
-chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
-chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
-chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
-chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
-chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
-chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
-chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
-}
-
-F_SLASH = chr(0xD2)
-F_PRNT_OPEN = chr(0xDE)
-F_AT_SIGN = chr(0xD0)
-
-# latex and farsitex commands whose first parameter does not need \lr{...}
-commands = [ "begin", 
-"end",
-"input", "include", "includeonly",
-"hspace", "vspace", "hspace*", "vspace*",
-"label", "ref", "cite", "bibitem",
-"bibliographystyle",
-"parbox",
-"newenvironment", "newtheorem",
-"persianmathdigitsfamily",
-"fontfamily", "fontseries", "fontshape",
-"rmdefault", "sfdefault", "ttdefault",
-"bfdefault", "itdefault", "sldefault", "scdefault",
-"pagenumbering", "pagestyle", "thispagestyle",
-"setcounter", "stepcounter", "setlength", "addtolength"
-]
-
-
-def ft_is_numeric(ch):
-	if ((ch in ft_numerical) or 
-	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
-		return 1
-	return 0
-
-def ft_can_join_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_final) or
-	    (ch in ft_bidi_joiners_isolated) or
-	    (ch in ft_bidi_joiners_initial_medial) or
-	    (ch in ft_bidi_joiners_final_isolated)):
-    		return 1
-	return 0
-
-def ft_can_join_right(ch):
-	if (ft_can_join_left(ch) or 
-	    (ch in ft_right_joiners_final) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_right_joiners_final_isolated)):
-		return 1
-	return 0
-
-def ft_joining_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or 
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_initial_medial)):
-		return 1
-	return 0
-
-
-def ft_joining_right(ch):
-	if ((ch in ft_right_joiners_final) or
-	    (ch in ft_bidi_joiners_medial) or 
-	    (ch in ft_bidi_joiners_final)):
-		return 1
-	return 0
-
-def ft_not_right_joined(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_bidi_joiners_isolated)):
-		return 1
-	return 0
-
-def ft_adjust_shaping(text, i):
-	current = text[i]
-	u = u''
-	try:
-		u = table_FT_UN[current][0]
-	except KeyError:
-		return u''
-
-	#if you don't want shaping remove the following comment
-	#return u
-
-	if ((current in ft_vowels) or (ft_is_numeric(current))):
-		return u
-
-	#find next non-vowel character on the left
-	text_len = len(text)
-	next_index = i+1
-	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
-		next_index += 1
-
-	if (next_index == text_len):
-		next = ''
-	else:
-		next = text[next_index]
-
-	# if current letter is joining from left but next letter is or can not joining
-	if (ft_joining_left(current)):
-		if (not ft_can_join_right(next)):
-			u += u'\u200D' #ZWJ
-		elif (ft_not_right_joined(next)):
-			u += u'\u200D\u200C' #ZWJ+ZWNJ
-	# if current letter can join but next letter is joining from right
-	elif (ft_can_join_left(current)):
-		if (ft_joining_right(next)):
-			u += u'\u200C\u200D' #ZWNJ+ZWJ
-		elif (ft_can_join_right(next)):
-			u += u'\u200C' #ZWNJ
-	return u
-
-def ft_adjust_number(text):
-	result = u''
-	i = len(text)-1
-	while (i >= 0):
-		result += ft_adjust_shaping(text, i)
-		i -= 1
-	return result
-
-
-def map_ft_unicode(text):
-	mapped_text = u''
-
-	i = 0
-	while (i < len(text)):
-		if (ft_is_numeric(text[i])):
-			next_index = i
-			while ((next_index+1 < len(text)) and
-			       (ft_is_numeric(text[next_index+1]))):
-				next_index += 1
-			mapped_text += ft_adjust_number(text[i:next_index+1])
-			i = next_index+1
-			continue
-
-		mapped_text += ft_adjust_shaping(text, i)
-		i += 1
-	return mapped_text
-
-# Finds next token all of the same language
-def ft_next_part(line, i, line_len):
-	j = i
-	language_flag = (line[j]<chr(0x80))
-	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
-		j += 1
-	return j
-
-###############################################
-# from here all functions are used to translate
-# farsitex commands to xepersian commands
-###############################################
-
-def read_size(input,index,last_index):
-	dim_index = -1 
-	inch_index = input.find(u'in', index)
-	if (inch_index != -1):
-		dim_index = inch_index
-	mm_index = input.find(u'mm', index)
-	if (mm_index != -1):
-		if (dim_index == -1 or mm_index < index):
-			dim_index = mm_index
-	cm_index = input.find(u'cm', index)
-	if (cm_index != -1):
-		if (dim_index == -1 or cm_index < dim_index):
-			dim_index = cm_index
-	pt_index = input.find(u'pt', index)
-	if (pt_index != -1):
-		if (dim_index == -1 or pt_index < dim_index):
-			dim_index = pt_index
-	next_cmd = input.find(u'\\', index)
-	if (next_cmd == -1 and dim_index == -1):
-		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
-		return -1
-	elif (next_cmd == -1 or (dim_index != -1 and next_cmd > dim_index)):
-		epsfxsize = input[index:dim_index+2]
-		return dim_index+2
-	elif (next_cmd != -1):
-		end_cmd = next_cmd+1
-		while (end_cmd < last_index and input[end_cmd].isalpha()):
-			end_cmd += 1
-		return end_cmd
-	else:
-		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
-		return -1
-
-
-latex_options=[u'a4paper', u'a5paper', u'b5paper', 
-			   u'letterpaper', u'legalpaper', u'executivepaper', 
-			   u'landscape', u'10pt', u'11pt', u'12pt', 
-			   u'oneside', u'twoside', u'draft', 
-			   u'final', u'titlepage', u'notitlepage',
-			   u'onecolumn', u'twocolumn',
-			   u'leqno', u'fleqn']
-
-table_eq_packages = {
-u'poem'     : u'persianpoem',
-u'fmakeidx' : u'makeidx',
-u'ffancyhe' : u'fancyhdr',
-u'fmultico' : u'multicol'
-}
-
-farsitex_ignore_options = [u'persian', u'farsi', u'epsf', u'fgraphix']
-
-xepersian_packages = u'\n\\usepackage{url}\n\\usepackage{fancyvrb}\n\\usepackage{setspace}\\doublespace\n\\usepackage{graphicx}\n'
-xepersian_preamble = u'\\settextfont[Scale=1.2]{XB Zar}\n\\setlatintextfont[Scale=1.1]{Times New Roman}\n\\setdigitfont{XB Zar}\n\\let\\iranic\\it\n\\let\\siah\\bf\n\\let\\khabide\\sl\n\\def\\siahir{\\siah\\iranic}\n\\def\\siahkh{\\siah\\khabide}\n\\setpookfont{XB Kayhan Pook}\\let\\tookhali\\pookfamily\n\\setsayehfont{XB Kayhan Sayeh}\\let\\sayedar\\sayehfamily\n\\let\\farsi\\Persian\n\\let\\english\\Latin\n\\let\\farmbox\\mbox\n\\newcommand{\\ftxepmatrix}[1]{\\begin{pmatrix}#1\\end{pmatrix}}\n\\def\\FarsiTeX{\\lr{FarsiTeX}}\n\\def\\????????{\\rl{?????????}}\n'
-
-def is_alpha_numeric_space(input):
-	input_len = len(input)
-	i = 0
-	while (i<input_len):
-		if (not (input[i].isalpha() or input[i].isdigit() or input[i]==u'.' or input[i]==u' ') ):
-			return 0
-		i+=1
-	return 1
-
-def is_alpha_numeric(input):
-	input_len = len(input)
-	i = 0
-	while (i<input_len):
-		if (not (input[i].isalpha() or input[i].isdigit() or input[i]=='.') ):
-			return 0
-		i+=1
-	return 1
-			
-def find_eq_cmd(keyword):
-	try:
-		eq_cmd = table_eq_packages[keyword]
-	except KeyError:
-		eq_cmd = u''
-	return eq_cmd
-
-def convert_persian_to_english(num):
-	result = u''
-	num_len = len(num)
-	index = 0
-	while (index < num_len):
-		if (ord(num[index]) >= ord(u'?') and ord(num[index]) <= ord(u'?')):
-			result += unichr(ord(num[index]) - ord(u'?') + ord(u'0'))
-		else:
-			result += num[index]
-		index += 1
-	return result
-
-# \sayedar \tookhali
-# \verb|| -> \item[\verb||] or \section{\verb||}
-# \url{} -> does not show numbers
-# \kasre{} \alef{} ...
-# persian number as parameter: \multicolumn{8}, \addtocounter{page}{1}
-# pagenumbers are in english
-def translate_cmds(output_line):
-	global last_epsfxsize
-	global last_epsfxsize_line
-	global last_epsfysize
-	global last_epsfysize_line
-	global state
-
-	result = u''
-	line_len = len(output_line)
-	index = 0
-	if (state == 1): #\begin{verbatim}
-		end_verbatim = output_line.find('\\end{verbatim}')
-		if (end_verbatim == -1):
-			return output_line
-		result += output_line[0:end_verbatim+14]
-		index = end_verbatim+14
-		state = 0
-	elif (state == 2): #\begin{verbatim*}
-		end_verbatim = output_line.find('\\end{verbatim*}')
-		if (end_verbatim == -1):
-			return output_line
-		result += output_line[0:end_verbatim+15]
-		index = end_verbatim+15
-		state = 0
-	elif (output_line[0:14] == "\\documentstyle"):
-		result += u'\\documentclass'
-		#process options
-		last_index = output_line.find(u']')
-		index = 15
-		first_option = 1
-		preamble = xepersian_preamble
-		packages = xepersian_packages
-		document_class = u''
-		while (index < last_index):
-			next_comma = output_line.find(u',',index,last_index)
-			if (next_comma == -1):
-				next_comma = last_index
-			option = output_line[index:next_comma]
-			index = next_comma+1
-			eq_cmd = find_eq_cmd(option)
-			if (eq_cmd != u''):
-				packages += u'\\usepackage{' + eq_cmd + u'}\n'
-				continue
-			elif (option in farsitex_ignore_options):
-				continue
-			elif (option == u'sharifth'):
-				document_class = u'xepersian-thesis'
-				continue
-			elif (not option in latex_options):
-				packages += u'\\usepackage{' + option + u'}\n'
-				continue
-	
-			if (first_option):
-				result += u'['
-			else:
-				result += u','
-			result += option
-			first_option = 0
-		#end while
-		if (not first_option):
-			result += u']'
-		index = output_line.find(u'}',last_index)
-		if (document_class == u''):
-			result += output_line[last_index+1:index+1]
-		else:
-			result += u'{' + document_class + u'}'
-		# I assume that nothing important is after
-		# \documentstyle[]{}, otherwise it may conflict
-		# with our preamble
-		if (index != -1):
-			result += output_line[index+1:]
-		result += packages + u'\\usepackage{xepersian}\n'
-		result += preamble
-		return result
-	#end elif "documentstyle"
-
-	while (index < line_len):
-		next_index = output_line.find(u'\\', index)
-		comment_index = output_line.find(u'%', index)
-		if (next_index == -1):
-			result += output_line[index:]
-			break
-		elif (state == 1):
-			if (output_line[next_index:next_index+14] == u'\\end{verbatim}'):
-				result += output_line[index:next_index+14]
-				index = next_index+14
-				state = 0
-			else:
-				result += output_line[index:next_index+1]
-				index = next_index+1
-		elif (state == 2):
-			if (output_line[next_index:next_index+15] == u'\\end{verbatim*}'):
-				result += output_line[index:next_index+15]
-				index = next_index+15
-				state = 0
-			else:
-				result += output_line[index:next_index+1]
-				index = next_index+1
-		elif (comment_index != -1 and comment_index < next_index):
-			result += output_line[index:]
-			break
-		elif (output_line[next_index:next_index+14] == u"\\input{amssym}"):
-			result += u'\\usepackage{amssymb}'
-			index = next_index+14
-		elif (output_line[next_index:next_index+12] == u"\\input{epsf}"):
-			index = next_index+12
-		elif (output_line[next_index:next_index+15] == u"\\includeepspdf{"):
-			result += u'\\includegraphics{'
-			index = next_index+15
-		elif (output_line[next_index:next_index+16] == u"\\begin{verbatim}"):
-			result += output_line[index:next_index+16]
-			index = next_index+16
-			state = 1
-		elif (output_line[next_index:next_index+17] == u"\\begin{verbatim*}"):
-			result += output_line[index:next_index+17]
-			index = next_index+17
-			state = 2
-		elif (output_line[next_index:next_index+26] == u'\\setlength{\\headrulewidth}'):
-			end_cmd = output_line.find('}', next_index+26)
-			result += u'\\renewcommand{\\headrulewidth}' + output_line[next_index+26:end_cmd+1]
-			index = end_cmd+1
-		elif (output_line[next_index:next_index+26] == u'\\setlength{\\footrulewidth}'):
-			end_cmd = output_line.find('}', next_index+26)
-			result += u'\\renewcommand{\\footrulewidth}' + output_line[next_index+26:end_cmd+1]
-			index = end_cmd+1
-		elif (output_line[next_index:next_index+10] == u"\\epsffile{"):
-			result += output_line[index:next_index]
-			result += u'\\includegraphics'
-			size_options = u''
-			if (line_number - last_epsfxsize_line <= 3):
-				size_options = u'width=' + last_epsfxsize
-			if (line_number - last_epsfysize_line <= 3):
-				if (size_options != u''):
-					size_options += u','
-				size_options += u'height=' + last_epsfysize
-			if (size_options != u''):
-				result += u'[' + size_options + u']'
-			end_prn = output_line.find(u'.eps}', next_index+9)
-
-			if (end_prn != -1):
-				result += output_line[next_index+9:end_prn] + u'}'
-				index = end_prn+5
-			else:
-				end_prn = output_line.find(u'.ps}', next_index+9)
-				if (end_prn != -1):
-					result += output_line[next_index+9:end_prn] + u'}'
-					index = end_prn+4
-				else:
-					end_prn = output_line.find(u'}', next_index+9)
-					result += output_line[next_index+9:end_prn+1]
-					index = end_prn+1
-		# I assume all the parameter of \epsfxsize comes in one line
-		elif (output_line[next_index:next_index+11] == u"\\epsfxsize="):
-			end_size = read_size(output_line, next_index+11, line_len)
-			if (end_size != -1):
-				last_epsfxsize = output_line[next_index+11:end_size]
-				index = end_size
-			else:
-				index = next_index+11
-			last_epsfxsize_line = line_number
-		# I assume all the parameter of \epsfysize comes in one line
-		elif (output_line[next_index:next_index+11] == u"\\epsfysize="):
-			end_size = read_size(output_line, next_index+11, line_len)
-			if (end_size != -1):
-				last_epsfysize = output_line[next_index+11:end_size]
-				index = end_size
-			else:
-				index = next_index+11
-			last_epsfysize_line = line_number
-		elif (output_line[next_index:next_index+10] == u"\\LR{\\verb*"):
-			end_verb = output_line.find(output_line[next_index+10], next_index+11)
-			verb_param = output_line[next_index+11:end_verb]
-			if (is_alpha_numeric(verb_param)):
-				result += output_line[index:next_index]
-				result += u'\\lr{\\tt{}' + verb_param
-			else:
-				result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+9] == u"\\LR{\\verb"):
-			end_verb = output_line.find(output_line[next_index+9], next_index+10)
-			verb_param = output_line[next_index+10:end_verb]
-			if (is_alpha_numeric_space(verb_param)):
-				result += output_line[index:next_index]
-				result += u'\\lr{\\tt{}' + verb_param
-			else:
-				result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+6] == u"\\verb*"):
-			end_verb = output_line.find(output_line[next_index+6], next_index+7)
-			result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+5] == u"\\verb"):
-			end_verb = output_line.find(output_line[next_index+5], next_index+6)
-			result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+9] == u"\\pmatrix{"):
-			result += u'\\ftxepmatrix{'
-			index = next_index+9
-		elif (output_line[next_index:next_index+16] == u"\\begin{document}"):
-			result += u'\\begin{document}\n\\VerbatimFootnotes'
-			index = next_index+16
-		elif (output_line[next_index:next_index+12] == u'\\setcounter{'):
-			begin_num = output_line.find(u'{', next_index+12)
-			end_num = output_line.find(u'}', begin_num)
-			num = convert_persian_to_english(output_line[begin_num+1:end_num])
-			result += output_line[index:begin_num+1]
-			result += num + u'}'
-			index = end_num+1
-		elif (output_line[next_index:next_index+14] == u'\\addtocounter{'):
-			begin_num = output_line.find(u'{', next_index+14)
-			end_num = output_line.find(u'}', begin_num)
-			num = convert_persian_to_english(output_line[begin_num+1:end_num])
-			print 'HI:'
-			print num
-			result += output_line[index:begin_num+1]
-			result += num + u'}'
-			index = end_num+1
-		elif (output_line[next_index:next_index+13] == u'\\multicolumn{'):
-			begin_num = next_index+13
-			end_num = output_line.find(u'}', begin_num)
-			num = convert_persian_to_english(output_line[begin_num:end_num])
-			result += output_line[index:begin_num]
-			result += num + u'}'
-			index = end_num+1
-		else:
-			result += output_line[index:next_index+2]
-			index = next_index+2
-	#end while
-	return result
-
-def convert_file(f, of, convert_cmds):
-	global state
-	global line_number
-	global last_epsfysize_line
-	global last_epsfxsize_line
-	global last_epsfxsize
-	global last_epsfysize
-
-	state = 0
-	line_number = 0
-	last_epsfysize_line = 0
-	last_epsfxsize_line = 0
-	last_epsfxsize = u''
-	last_epsfysize = u''
-
-	for line in f:
-		line_number += 1
-		print line_number
-		output_line = u''
-		line_len = len(line)
-		
-		# remove new-line characters from end of line
-		if (line_len>1 and line[line_len-1] == '\n'):
-			line_len-=1
-		if (line_len>1 and line[line_len-1] == '\r'):
-			line_len-=1
-		
-		# check line-direction character
-		line_direction_rtl = (line[0] == '<')
-		if (line[0] != '>') and (line[0] != '<'):
-			print "FORMAT ERROR AT LINE: " + str(line_number)
-			exit(0)
-	
-		i = 1
-	
-		while (i<line_len):
-			next_part_index = ft_next_part(line, i, line_len)
-			next_part = line[i:next_part_index]
-			next_part_latin = (line[i]<chr(0x80))
-			
-			# see if we should put \lr{...} for the current english expression
-			if line_direction_rtl and next_part_latin:
-				is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
-				is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
-				is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
-				is_verb_parameter = ( (line[i-6:i] == F_SLASH+"verb") and not isalpha(line[i]))
-				is_verb = (next_part_latin and (line[i:i+5]=='\\verb' or line[i:i+6]==' \\verb'))
-			
-				cmd_index = 0
-				while cmd_index < len(commands):
-					len_cmd = len(commands[cmd_index])+2
-					if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
-						break
-					cmd_index += 1
-				is_commands_group = cmd_index < len(commands)
-				is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
-	
-			if next_part_latin:
-				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
-					output_line += u'\\lr{'
-				if ( line_direction_rtl and is_verb):
-					output_line += u'\\LR{'
-				
-				output_line += next_part.encode( 'utf-8' )
-				
-				if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb) ):
-					output_line += u'}'
-				if ( line_direction_rtl and is_verb):
-					output_line += u'}'
-			else:
-				if ( not line_direction_rtl):
-					output_line += u'\\rl{'
-					
-				output_line += map_ft_unicode(next_part)
-				
-				if (not line_direction_rtl):
-					output_line += u'}'
-					
-			i = next_part_index
-		# end of while			
-		
-		# convert some of the FarsiTeX commands to XePersian commands
-		# only if it is requested
-		if (convert_cmds):
-			result = translate_cmds(output_line) 
-		else:
-			result = output_line
-		output_line = result + u'\n'
-		# write the processed line
-		of.write(output_line)
-		# end of line processing
-	# end of file processing
-
-###################################
-# Begin of main body of the program
-###################################
-
-# global variables
-line_number = 0
-last_epsfxsize = u''
-last_epsfxsize_line = 0
-last_epsfysize = u''
-last_epsfysize_line = 0
-state = 0
-
-if len(sys.argv) <= 2:
-	print 'usage: python undk in_filename out_filename'
-	exit(0)
-
-filename = sys.argv[1]
-outfile = sys.argv[2]
-
-try:
-	f = open(filename, 'r')
-except IOError:
-	print "Can not open the input file: " + filename
-	exit(0)
-
-try:
-	of = codecs.open(outfile, encoding='utf-8', mode='w')
-except IOError:
-	print "Can not open the output file: " + outfile
-	exit(0)
-
-convert_file(f, of, 1)
-	
-of.close()
-f.close()	

Added: trunk/ftxe-0.6.py
===================================================================
--- trunk/ftxe-0.6.py	2009-06-19 08:14:26 UTC (rev 75)
+++ trunk/ftxe-0.6.py	2009-06-24 04:37:11 UTC (rev 76)
@@ -0,0 +1,933 @@
+?#########################################
+#       General Public License          #
+#       Author:  Mostafa Vahedi         #
+#       Date:    21 June 2009           #
+#       Version  0.6                    #
+#########################################
+
+import codecs
+
+import sys
+import os
+
+ft_numerical = [
+chr(0xB9),	# 	Arabic Thoushads Seperator
+chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
+]
+
+
+ft_vowels = [
+chr(0xB0),	#	ARABIC FATHA
+chr(0xB1),	#	ARABIC KASRA
+chr(0xB2),	#	ARABIC DAMMA
+chr(0xB3),	#	ARABIC FATHATAN
+chr(0xB4),	#	ARABIC SHADDA
+chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB),	#	ARABIC HAMZA ABOVE
+chr(0xC4) 	#	ARABIC SUKUN
+]
+
+ft_non_joiners = [
+chr(0x8F)	#	ARABIC LETTER HAMZA
+]
+
+ft_bidi_joiners_initial = [
+chr(0xE4),	#	ARABIC LETTER AIN, initial form
+chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
+chr(0xFB) 	#	ARABIC LETTER HEH, initial form
+]
+
+ft_bidi_joiners_medial = [
+chr(0xE3),	#	ARABIC LETTER AIN, medial form
+chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
+chr(0xFA) 	#	ARABIC LETTER HEH, medial form
+]
+
+ft_bidi_joiners_final = [
+chr(0xE2),	#	ARABIC LETTER AIN, final form
+chr(0xE6),	#	ARABIC LETTER GHAIN, final form
+chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
+]
+
+ft_bidi_joiners_isolated = [
+chr(0xE1),	#	ARABIC LETTER AIN, isolated form
+chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
+chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
+]
+
+ft_bidi_joiners_initial_medial = [
+chr(0x8B),	#	ARABIC TATWEEL
+chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
+chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
+chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
+chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
+chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
+chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
+chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
+]
+
+ft_bidi_joiners_final_isolated = [
+chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
+chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
+chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
+chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
+chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
+chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
+chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
+chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
+]
+
+ft_right_joiners_final = [
+chr(0x91)	#	ARABIC LETTER ALEF, final form
+]
+
+ft_right_joiners_isolated = [
+chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x90)	#	ARABIC LETTER ALEF, isolated form
+]
+
+ft_right_joiners_final_isolated = [
+chr(0xA2),	#	ARABIC LETTER DAL
+chr(0xA3),	#	ARABIC LETTER THAL
+chr(0xA4),	#	ARABIC LETTER REH
+chr(0xA5),	#	ARABIC LETTER ZAIN
+chr(0xA6),	#	ARABIC LETTER JEH
+chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
+chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF8)	#	ARABIC LETTER WAW
+]
+
+
+table_FT_UN = {
+chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
+chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
+chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
+chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
+chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
+chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
+chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
+chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
+chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
+chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
+chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
+chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
+chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
+chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
+chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
+chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
+chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
+chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
+chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
+chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
+chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
+chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
+chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
+chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
+chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
+chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
+chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
+chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
+chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
+chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
+chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
+chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
+chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
+chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
+chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
+chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
+chr(0xB5) : [u'\u0023'],	# * #
+chr(0xB6) : [u'\u0024'],	# * $
+chr(0xB7) : [u'\u0025'],	# * %
+chr(0xB8) : [u'\u0026'],	# * &
+chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
+chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
+chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
+chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
+chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
+chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
+chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
+chr(0xC5) : [u'\u002D'],	# * -
+chr(0xC6) : [u'\u002E'],	# * FULL STOP
+chr(0xC7) : [u'\u002F'],	# * /
+chr(0xC8) : [u'\u002A'],	# * *
+chr(0xC9) : [u'\u007E'],	# * ~
+chr(0xCA) : [u'\u003A'],	# * COLON
+chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
+chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
+chr(0xCD) : [u'\u002B'],	# * +
+chr(0xCE) : [u'\u003D'],	# * =
+chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
+# chr(0xD0) : [u'\u0040'],	# * @
+chr(0xD0) : [u''],	        # * @
+chr(0xD1) : [u'\u005D'],	# * [
+chr(0xD2) : [u'\u005C'],	# * \
+chr(0xD3) : [u'\u005B'],	# * ]
+chr(0xD4) : [u'\u005E'],	# * ^
+chr(0xD5) : [u'\u005F'],	# * _
+chr(0xD6) : [u'\u0060'],	# * `
+chr(0xD7) : [u'\u007D'],	# * {
+chr(0xD8) : [u'\u007C'],	# * |
+chr(0xDA) : [u'\u0020'],	# * SPACE
+chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
+chr(0xDE) : [u'\u007B'],	# * }
+chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
+chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
+chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
+chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
+chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
+chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
+chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
+chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
+chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
+chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
+chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
+chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
+chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
+chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
+chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
+chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
+chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
+chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
+}
+
+F_SLASH = chr(0xD2)
+F_PRNT_OPEN = chr(0xDE)
+F_PRNT_CLOSE = chr(0xD7)
+F_AT_SIGN = chr(0xD0)
+F_PERCENT_SIGN = chr(0xB7)
+
+# latex and farsitex commands whose first parameter does not need \lr{...}
+commands = [ "begin", 
+"end",
+"input", "include", "includeonly",
+"hspace", "vspace", "hspace*", "vspace*",
+"label", "ref", "cite", "bibitem",
+"bibliographystyle",
+"parbox",
+"newenvironment", "newtheorem",
+"persianmathdigitsfamily",
+"fontfamily", "fontseries", "fontshape",
+"rmdefault", "sfdefault", "ttdefault",
+"bfdefault", "itdefault", "sldefault", "scdefault",
+"pagenumbering", "pagestyle", "thispagestyle",
+"setcounter", "stepcounter", "setlength", "addtolength"
+]
+
+
+def ft_is_numeric(ch):
+	if ((ch in ft_numerical) or 
+	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
+		return 1
+	return 0
+
+def ft_can_join_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_final) or
+	    (ch in ft_bidi_joiners_isolated) or
+	    (ch in ft_bidi_joiners_initial_medial) or
+	    (ch in ft_bidi_joiners_final_isolated)):
+    		return 1
+	return 0
+
+def ft_can_join_right(ch):
+	if (ft_can_join_left(ch) or 
+	    (ch in ft_right_joiners_final) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_right_joiners_final_isolated)):
+		return 1
+	return 0
+
+def ft_joining_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or 
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_initial_medial)):
+		return 1
+	return 0
+
+
+def ft_joining_right(ch):
+	if ((ch in ft_right_joiners_final) or
+	    (ch in ft_bidi_joiners_medial) or 
+	    (ch in ft_bidi_joiners_final)):
+		return 1
+	return 0
+
+def ft_not_right_joined(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_bidi_joiners_isolated)):
+		return 1
+	return 0
+
+def ft_adjust_shaping(text, i):
+	current = text[i]
+	u = u''
+	try:
+		u = table_FT_UN[current][0]
+	except KeyError:
+		return u''
+
+	#if you don't want shaping remove the following comment
+	#return u
+
+	if ((current in ft_vowels) or (ft_is_numeric(current))):
+		return u
+
+	#find next non-vowel character on the left
+	text_len = len(text)
+	next_index = i+1
+	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
+		next_index += 1
+
+	if (next_index == text_len):
+		next = ''
+	else:
+		next = text[next_index]
+
+	# if current letter is joining from left but next letter is or can not joining
+	if (ft_joining_left(current)):
+		if (not ft_can_join_right(next)):
+			u += u'\u200D' #ZWJ
+		elif (ft_not_right_joined(next)):
+			u += u'\u200D\u200C' #ZWJ+ZWNJ
+	# if current letter can join but next letter is joining from right
+	elif (ft_can_join_left(current)):
+		if (ft_joining_right(next)):
+			u += u'\u200C\u200D' #ZWNJ+ZWJ
+		elif (ft_can_join_right(next)):
+			u += u'\u200C' #ZWNJ
+	return u
+
+def ft_adjust_number(text):
+	result = u''
+	i = len(text)-1
+	while (i >= 0):
+		result += ft_adjust_shaping(text, i)
+		i -= 1
+	return result
+
+
+def map_ft_unicode(text):
+	mapped_text = u''
+
+	i = 0
+	while (i < len(text)):
+		if (ft_is_numeric(text[i])):
+			next_index = i
+			while ((next_index+1 < len(text)) and
+			       (ft_is_numeric(text[next_index+1]))):
+				next_index += 1
+			mapped_text += ft_adjust_number(text[i:next_index+1])
+			i = next_index+1
+			continue
+
+		mapped_text += ft_adjust_shaping(text, i)
+		i += 1
+	return mapped_text
+
+# Finds next token all of the same language
+def ft_next_part(line, i, line_len):
+	global global_state
+	
+	j = i
+	language_flag = (line[j]<chr(0x80))
+	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
+		if ( (global_state == 0) and ( (line[j] == '%') or (line[j] == F_PERCENT_SIGN) ) ):
+			global_state = 1
+		elif ((global_state == 0) and ((line[j:j+16] == '\\begin{verbatim}') or (line[j:j+17] == '\\begin{verbatim*}'))):
+			global_state = 2
+		elif ((global_state == 2) and ((line[j:j+14] == '\\end{verbatim}') or (line[j:j+15] == '\\end{verbatim*}'))):
+			global_state = 0
+		elif ((global_state == 0) and (line[j:j+6] == '\\verb*')):
+			next_index = line.find(line[j+6], j+7)
+			j = next_index
+		elif ((global_state == 0) and (line[j:j+5] == '\\verb')):
+			next_index = line.find(line[j+5], j+6)
+			j = next_index
+		elif ((global_state == 0) and (line[j:j+9] == '\\include{')):
+			next_index = line.find('}', j+9)
+			filename = line[j+10:next_index-1] + '.ftx'
+			print filename
+			if (os.path.exists(filename) and not filename in filenames):
+				filenames.append(filename)
+		elif ((global_state == 0) and (line[j:j+7] == '\\input{')):
+			next_index = line.find('}', j+7)
+			filename = line[j+8:next_index-1] + '.ftx'
+			if (os.path.exists(filename) and not filename in filenames):
+				filenames.append(filename)
+		elif ((global_state == 0) and (line[j:j+9] == F_SLASH + 'include' + F_PRNT_OPEN)):
+			next_index = line.find(F_PRNT_CLOSE, j+9)
+			filename = line[j+10:next_index-1] + '.ftx'
+			if (os.path.exists(filename) and not filename in filenames):
+				filenames.append(filename)
+		elif ((global_state == 0) and (line[j:j+7] == F_SLASH + 'input' + F_PRNT_OPEN)):
+			next_index = line.find(F_PRNT_CLOSE, j+7)
+			filename = line[j+8:next_index-1] + '.ftx'
+			if (os.path.exists(filename) and not filename in filenames):
+				filenames.append(filename)
+		j += 1
+	return j
+
+###############################################
+# from here all functions are used to translate
+# farsitex commands to xepersian commands
+###############################################
+
+def read_size(input,index,last_index):
+	dim_index = -1 
+	inch_index = input.find(u'in', index)
+	if (inch_index != -1):
+		dim_index = inch_index
+	mm_index = input.find(u'mm', index)
+	if (mm_index != -1):
+		if (dim_index == -1 or mm_index < index):
+			dim_index = mm_index
+	cm_index = input.find(u'cm', index)
+	if (cm_index != -1):
+		if (dim_index == -1 or cm_index < dim_index):
+			dim_index = cm_index
+	pt_index = input.find(u'pt', index)
+	if (pt_index != -1):
+		if (dim_index == -1 or pt_index < dim_index):
+			dim_index = pt_index
+	next_cmd = input.find(u'\\', index)
+	if (next_cmd == -1 and dim_index == -1):
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+	elif (next_cmd == -1 or (dim_index != -1 and next_cmd > dim_index)):
+		epsfxsize = input[index:dim_index+2]
+		return dim_index+2
+	elif (next_cmd != -1):
+		end_cmd = next_cmd+1
+		while (end_cmd < last_index and input[end_cmd].isalpha()):
+			end_cmd += 1
+		return end_cmd
+	else:
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+
+
+latex_options=[u'a4paper', u'a5paper', u'b5paper', 
+			   u'letterpaper', u'legalpaper', u'executivepaper', 
+			   u'landscape', u'10pt', u'11pt', u'12pt', 
+			   u'oneside', u'twoside', u'draft', 
+			   u'final', u'titlepage', u'notitlepage',
+			   u'onecolumn', u'twocolumn',
+			   u'leqno', u'fleqn']
+
+table_eq_packages = {
+u'poem'     : u'persianpoem',
+u'fmakeidx' : u'makeidx',
+u'ffancyhe' : u'fancyhdr',
+u'fmultico' : u'multicol'
+}
+
+farsitex_ignore_options = [u'persian', u'farsi', u'epsf', u'fgraphix', u'lotusfont']
+
+xepersian_packages = u'\n\\usepackage{url}\n\\usepackage{fancyvrb}\n\\usepackage{setspace}\\doublespace\n\\usepackage{graphicx}\n\\usepackage{amssymb}\n'
+xepersian_preamble = u'\\settextfont[Scale=1.2]{XB Zar}\n\\setlatintextfont[Scale=1.1]{Times New Roman}\n\\setdigitfont{XB Zar}\n\\let\\iranic\\it\n\\let\\siah\\bf\n\\let\\khabide\\sl\n\\def\\siahir{\\siah\\iranic}\n\\def\\siahkh{\\siah\\khabide}\n\\setpookfont{XB Kayhan Pook}\\let\\tookhali\\pookfamily\n\\setsayehfont{XB Kayhan Sayeh}\\let\\sayedar\\sayehfamily\n\\let\\farsi\\Persian\n\\let\\english\\Latin\n\\let\\farmbox\\mbox\n\\newcommand{\\ftxepmatrix}[1]{\\begin{pmatrix}#1\\end{pmatrix}}\n\\def\\FarsiTeX{\\lr{FarsiTeX}}\n\\def\\????????{\\rl{?????????}}\n'
+
+def is_alpha_numeric_space(input):
+	input_len = len(input)
+	i = 0
+	while (i<input_len):
+		if (not (input[i].isalpha() or input[i].isdigit() or input[i]==u'.' or input[i]==u' ') ):
+			return 0
+		i+=1
+	return 1
+
+def is_alpha_numeric(input):
+	input_len = len(input)
+	i = 0
+	while (i<input_len):
+		if (not (input[i].isalpha() or input[i].isdigit() or input[i]=='.') ):
+			return 0
+		i+=1
+	return 1
+			
+def find_eq_cmd(keyword):
+	try:
+		eq_cmd = table_eq_packages[keyword]
+	except KeyError:
+		eq_cmd = u''
+	return eq_cmd
+
+def convert_persian_to_english(num):
+	result = u''
+	num_len = len(num)
+	index = 0
+	while (index < num_len):
+		if (ord(num[index]) >= ord(u'?') and ord(num[index]) <= ord(u'?')):
+			result += unichr(ord(num[index]) - ord(u'?') + ord(u'0'))
+		else:
+			result += num[index]
+		index += 1
+	return result
+
+# \verb|| -> \item[\verb||] or \section{\verb||}
+# \url{} -> does not show numbers
+# \kasre{} \alef{} ...
+def translate_cmds(output_line):
+	global last_epsfxsize
+	global last_epsfxsize_line
+	global last_epsfysize
+	global last_epsfysize_line
+	global state
+
+	result = u''
+	line_len = len(output_line)
+	index = 0
+	if (state == 1): #\begin{verbatim}
+		end_verbatim = output_line.find('\\end{verbatim}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+14]
+		index = end_verbatim+14
+		state = 0
+	elif (state == 2): #\begin{verbatim*}
+		end_verbatim = output_line.find('\\end{verbatim*}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+15]
+		index = end_verbatim+15
+		state = 0
+	elif (output_line[0:14] == "\\documentstyle"):
+		result += u'\\documentclass'
+		#process options
+		last_index = output_line.find(u']')
+		index = 15
+		first_option = 1
+		preamble = xepersian_preamble
+		packages = xepersian_packages
+		document_class = u''
+		while (index < last_index):
+			next_comma = output_line.find(u',',index,last_index)
+			if (next_comma == -1):
+				next_comma = last_index
+			first_of_option = index
+			while (output_line[first_of_option] == u' '):
+				first_of_option += 1
+			end_of_option = next_comma
+			while (output_line[end_of_option-1] == u' '):
+				end_of_option -= 1
+			option = output_line[first_of_option:end_of_option]
+			index = next_comma+1
+			eq_cmd = find_eq_cmd(option)
+			if (eq_cmd != u''):
+				packages += u'\\usepackage{' + eq_cmd + u'}\n'
+				continue
+			elif (option in farsitex_ignore_options):
+				continue
+			elif (option == u'sharifth'):
+				document_class = u'xepersian-thesis'
+				continue
+			elif (not option in latex_options):
+				packages += u'\\usepackage{' + option + u'}\n'
+				continue
+	
+			if (first_option):
+				result += u'['
+			else:
+				result += u','
+			result += option
+			first_option = 0
+		#end while
+		if (not first_option):
+			result += u']'
+		index = output_line.find(u'}',last_index)
+		if (document_class == u''):
+			result += output_line[last_index+1:index+1]
+		else:
+			result += u'{' + document_class + u'}'
+		# I assume that nothing important is after
+		# \documentstyle[]{}, otherwise it may conflict
+		# with our preamble
+		if (index != -1):
+			result += output_line[index+1:]
+		result += packages + u'\\usepackage{xepersian}\n'
+		result += preamble
+		return result
+	#end elif "documentstyle"
+
+	while (index < line_len):
+		next_index = output_line.find(u'\\', index)
+		comment_index = output_line.find(u'%', index)
+		if (next_index == -1):
+			result += output_line[index:]
+			break
+		elif (state == 1):
+			if (output_line[next_index:next_index+14] == u'\\end{verbatim}'):
+				result += output_line[index:next_index+14]
+				index = next_index+14
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (state == 2):
+			if (output_line[next_index:next_index+15] == u'\\end{verbatim*}'):
+				result += output_line[index:next_index+15]
+				index = next_index+15
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (comment_index != -1 and comment_index < next_index):
+			result += output_line[index:]
+			break
+		elif (output_line[next_index:next_index+14] == u"\\input{amssym}"):
+			result += u'\\usepackage{amssymb}'
+			index = next_index+14
+		elif (output_line[next_index:next_index+12] == u"\\input{epsf}"):
+			index = next_index+12
+		elif (output_line[next_index:next_index+15] == u"\\includeepspdf{"):
+			result += u'\\includegraphics{'
+			index = next_index+15
+		elif (output_line[next_index:next_index+16] == u"\\begin{verbatim}"):
+			result += output_line[index:next_index+16]
+			index = next_index+16
+			state = 1
+		elif (output_line[next_index:next_index+17] == u"\\begin{verbatim*}"):
+			result += output_line[index:next_index+17]
+			index = next_index+17
+			state = 2
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\headrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\headrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\footrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\footrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+10] == u"\\epsffile{"):
+			result += output_line[index:next_index]
+			result += u'\\includegraphics'
+			size_options = u''
+			if (line_number - last_epsfxsize_line <= 3):
+				size_options = u'width=' + last_epsfxsize
+			if (line_number - last_epsfysize_line <= 3):
+				if (size_options != u''):
+					size_options += u','
+				size_options += u'height=' + last_epsfysize
+			if (size_options != u''):
+				result += u'[' + size_options + u']'
+			end_prn = output_line.find(u'.eps}', next_index+9)
+
+			if (end_prn != -1):
+				result += output_line[next_index+9:end_prn] + u'}'
+				index = end_prn+5
+			else:
+				end_prn = output_line.find(u'.ps}', next_index+9)
+				if (end_prn != -1):
+					result += output_line[next_index+9:end_prn] + u'}'
+					index = end_prn+4
+				else:
+					end_prn = output_line.find(u'}', next_index+9)
+					result += output_line[next_index+9:end_prn+1]
+					index = end_prn+1
+		# I assume all the parameter of \epsfxsize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfxsize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfxsize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfxsize_line = line_number
+		# I assume all the parameter of \epsfysize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfysize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfysize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfysize_line = line_number
+		elif (output_line[next_index:next_index+10] == u"\\LR{\\verb*"):
+			end_verb = output_line.find(output_line[next_index+10], next_index+11)
+			verb_param = output_line[next_index+11:end_verb]
+			if (is_alpha_numeric(verb_param)):
+				result += output_line[index:next_index]
+				result += u'\\lr{\\tt{}' + verb_param
+			else:
+				result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+9] == u"\\LR{\\verb"):
+			end_verb = output_line.find(output_line[next_index+9], next_index+10)
+			verb_param = output_line[next_index+10:end_verb]
+			if (is_alpha_numeric_space(verb_param)):
+				result += output_line[index:next_index]
+				result += u'\\lr{\\tt{}' + verb_param
+			else:
+				result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+6] == u"\\verb*"):
+			end_verb = output_line.find(output_line[next_index+6], next_index+7)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+5] == u"\\verb"):
+			end_verb = output_line.find(output_line[next_index+5], next_index+6)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+9] == u"\\pmatrix{"):
+			result += u'\\ftxepmatrix{'
+			index = next_index+9
+		elif (output_line[next_index:next_index+16] == u"\\begin{document}"):
+			result += u'\\begin{document}\n\\VerbatimFootnotes'
+			index = next_index+16
+		elif (output_line[next_index:next_index+12] == u'\\setcounter{'):
+			begin_num = output_line.find(u'{', next_index+12)
+			end_num = output_line.find(u'}', begin_num)
+			num = convert_persian_to_english(output_line[begin_num+1:end_num])
+			result += output_line[index:begin_num+1]
+			result += num + u'}'
+			index = end_num+1
+		elif (output_line[next_index:next_index+14] == u'\\addtocounter{'):
+			begin_num = output_line.find(u'{', next_index+14)
+			end_num = output_line.find(u'}', begin_num)
+			num = convert_persian_to_english(output_line[begin_num+1:end_num])
+			print 'HI:'
+			print num
+			result += output_line[index:begin_num+1]
+			result += num + u'}'
+			index = end_num+1
+		elif (output_line[next_index:next_index+13] == u'\\multicolumn{'):
+			begin_num = next_index+13
+			end_num = output_line.find(u'}', begin_num)
+			num = convert_persian_to_english(output_line[begin_num:end_num])
+			result += output_line[index:begin_num]
+			result += num + u'}'
+			index = end_num+1
+		else:
+			result += output_line[index:next_index+2]
+			index = next_index+2
+	#end while
+	return result
+
+###############################################
+# from here all functions are mainly used to
+# convert farsitex format to unicode
+###############################################
+
+def convert_file(f, of, convert_cmds):
+	global state
+	global line_number
+	global last_epsfysize_line
+	global last_epsfxsize_line
+	global last_epsfxsize
+	global last_epsfysize
+	global global_state
+
+	state = 0
+	line_number = 0
+	last_epsfysize_line = 0
+	last_epsfxsize_line = 0
+	last_epsfxsize = u''
+	last_epsfysize = u''
+
+	for line in f:
+		line_number += 1
+		print line_number,
+		output_line = u''
+		line_len = len(line)
+		
+		# remove new-line characters from end of line
+		if (line_len>1 and line[line_len-1] == '\n'):
+			line_len-=1
+		if (line_len>1 and line[line_len-1] == '\r'):
+			line_len-=1
+		
+		# check line-direction character
+		line_direction_rtl = (line[0] == '<')
+		if (line[0] != '>') and (line[0] != '<'):
+			print "FORMAT ERROR AT LINE: " + str(line_number)
+			exit(0)
+	
+		i = 1
+	
+		while (i<line_len):
+			next_part_index = ft_next_part(line, i, line_len)
+			next_part = line[i:next_part_index]
+			next_part_latin = (line[i]<chr(0x80))
+			
+			# see if we should put \lr{...} for the current english expression
+			if (global_state == 0):
+				if line_direction_rtl and next_part_latin:
+					is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
+					is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
+					is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
+					is_verb_parameter = ( (line[i-6:i] == F_SLASH+"verb") and not isalpha(line[i]))
+					is_verb = (next_part_latin and (line[i:i+5]=='\\verb' or line[i:i+6]==' \\verb'))
+					is_english = (next_part_latin and (line[i:i+8]=='\\english'))
+				
+					cmd_index = 0
+					while cmd_index < len(commands):
+						len_cmd = len(commands[cmd_index])+2
+						if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
+							break
+						cmd_index += 1
+					is_commands_group = cmd_index < len(commands)
+					is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
+	
+			if next_part_latin:
+				if (global_state == 0):
+					# whether we should put a \lr{ command
+					if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb or is_english) ):
+						output_line += u'\\lr{'
+					if ( line_direction_rtl and is_verb):
+						output_line += u'\\LR{'
+				
+				# here is the main place that converting happens
+				output_line += next_part.encode( 'utf-8' )
+				
+				if (global_state == 0):
+					# check whether we already used a \lr command: then end it
+					if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb or is_english) ):
+						output_line += u'}'
+					if ( line_direction_rtl and is_verb):
+						output_line += u'}'
+			else:
+				if (global_state == 0):
+					# whether we should put a \rl{} command
+					if ( not line_direction_rtl):
+						output_line += u'\\rl{'
+					
+				# here is the main place that converting happens
+				output_line += map_ft_unicode(next_part)
+				
+				if (global_state == 0):
+					# check whether we already used a \rl command: then end it
+					if (not line_direction_rtl):
+						output_line += u'}'
+					
+			i = next_part_index
+		# end of while			
+
+		#if there was a % commenting then we can return to normal situation
+		if (global_state == 1):
+			global_state = 0
+		
+		# convert some of the FarsiTeX commands to XePersian commands
+		# only if it is requested
+		if (convert_cmds):
+			result = translate_cmds(output_line) 
+		else:
+			result = output_line
+		output_line = result + u'\n'
+		# write the processed line
+		of.write(output_line)
+		# end of line processing
+	# end of file processing
+
+###################################
+# Begin of main body of the program
+###################################
+
+# global variables
+line_number = 0
+last_epsfxsize = u''
+last_epsfxsize_line = 0
+last_epsfysize = u''
+last_epsfysize_line = 0
+state = 0
+global_state = 0
+
+if len(sys.argv) <= 1:
+	print 'usage: python ftxe-0.6 in_filename'
+	exit(0)
+
+index = 0
+filenames = [sys.argv[1]]
+
+while (index < len(filenames)):
+	filename = filenames[index]
+	index += 1
+
+	outfile = ''
+	if (filename[-4:] != '.tex'):
+		outfile = filename[0:-3] + 'tex'
+	else: 
+		outfile = filename + '.tex'
+
+	print '\n\nConverting "' + filename + '" into "' + outfile + '"'
+	try:
+		f = open(filename, 'r')
+	except IOError:
+		print "Can not open the input file: " + filename
+		exit(0)
+
+	try:
+		of = codecs.open(outfile, encoding='utf-8', mode='w')
+	except IOError:
+		print "Can not open the output file: " + outfile
+		exit(0)
+
+	convert_file(f, of, 1)
+		
+	of.close()
+	f.close()	



From vafa at mail.berlios.de  Sat Jun 27 03:36:54 2009
From: vafa at mail.berlios.de (vafa at mail.berlios.de)
Date: Sat, 27 Jun 2009 03:36:54 +0200
Subject: [Xepersian-development] r77 - trunk
Message-ID: <200906270136.n5R1aswj004011@sheep.berlios.de>

Author: vafa
Date: 2009-06-27 03:36:36 +0200 (Sat, 27 Jun 2009)
New Revision: 77

Added:
   trunk/ftxe-0.8.py
Removed:
   trunk/ftxe-0.6.py
Log:
new version of farsitex-unicode converter per Mostafa

Deleted: trunk/ftxe-0.6.py
===================================================================
--- trunk/ftxe-0.6.py	2009-06-24 04:37:11 UTC (rev 76)
+++ trunk/ftxe-0.6.py	2009-06-27 01:36:36 UTC (rev 77)
@@ -1,933 +0,0 @@
-?#########################################
-#       General Public License          #
-#       Author:  Mostafa Vahedi         #
-#       Date:    21 June 2009           #
-#       Version  0.6                    #
-#########################################
-
-import codecs
-
-import sys
-import os
-
-ft_numerical = [
-chr(0xB9),	# 	Arabic Thoushads Seperator
-chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
-]
-
-
-ft_vowels = [
-chr(0xB0),	#	ARABIC FATHA
-chr(0xB1),	#	ARABIC KASRA
-chr(0xB2),	#	ARABIC DAMMA
-chr(0xB3),	#	ARABIC FATHATAN
-chr(0xB4),	#	ARABIC SHADDA
-chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB),	#	ARABIC HAMZA ABOVE
-chr(0xC4) 	#	ARABIC SUKUN
-]
-
-ft_non_joiners = [
-chr(0x8F)	#	ARABIC LETTER HAMZA
-]
-
-ft_bidi_joiners_initial = [
-chr(0xE4),	#	ARABIC LETTER AIN, initial form
-chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
-chr(0xFB) 	#	ARABIC LETTER HEH, initial form
-]
-
-ft_bidi_joiners_medial = [
-chr(0xE3),	#	ARABIC LETTER AIN, medial form
-chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
-chr(0xFA) 	#	ARABIC LETTER HEH, medial form
-]
-
-ft_bidi_joiners_final = [
-chr(0xE2),	#	ARABIC LETTER AIN, final form
-chr(0xE6),	#	ARABIC LETTER GHAIN, final form
-chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
-]
-
-ft_bidi_joiners_isolated = [
-chr(0xE1),	#	ARABIC LETTER AIN, isolated form
-chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
-chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
-]
-
-ft_bidi_joiners_initial_medial = [
-chr(0x8B),	#	ARABIC TATWEEL
-chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
-chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
-chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
-chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
-chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
-chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
-chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
-]
-
-ft_bidi_joiners_final_isolated = [
-chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
-chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
-chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
-chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
-chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
-chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
-chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
-chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
-]
-
-ft_right_joiners_final = [
-chr(0x91)	#	ARABIC LETTER ALEF, final form
-]
-
-ft_right_joiners_isolated = [
-chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x90)	#	ARABIC LETTER ALEF, isolated form
-]
-
-ft_right_joiners_final_isolated = [
-chr(0xA2),	#	ARABIC LETTER DAL
-chr(0xA3),	#	ARABIC LETTER THAL
-chr(0xA4),	#	ARABIC LETTER REH
-chr(0xA5),	#	ARABIC LETTER ZAIN
-chr(0xA6),	#	ARABIC LETTER JEH
-chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
-chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF8)	#	ARABIC LETTER WAW
-]
-
-
-table_FT_UN = {
-chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
-chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
-chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
-chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
-chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
-chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
-chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
-chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
-chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
-chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
-chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
-chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
-chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
-chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
-chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
-chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
-chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
-chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
-chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
-chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
-chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
-chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
-chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
-chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
-chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
-chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
-chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
-chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
-chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
-chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
-chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
-chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
-chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
-chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
-chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
-chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
-chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
-chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
-chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
-chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
-chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
-chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
-chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
-chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
-chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
-chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
-chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
-chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
-chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
-chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
-chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
-chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
-chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
-chr(0xB5) : [u'\u0023'],	# * #
-chr(0xB6) : [u'\u0024'],	# * $
-chr(0xB7) : [u'\u0025'],	# * %
-chr(0xB8) : [u'\u0026'],	# * &
-chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
-chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
-chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
-chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
-chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
-chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
-chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
-chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
-chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
-chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
-chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
-chr(0xC5) : [u'\u002D'],	# * -
-chr(0xC6) : [u'\u002E'],	# * FULL STOP
-chr(0xC7) : [u'\u002F'],	# * /
-chr(0xC8) : [u'\u002A'],	# * *
-chr(0xC9) : [u'\u007E'],	# * ~
-chr(0xCA) : [u'\u003A'],	# * COLON
-chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
-chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
-chr(0xCD) : [u'\u002B'],	# * +
-chr(0xCE) : [u'\u003D'],	# * =
-chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
-# chr(0xD0) : [u'\u0040'],	# * @
-chr(0xD0) : [u''],	        # * @
-chr(0xD1) : [u'\u005D'],	# * [
-chr(0xD2) : [u'\u005C'],	# * \
-chr(0xD3) : [u'\u005B'],	# * ]
-chr(0xD4) : [u'\u005E'],	# * ^
-chr(0xD5) : [u'\u005F'],	# * _
-chr(0xD6) : [u'\u0060'],	# * `
-chr(0xD7) : [u'\u007D'],	# * {
-chr(0xD8) : [u'\u007C'],	# * |
-chr(0xDA) : [u'\u0020'],	# * SPACE
-chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
-chr(0xDE) : [u'\u007B'],	# * }
-chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
-chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
-chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
-chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
-chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
-chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
-chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
-chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
-chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
-chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
-chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
-chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
-chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
-chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
-chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
-chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
-chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
-chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
-chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
-chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
-chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
-chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
-chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
-chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
-chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
-chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
-chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
-chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
-chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
-chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
-chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
-}
-
-F_SLASH = chr(0xD2)
-F_PRNT_OPEN = chr(0xDE)
-F_PRNT_CLOSE = chr(0xD7)
-F_AT_SIGN = chr(0xD0)
-F_PERCENT_SIGN = chr(0xB7)
-
-# latex and farsitex commands whose first parameter does not need \lr{...}
-commands = [ "begin", 
-"end",
-"input", "include", "includeonly",
-"hspace", "vspace", "hspace*", "vspace*",
-"label", "ref", "cite", "bibitem",
-"bibliographystyle",
-"parbox",
-"newenvironment", "newtheorem",
-"persianmathdigitsfamily",
-"fontfamily", "fontseries", "fontshape",
-"rmdefault", "sfdefault", "ttdefault",
-"bfdefault", "itdefault", "sldefault", "scdefault",
-"pagenumbering", "pagestyle", "thispagestyle",
-"setcounter", "stepcounter", "setlength", "addtolength"
-]
-
-
-def ft_is_numeric(ch):
-	if ((ch in ft_numerical) or 
-	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
-		return 1
-	return 0
-
-def ft_can_join_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_final) or
-	    (ch in ft_bidi_joiners_isolated) or
-	    (ch in ft_bidi_joiners_initial_medial) or
-	    (ch in ft_bidi_joiners_final_isolated)):
-    		return 1
-	return 0
-
-def ft_can_join_right(ch):
-	if (ft_can_join_left(ch) or 
-	    (ch in ft_right_joiners_final) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_right_joiners_final_isolated)):
-		return 1
-	return 0
-
-def ft_joining_left(ch):
-	if ((ch in ft_bidi_joiners_initial) or 
-	    (ch in ft_bidi_joiners_medial) or
-	    (ch in ft_bidi_joiners_initial_medial)):
-		return 1
-	return 0
-
-
-def ft_joining_right(ch):
-	if ((ch in ft_right_joiners_final) or
-	    (ch in ft_bidi_joiners_medial) or 
-	    (ch in ft_bidi_joiners_final)):
-		return 1
-	return 0
-
-def ft_not_right_joined(ch):
-	if ((ch in ft_bidi_joiners_initial) or
-	    (ch in ft_right_joiners_isolated) or
-	    (ch in ft_bidi_joiners_isolated)):
-		return 1
-	return 0
-
-def ft_adjust_shaping(text, i):
-	current = text[i]
-	u = u''
-	try:
-		u = table_FT_UN[current][0]
-	except KeyError:
-		return u''
-
-	#if you don't want shaping remove the following comment
-	#return u
-
-	if ((current in ft_vowels) or (ft_is_numeric(current))):
-		return u
-
-	#find next non-vowel character on the left
-	text_len = len(text)
-	next_index = i+1
-	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
-		next_index += 1
-
-	if (next_index == text_len):
-		next = ''
-	else:
-		next = text[next_index]
-
-	# if current letter is joining from left but next letter is or can not joining
-	if (ft_joining_left(current)):
-		if (not ft_can_join_right(next)):
-			u += u'\u200D' #ZWJ
-		elif (ft_not_right_joined(next)):
-			u += u'\u200D\u200C' #ZWJ+ZWNJ
-	# if current letter can join but next letter is joining from right
-	elif (ft_can_join_left(current)):
-		if (ft_joining_right(next)):
-			u += u'\u200C\u200D' #ZWNJ+ZWJ
-		elif (ft_can_join_right(next)):
-			u += u'\u200C' #ZWNJ
-	return u
-
-def ft_adjust_number(text):
-	result = u''
-	i = len(text)-1
-	while (i >= 0):
-		result += ft_adjust_shaping(text, i)
-		i -= 1
-	return result
-
-
-def map_ft_unicode(text):
-	mapped_text = u''
-
-	i = 0
-	while (i < len(text)):
-		if (ft_is_numeric(text[i])):
-			next_index = i
-			while ((next_index+1 < len(text)) and
-			       (ft_is_numeric(text[next_index+1]))):
-				next_index += 1
-			mapped_text += ft_adjust_number(text[i:next_index+1])
-			i = next_index+1
-			continue
-
-		mapped_text += ft_adjust_shaping(text, i)
-		i += 1
-	return mapped_text
-
-# Finds next token all of the same language
-def ft_next_part(line, i, line_len):
-	global global_state
-	
-	j = i
-	language_flag = (line[j]<chr(0x80))
-	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
-		if ( (global_state == 0) and ( (line[j] == '%') or (line[j] == F_PERCENT_SIGN) ) ):
-			global_state = 1
-		elif ((global_state == 0) and ((line[j:j+16] == '\\begin{verbatim}') or (line[j:j+17] == '\\begin{verbatim*}'))):
-			global_state = 2
-		elif ((global_state == 2) and ((line[j:j+14] == '\\end{verbatim}') or (line[j:j+15] == '\\end{verbatim*}'))):
-			global_state = 0
-		elif ((global_state == 0) and (line[j:j+6] == '\\verb*')):
-			next_index = line.find(line[j+6], j+7)
-			j = next_index
-		elif ((global_state == 0) and (line[j:j+5] == '\\verb')):
-			next_index = line.find(line[j+5], j+6)
-			j = next_index
-		elif ((global_state == 0) and (line[j:j+9] == '\\include{')):
-			next_index = line.find('}', j+9)
-			filename = line[j+10:next_index-1] + '.ftx'
-			print filename
-			if (os.path.exists(filename) and not filename in filenames):
-				filenames.append(filename)
-		elif ((global_state == 0) and (line[j:j+7] == '\\input{')):
-			next_index = line.find('}', j+7)
-			filename = line[j+8:next_index-1] + '.ftx'
-			if (os.path.exists(filename) and not filename in filenames):
-				filenames.append(filename)
-		elif ((global_state == 0) and (line[j:j+9] == F_SLASH + 'include' + F_PRNT_OPEN)):
-			next_index = line.find(F_PRNT_CLOSE, j+9)
-			filename = line[j+10:next_index-1] + '.ftx'
-			if (os.path.exists(filename) and not filename in filenames):
-				filenames.append(filename)
-		elif ((global_state == 0) and (line[j:j+7] == F_SLASH + 'input' + F_PRNT_OPEN)):
-			next_index = line.find(F_PRNT_CLOSE, j+7)
-			filename = line[j+8:next_index-1] + '.ftx'
-			if (os.path.exists(filename) and not filename in filenames):
-				filenames.append(filename)
-		j += 1
-	return j
-
-###############################################
-# from here all functions are used to translate
-# farsitex commands to xepersian commands
-###############################################
-
-def read_size(input,index,last_index):
-	dim_index = -1 
-	inch_index = input.find(u'in', index)
-	if (inch_index != -1):
-		dim_index = inch_index
-	mm_index = input.find(u'mm', index)
-	if (mm_index != -1):
-		if (dim_index == -1 or mm_index < index):
-			dim_index = mm_index
-	cm_index = input.find(u'cm', index)
-	if (cm_index != -1):
-		if (dim_index == -1 or cm_index < dim_index):
-			dim_index = cm_index
-	pt_index = input.find(u'pt', index)
-	if (pt_index != -1):
-		if (dim_index == -1 or pt_index < dim_index):
-			dim_index = pt_index
-	next_cmd = input.find(u'\\', index)
-	if (next_cmd == -1 and dim_index == -1):
-		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
-		return -1
-	elif (next_cmd == -1 or (dim_index != -1 and next_cmd > dim_index)):
-		epsfxsize = input[index:dim_index+2]
-		return dim_index+2
-	elif (next_cmd != -1):
-		end_cmd = next_cmd+1
-		while (end_cmd < last_index and input[end_cmd].isalpha()):
-			end_cmd += 1
-		return end_cmd
-	else:
-		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
-		return -1
-
-
-latex_options=[u'a4paper', u'a5paper', u'b5paper', 
-			   u'letterpaper', u'legalpaper', u'executivepaper', 
-			   u'landscape', u'10pt', u'11pt', u'12pt', 
-			   u'oneside', u'twoside', u'draft', 
-			   u'final', u'titlepage', u'notitlepage',
-			   u'onecolumn', u'twocolumn',
-			   u'leqno', u'fleqn']
-
-table_eq_packages = {
-u'poem'     : u'persianpoem',
-u'fmakeidx' : u'makeidx',
-u'ffancyhe' : u'fancyhdr',
-u'fmultico' : u'multicol'
-}
-
-farsitex_ignore_options = [u'persian', u'farsi', u'epsf', u'fgraphix', u'lotusfont']
-
-xepersian_packages = u'\n\\usepackage{url}\n\\usepackage{fancyvrb}\n\\usepackage{setspace}\\doublespace\n\\usepackage{graphicx}\n\\usepackage{amssymb}\n'
-xepersian_preamble = u'\\settextfont[Scale=1.2]{XB Zar}\n\\setlatintextfont[Scale=1.1]{Times New Roman}\n\\setdigitfont{XB Zar}\n\\let\\iranic\\it\n\\let\\siah\\bf\n\\let\\khabide\\sl\n\\def\\siahir{\\siah\\iranic}\n\\def\\siahkh{\\siah\\khabide}\n\\setpookfont{XB Kayhan Pook}\\let\\tookhali\\pookfamily\n\\setsayehfont{XB Kayhan Sayeh}\\let\\sayedar\\sayehfamily\n\\let\\farsi\\Persian\n\\let\\english\\Latin\n\\let\\farmbox\\mbox\n\\newcommand{\\ftxepmatrix}[1]{\\begin{pmatrix}#1\\end{pmatrix}}\n\\def\\FarsiTeX{\\lr{FarsiTeX}}\n\\def\\????????{\\rl{?????????}}\n'
-
-def is_alpha_numeric_space(input):
-	input_len = len(input)
-	i = 0
-	while (i<input_len):
-		if (not (input[i].isalpha() or input[i].isdigit() or input[i]==u'.' or input[i]==u' ') ):
-			return 0
-		i+=1
-	return 1
-
-def is_alpha_numeric(input):
-	input_len = len(input)
-	i = 0
-	while (i<input_len):
-		if (not (input[i].isalpha() or input[i].isdigit() or input[i]=='.') ):
-			return 0
-		i+=1
-	return 1
-			
-def find_eq_cmd(keyword):
-	try:
-		eq_cmd = table_eq_packages[keyword]
-	except KeyError:
-		eq_cmd = u''
-	return eq_cmd
-
-def convert_persian_to_english(num):
-	result = u''
-	num_len = len(num)
-	index = 0
-	while (index < num_len):
-		if (ord(num[index]) >= ord(u'?') and ord(num[index]) <= ord(u'?')):
-			result += unichr(ord(num[index]) - ord(u'?') + ord(u'0'))
-		else:
-			result += num[index]
-		index += 1
-	return result
-
-# \verb|| -> \item[\verb||] or \section{\verb||}
-# \url{} -> does not show numbers
-# \kasre{} \alef{} ...
-def translate_cmds(output_line):
-	global last_epsfxsize
-	global last_epsfxsize_line
-	global last_epsfysize
-	global last_epsfysize_line
-	global state
-
-	result = u''
-	line_len = len(output_line)
-	index = 0
-	if (state == 1): #\begin{verbatim}
-		end_verbatim = output_line.find('\\end{verbatim}')
-		if (end_verbatim == -1):
-			return output_line
-		result += output_line[0:end_verbatim+14]
-		index = end_verbatim+14
-		state = 0
-	elif (state == 2): #\begin{verbatim*}
-		end_verbatim = output_line.find('\\end{verbatim*}')
-		if (end_verbatim == -1):
-			return output_line
-		result += output_line[0:end_verbatim+15]
-		index = end_verbatim+15
-		state = 0
-	elif (output_line[0:14] == "\\documentstyle"):
-		result += u'\\documentclass'
-		#process options
-		last_index = output_line.find(u']')
-		index = 15
-		first_option = 1
-		preamble = xepersian_preamble
-		packages = xepersian_packages
-		document_class = u''
-		while (index < last_index):
-			next_comma = output_line.find(u',',index,last_index)
-			if (next_comma == -1):
-				next_comma = last_index
-			first_of_option = index
-			while (output_line[first_of_option] == u' '):
-				first_of_option += 1
-			end_of_option = next_comma
-			while (output_line[end_of_option-1] == u' '):
-				end_of_option -= 1
-			option = output_line[first_of_option:end_of_option]
-			index = next_comma+1
-			eq_cmd = find_eq_cmd(option)
-			if (eq_cmd != u''):
-				packages += u'\\usepackage{' + eq_cmd + u'}\n'
-				continue
-			elif (option in farsitex_ignore_options):
-				continue
-			elif (option == u'sharifth'):
-				document_class = u'xepersian-thesis'
-				continue
-			elif (not option in latex_options):
-				packages += u'\\usepackage{' + option + u'}\n'
-				continue
-	
-			if (first_option):
-				result += u'['
-			else:
-				result += u','
-			result += option
-			first_option = 0
-		#end while
-		if (not first_option):
-			result += u']'
-		index = output_line.find(u'}',last_index)
-		if (document_class == u''):
-			result += output_line[last_index+1:index+1]
-		else:
-			result += u'{' + document_class + u'}'
-		# I assume that nothing important is after
-		# \documentstyle[]{}, otherwise it may conflict
-		# with our preamble
-		if (index != -1):
-			result += output_line[index+1:]
-		result += packages + u'\\usepackage{xepersian}\n'
-		result += preamble
-		return result
-	#end elif "documentstyle"
-
-	while (index < line_len):
-		next_index = output_line.find(u'\\', index)
-		comment_index = output_line.find(u'%', index)
-		if (next_index == -1):
-			result += output_line[index:]
-			break
-		elif (state == 1):
-			if (output_line[next_index:next_index+14] == u'\\end{verbatim}'):
-				result += output_line[index:next_index+14]
-				index = next_index+14
-				state = 0
-			else:
-				result += output_line[index:next_index+1]
-				index = next_index+1
-		elif (state == 2):
-			if (output_line[next_index:next_index+15] == u'\\end{verbatim*}'):
-				result += output_line[index:next_index+15]
-				index = next_index+15
-				state = 0
-			else:
-				result += output_line[index:next_index+1]
-				index = next_index+1
-		elif (comment_index != -1 and comment_index < next_index):
-			result += output_line[index:]
-			break
-		elif (output_line[next_index:next_index+14] == u"\\input{amssym}"):
-			result += u'\\usepackage{amssymb}'
-			index = next_index+14
-		elif (output_line[next_index:next_index+12] == u"\\input{epsf}"):
-			index = next_index+12
-		elif (output_line[next_index:next_index+15] == u"\\includeepspdf{"):
-			result += u'\\includegraphics{'
-			index = next_index+15
-		elif (output_line[next_index:next_index+16] == u"\\begin{verbatim}"):
-			result += output_line[index:next_index+16]
-			index = next_index+16
-			state = 1
-		elif (output_line[next_index:next_index+17] == u"\\begin{verbatim*}"):
-			result += output_line[index:next_index+17]
-			index = next_index+17
-			state = 2
-		elif (output_line[next_index:next_index+26] == u'\\setlength{\\headrulewidth}'):
-			end_cmd = output_line.find('}', next_index+26)
-			result += u'\\renewcommand{\\headrulewidth}' + output_line[next_index+26:end_cmd+1]
-			index = end_cmd+1
-		elif (output_line[next_index:next_index+26] == u'\\setlength{\\footrulewidth}'):
-			end_cmd = output_line.find('}', next_index+26)
-			result += u'\\renewcommand{\\footrulewidth}' + output_line[next_index+26:end_cmd+1]
-			index = end_cmd+1
-		elif (output_line[next_index:next_index+10] == u"\\epsffile{"):
-			result += output_line[index:next_index]
-			result += u'\\includegraphics'
-			size_options = u''
-			if (line_number - last_epsfxsize_line <= 3):
-				size_options = u'width=' + last_epsfxsize
-			if (line_number - last_epsfysize_line <= 3):
-				if (size_options != u''):
-					size_options += u','
-				size_options += u'height=' + last_epsfysize
-			if (size_options != u''):
-				result += u'[' + size_options + u']'
-			end_prn = output_line.find(u'.eps}', next_index+9)
-
-			if (end_prn != -1):
-				result += output_line[next_index+9:end_prn] + u'}'
-				index = end_prn+5
-			else:
-				end_prn = output_line.find(u'.ps}', next_index+9)
-				if (end_prn != -1):
-					result += output_line[next_index+9:end_prn] + u'}'
-					index = end_prn+4
-				else:
-					end_prn = output_line.find(u'}', next_index+9)
-					result += output_line[next_index+9:end_prn+1]
-					index = end_prn+1
-		# I assume all the parameter of \epsfxsize comes in one line
-		elif (output_line[next_index:next_index+11] == u"\\epsfxsize="):
-			end_size = read_size(output_line, next_index+11, line_len)
-			if (end_size != -1):
-				last_epsfxsize = output_line[next_index+11:end_size]
-				index = end_size
-			else:
-				index = next_index+11
-			last_epsfxsize_line = line_number
-		# I assume all the parameter of \epsfysize comes in one line
-		elif (output_line[next_index:next_index+11] == u"\\epsfysize="):
-			end_size = read_size(output_line, next_index+11, line_len)
-			if (end_size != -1):
-				last_epsfysize = output_line[next_index+11:end_size]
-				index = end_size
-			else:
-				index = next_index+11
-			last_epsfysize_line = line_number
-		elif (output_line[next_index:next_index+10] == u"\\LR{\\verb*"):
-			end_verb = output_line.find(output_line[next_index+10], next_index+11)
-			verb_param = output_line[next_index+11:end_verb]
-			if (is_alpha_numeric(verb_param)):
-				result += output_line[index:next_index]
-				result += u'\\lr{\\tt{}' + verb_param
-			else:
-				result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+9] == u"\\LR{\\verb"):
-			end_verb = output_line.find(output_line[next_index+9], next_index+10)
-			verb_param = output_line[next_index+10:end_verb]
-			if (is_alpha_numeric_space(verb_param)):
-				result += output_line[index:next_index]
-				result += u'\\lr{\\tt{}' + verb_param
-			else:
-				result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+6] == u"\\verb*"):
-			end_verb = output_line.find(output_line[next_index+6], next_index+7)
-			result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+5] == u"\\verb"):
-			end_verb = output_line.find(output_line[next_index+5], next_index+6)
-			result += output_line[index:end_verb+1]
-			index = end_verb+1
-		elif (output_line[next_index:next_index+9] == u"\\pmatrix{"):
-			result += u'\\ftxepmatrix{'
-			index = next_index+9
-		elif (output_line[next_index:next_index+16] == u"\\begin{document}"):
-			result += u'\\begin{document}\n\\VerbatimFootnotes'
-			index = next_index+16
-		elif (output_line[next_index:next_index+12] == u'\\setcounter{'):
-			begin_num = output_line.find(u'{', next_index+12)
-			end_num = output_line.find(u'}', begin_num)
-			num = convert_persian_to_english(output_line[begin_num+1:end_num])
-			result += output_line[index:begin_num+1]
-			result += num + u'}'
-			index = end_num+1
-		elif (output_line[next_index:next_index+14] == u'\\addtocounter{'):
-			begin_num = output_line.find(u'{', next_index+14)
-			end_num = output_line.find(u'}', begin_num)
-			num = convert_persian_to_english(output_line[begin_num+1:end_num])
-			print 'HI:'
-			print num
-			result += output_line[index:begin_num+1]
-			result += num + u'}'
-			index = end_num+1
-		elif (output_line[next_index:next_index+13] == u'\\multicolumn{'):
-			begin_num = next_index+13
-			end_num = output_line.find(u'}', begin_num)
-			num = convert_persian_to_english(output_line[begin_num:end_num])
-			result += output_line[index:begin_num]
-			result += num + u'}'
-			index = end_num+1
-		else:
-			result += output_line[index:next_index+2]
-			index = next_index+2
-	#end while
-	return result
-
-###############################################
-# from here all functions are mainly used to
-# convert farsitex format to unicode
-###############################################
-
-def convert_file(f, of, convert_cmds):
-	global state
-	global line_number
-	global last_epsfysize_line
-	global last_epsfxsize_line
-	global last_epsfxsize
-	global last_epsfysize
-	global global_state
-
-	state = 0
-	line_number = 0
-	last_epsfysize_line = 0
-	last_epsfxsize_line = 0
-	last_epsfxsize = u''
-	last_epsfysize = u''
-
-	for line in f:
-		line_number += 1
-		print line_number,
-		output_line = u''
-		line_len = len(line)
-		
-		# remove new-line characters from end of line
-		if (line_len>1 and line[line_len-1] == '\n'):
-			line_len-=1
-		if (line_len>1 and line[line_len-1] == '\r'):
-			line_len-=1
-		
-		# check line-direction character
-		line_direction_rtl = (line[0] == '<')
-		if (line[0] != '>') and (line[0] != '<'):
-			print "FORMAT ERROR AT LINE: " + str(line_number)
-			exit(0)
-	
-		i = 1
-	
-		while (i<line_len):
-			next_part_index = ft_next_part(line, i, line_len)
-			next_part = line[i:next_part_index]
-			next_part_latin = (line[i]<chr(0x80))
-			
-			# see if we should put \lr{...} for the current english expression
-			if (global_state == 0):
-				if line_direction_rtl and next_part_latin:
-					is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
-					is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
-					is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
-					is_verb_parameter = ( (line[i-6:i] == F_SLASH+"verb") and not isalpha(line[i]))
-					is_verb = (next_part_latin and (line[i:i+5]=='\\verb' or line[i:i+6]==' \\verb'))
-					is_english = (next_part_latin and (line[i:i+8]=='\\english'))
-				
-					cmd_index = 0
-					while cmd_index < len(commands):
-						len_cmd = len(commands[cmd_index])+2
-						if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
-							break
-						cmd_index += 1
-					is_commands_group = cmd_index < len(commands)
-					is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
-	
-			if next_part_latin:
-				if (global_state == 0):
-					# whether we should put a \lr{ command
-					if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb or is_english) ):
-						output_line += u'\\lr{'
-					if ( line_direction_rtl and is_verb):
-						output_line += u'\\LR{'
-				
-				# here is the main place that converting happens
-				output_line += next_part.encode( 'utf-8' )
-				
-				if (global_state == 0):
-					# check whether we already used a \lr command: then end it
-					if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb or is_english) ):
-						output_line += u'}'
-					if ( line_direction_rtl and is_verb):
-						output_line += u'}'
-			else:
-				if (global_state == 0):
-					# whether we should put a \rl{} command
-					if ( not line_direction_rtl):
-						output_line += u'\\rl{'
-					
-				# here is the main place that converting happens
-				output_line += map_ft_unicode(next_part)
-				
-				if (global_state == 0):
-					# check whether we already used a \rl command: then end it
-					if (not line_direction_rtl):
-						output_line += u'}'
-					
-			i = next_part_index
-		# end of while			
-
-		#if there was a % commenting then we can return to normal situation
-		if (global_state == 1):
-			global_state = 0
-		
-		# convert some of the FarsiTeX commands to XePersian commands
-		# only if it is requested
-		if (convert_cmds):
-			result = translate_cmds(output_line) 
-		else:
-			result = output_line
-		output_line = result + u'\n'
-		# write the processed line
-		of.write(output_line)
-		# end of line processing
-	# end of file processing
-
-###################################
-# Begin of main body of the program
-###################################
-
-# global variables
-line_number = 0
-last_epsfxsize = u''
-last_epsfxsize_line = 0
-last_epsfysize = u''
-last_epsfysize_line = 0
-state = 0
-global_state = 0
-
-if len(sys.argv) <= 1:
-	print 'usage: python ftxe-0.6 in_filename'
-	exit(0)
-
-index = 0
-filenames = [sys.argv[1]]
-
-while (index < len(filenames)):
-	filename = filenames[index]
-	index += 1
-
-	outfile = ''
-	if (filename[-4:] != '.tex'):
-		outfile = filename[0:-3] + 'tex'
-	else: 
-		outfile = filename + '.tex'
-
-	print '\n\nConverting "' + filename + '" into "' + outfile + '"'
-	try:
-		f = open(filename, 'r')
-	except IOError:
-		print "Can not open the input file: " + filename
-		exit(0)
-
-	try:
-		of = codecs.open(outfile, encoding='utf-8', mode='w')
-	except IOError:
-		print "Can not open the output file: " + outfile
-		exit(0)
-
-	convert_file(f, of, 1)
-		
-	of.close()
-	f.close()	

Added: trunk/ftxe-0.8.py
===================================================================
--- trunk/ftxe-0.8.py	2009-06-24 04:37:11 UTC (rev 76)
+++ trunk/ftxe-0.8.py	2009-06-27 01:36:36 UTC (rev 77)
@@ -0,0 +1,980 @@
+?#########################################
+#       General Public License          #
+#       Author:  Mostafa Vahedi         #
+#       Date:    26 June 2009           #
+#       Version  0.8                    #
+#########################################
+
+import codecs
+
+import sys
+import os
+
+ft_numerical = [
+chr(0xB9),	# 	Arabic Thoushads Seperator
+chr(0xBC)	#	ARABIC DECIMAL SEPARATOR
+]
+
+
+ft_vowels = [
+chr(0xB0),	#	ARABIC FATHA
+chr(0xB1),	#	ARABIC KASRA
+chr(0xB2),	#	ARABIC DAMMA
+chr(0xB3),	#	ARABIC FATHATAN
+chr(0xB4),	#	ARABIC SHADDA
+chr(0xBA),	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB),	#	ARABIC HAMZA ABOVE
+chr(0xC4) 	#	ARABIC SUKUN
+]
+
+ft_non_joiners = [
+chr(0x8F)	#	ARABIC LETTER HAMZA
+]
+
+ft_bidi_joiners_initial = [
+chr(0xE4),	#	ARABIC LETTER AIN, initial form
+chr(0xE8),	#	ARABIC LETTER GHAIN, initial form
+chr(0xFB) 	#	ARABIC LETTER HEH, initial form
+]
+
+ft_bidi_joiners_medial = [
+chr(0xE3),	#	ARABIC LETTER AIN, medial form
+chr(0xE7),	#	ARABIC LETTER GHAIN, medial form
+chr(0xFA) 	#	ARABIC LETTER HEH, medial form
+]
+
+ft_bidi_joiners_final = [
+chr(0xE2),	#	ARABIC LETTER AIN, final form
+chr(0xE6),	#	ARABIC LETTER GHAIN, final form
+chr(0xFC) 	#	ARABIC LETTER FARSI YEH, final form
+]
+
+ft_bidi_joiners_isolated = [
+chr(0xE1),	#	ARABIC LETTER AIN, isolated form
+chr(0xE5),	#	ARABIC LETTER GHAIN, isolated form
+chr(0xFD) 	#	ARABIC LETTER FARSI YEH, isolated form
+]
+
+ft_bidi_joiners_initial_medial = [
+chr(0x8B),	#	ARABIC TATWEEL
+chr(0x8E),	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x93),	#	ARABIC LETTER BEH, initial-medial form
+chr(0x95),	#	ARABIC LETTER PEH, initial-medial form
+chr(0x97),	#	ARABIC LETTER TEH, initial-medial form
+chr(0x99),	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9B),	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9D),	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9F),	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA1),	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA8),	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xAA),	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAC),	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAE),	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF),	#	ARABIC LETTER TAH, initial-medial form
+chr(0xE0),	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xEA),	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEC),	#	ARABIC LETTER QAF, initial-medial form
+chr(0xEE),	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xF0),	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF3),	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF5),	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF7),	#	ARABIC LETTER NOON, initial-medial form
+chr(0xFE)	#	ARABIC LETTER FARSI YEH, initial-medial form
+]
+
+ft_bidi_joiners_final_isolated = [
+chr(0x92),	#	ARABIC LETTER BEH, final-isolated form
+chr(0x94),	#	ARABIC LETTER PEH, final-isolated form
+chr(0x96),	#	ARABIC LETTER TEH, final-isolated form
+chr(0x98),	#	ARABIC LETTER THEH, final-isolated form
+chr(0x9A),	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9C),	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9E),	#	ARABIC LETTER HAH, final-isolated form
+chr(0xA0),	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA7),	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA9),	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAB),	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAD),	#	ARABIC LETTER DAD, final-isolated form
+chr(0xC1),	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2),	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xE9),	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEB),	#	ARABIC LETTER QAF, final-isolated form
+chr(0xED),	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEF),	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF1),	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF4),	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF6),	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF9) 	#	ARABIC LETTER HEH, final-isolated form
+]
+
+ft_right_joiners_final = [
+chr(0x91)	#	ARABIC LETTER ALEF, final form
+]
+
+ft_right_joiners_isolated = [
+chr(0x8D),	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x90)	#	ARABIC LETTER ALEF, isolated form
+]
+
+ft_right_joiners_final_isolated = [
+chr(0xA2),	#	ARABIC LETTER DAL
+chr(0xA3),	#	ARABIC LETTER THAL
+chr(0xA4),	#	ARABIC LETTER REH
+chr(0xA5),	#	ARABIC LETTER ZAIN
+chr(0xA6),	#	ARABIC LETTER JEH
+chr(0xBF),	#	ARABIC LETTER TEH MARBUTAH
+chr(0xF2),	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF8)	#	ARABIC LETTER WAW
+]
+
+
+table_FT_UN = {
+chr(0x80) : [u'\u06F0'],	#	EXTENDED ARABIC-INDIC DIGIT ZERO
+chr(0x81) : [u'\u06F1'],	#	EXTENDED ARABIC-INDIC DIGIT ONE
+chr(0x82) : [u'\u06F2'],	#	EXTENDED ARABIC-INDIC DIGIT TWO
+chr(0x83) : [u'\u06F3'],	#	EXTENDED ARABIC-INDIC DIGIT THREE
+chr(0x84) : [u'\u06F4'],	#	EXTENDED ARABIC-INDIC DIGIT FOUR
+chr(0x85) : [u'\u06F5'],	#	EXTENDED ARABIC-INDIC DIGIT FIVE
+chr(0x86) : [u'\u06F6'],	#	EXTENDED ARABIC-INDIC DIGIT SIX
+chr(0x87) : [u'\u06F7'],	#	EXTENDED ARABIC-INDIC DIGIT SEVEN
+chr(0x88) : [u'\u06F8'],	#	EXTENDED ARABIC-INDIC DIGIT EIGHT
+chr(0x89) : [u'\u06F9'],	#	EXTENDED ARABIC-INDIC DIGIT NINE
+chr(0x8A) : [u'\u060C'],	#	ARABIC COMMA
+chr(0x8B) : [u'\u0640'],	#	ARABIC TATWEEL
+chr(0x8C) : [u'\u061F'],	#	ARABIC QUESTION MARK
+chr(0x8D) : [u'\u0622'],	#	ARABIC LETTER ALEF WITH MADDA ABOVE, isolated form
+chr(0x8E) : [u'\u0626'],	#	ARABIC LETTER YEH WITH HAMZA ABOVE, initial-medial form
+chr(0x8F) : [u'\u0621'],	#	ARABIC LETTER HAMZA
+chr(0x90) : [u'\u0627'],	#	ARABIC LETTER ALEF, isolated form
+chr(0x91) : [u'\u0627'],	#	ARABIC LETTER ALEF, final form
+chr(0x92) : [u'\u0628'],	#	ARABIC LETTER BEH, final-isolated form
+chr(0x93) : [u'\u0628'],	#	ARABIC LETTER BEH, initial-medial form
+chr(0x94) : [u'\u067E'],	#	ARABIC LETTER PEH, final-isolated form
+chr(0x95) : [u'\u067E'],	#	ARABIC LETTER PEH, initial-medial form
+chr(0x96) : [u'\u062A'],	#	ARABIC LETTER TEH, final-isolated form
+chr(0x97) : [u'\u062A'],	#	ARABIC LETTER TEH, initial-medial form
+chr(0x98) : [u'\u062B'],	#	ARABIC LETTER THEH, final-isolated form
+chr(0x99) : [u'\u062B'],	#	ARABIC LETTER THEH, initial-medial form
+chr(0x9A) : [u'\u062C'],	#	ARABIC LETTER JEEM, final-isolated form
+chr(0x9B) : [u'\u062C'],	#	ARABIC LETTER JEEM, initial-medial form
+chr(0x9C) : [u'\u0686'],	#	ARABIC LETTER TCHEH, final-isolated form
+chr(0x9D) : [u'\u0686'],	#	ARABIC LETTER TCHEH, initial-medial form
+chr(0x9E) : [u'\u062D'],	#	ARABIC LETTER HAH, final-isolated form
+chr(0x9F) : [u'\u062D'],	#	ARABIC LETTER HAH, initial-medial form
+chr(0xA0) : [u'\u062E'],	#	ARABIC LETTER KHAH, final-isolated form
+chr(0xA1) : [u'\u062E'],	#	ARABIC LETTER KHAH, initial-medial form
+chr(0xA2) : [u'\u062F'],	#	ARABIC LETTER DAL
+chr(0xA3) : [u'\u0630'],	#	ARABIC LETTER THAL
+chr(0xA4) : [u'\u0631'],	#	ARABIC LETTER REH
+chr(0xA5) : [u'\u0632'],	#	ARABIC LETTER ZAIN
+chr(0xA6) : [u'\u0698'],	#	ARABIC LETTER JEH
+chr(0xA7) : [u'\u0633'],	#	ARABIC LETTER SEEN, final-isolated form
+chr(0xA8) : [u'\u0633'],	#	ARABIC LETTER SEEN, initial-medial form
+chr(0xA9) : [u'\u0634'],	#	ARABIC LETTER SHEEN, final-isolated form
+chr(0xAA) : [u'\u0634'],	#	ARABIC LETTER SHEEN, initial-medial form
+chr(0xAB) : [u'\u0635'],	#	ARABIC LETTER SAD, final-isolated form
+chr(0xAC) : [u'\u0635'],	#	ARABIC LETTER SAD, initial-medial form
+chr(0xAD) : [u'\u0636'],	#	ARABIC LETTER DAD, final-isolated form
+chr(0xAE) : [u'\u0636'],	#	ARABIC LETTER DAD, initial-medial form
+chr(0xAF) : [u'\u0637'],	#	ARABIC LETTER TAH, initial-medial form
+chr(0xB0) : [u'\u064E'],	#	ARABIC FATHA
+chr(0xB1) : [u'\u0650'],	#	ARABIC KASRA
+chr(0xB2) : [u'\u064F'],	#	ARABIC DAMMA
+chr(0xB3) : [u'\u064B'],	#	ARABIC FATHATAN
+chr(0xB4) : [u'\u0651'],	#	ARABIC SHADDA
+chr(0xB5) : [u'\u0023'],	# * #
+chr(0xB6) : [u'\u0024'],	# * $
+chr(0xB7) : [u'\u0025'],	# * %
+chr(0xB8) : [u'\u0026'],	# * &
+chr(0xB9) : [u'\u066C'],	# 	Arabic Thoushads Seperator
+chr(0xBA) : [u'\u0670'],	#	ARABIC LETTER SUPERSCRIPT ALEF
+chr(0xBB) : [u'\u0654'],	#	ARABIC HAMZA ABOVE
+chr(0xBC) : [u'\u066B'],	#	ARABIC DECIMAL SEPARATOR
+chr(0xBD) : [u'\u0029'],	# * RIGHT PARENTHESIS
+chr(0xBE) : [u'\u0028'],	# * LEFT PARENTHESIS
+chr(0xBF) : [u'\u0629'],	#	ARABIC LETTER TEH MARBUTAH
+chr(0xC0) : [u'\u00BB'],	#	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC1) : [u'\u0637'],	#	ARABIC LETTER TAH, final-isolated form
+chr(0xC2) : [u'\u0638'],	#	ARABIC LETTER ZAH, final-isolated form
+chr(0xC3) : [u'\u00AB'],	#	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+chr(0xC4) : [u'\u0652'],	#	ARABIC SUKUN
+chr(0xC5) : [u'\u002D'],	# * -
+chr(0xC6) : [u'\u002E'],	# * FULL STOP
+chr(0xC7) : [u'\u002F'],	# * /
+chr(0xC8) : [u'\u002A'],	# * *
+chr(0xC9) : [u'\u007E'],	# * ~
+chr(0xCA) : [u'\u003A'],	# * COLON
+chr(0xCB) : [u'\u061B'],	# 	ARABIC SEMICOLON
+chr(0xCC) : [u'\u003E'],	# * GREATER-THAN SIGN
+chr(0xCD) : [u'\u002B'],	# * +
+chr(0xCE) : [u'\u003D'],	# * =
+chr(0xCF) : [u'\u003C'],	# * LESS-THAN SIGN
+# chr(0xD0) : [u'\u0040'],	# * @
+chr(0xD0) : [u''],	        # * @
+chr(0xD1) : [u'\u005D'],	# * [
+chr(0xD2) : [u'\u005C'],	# * \
+chr(0xD3) : [u'\u005B'],	# * ]
+chr(0xD4) : [u'\u005E'],	# * ^
+chr(0xD5) : [u'\u005F'],	# * _
+chr(0xD6) : [u'\u0060'],	# * `
+chr(0xD7) : [u'\u007D'],	# * {
+chr(0xD8) : [u'\u007C'],	# * |
+chr(0xDA) : [u'\u0020'],	# * SPACE
+chr(0xDD) : [u'\u0021'],	# * EXCLAMATION MARK
+chr(0xDE) : [u'\u007B'],	# * }
+chr(0xE0) : [u'\u0638'],	#	ARABIC LETTER ZAH, initial-medial form
+chr(0xE1) : [u'\u0639'],	#	ARABIC LETTER AIN, isolated form
+chr(0xE2) : [u'\u0639'],	#	ARABIC LETTER AIN, final form
+chr(0xE3) : [u'\u0639'],	#	ARABIC LETTER AIN, medial form
+chr(0xE4) : [u'\u0639'],	#	ARABIC LETTER AIN, initial form
+chr(0xE5) : [u'\u063A'],	#	ARABIC LETTER GHAIN, isolated form
+chr(0xE6) : [u'\u063A'],	#	ARABIC LETTER GHAIN, final form
+chr(0xE7) : [u'\u063A'],	#	ARABIC LETTER GHAIN, medial form
+chr(0xE8) : [u'\u063A'],	#	ARABIC LETTER GHAIN, initial form
+chr(0xE9) : [u'\u0641'],	#	ARABIC LETTER FEH, final-isolated form
+chr(0xEA) : [u'\u0641'],	#	ARABIC LETTER FEH, initial-medial form
+chr(0xEB) : [u'\u0642'],	#	ARABIC LETTER QAF, final-isolated form
+chr(0xEC) : [u'\u0642'],	#	ARABIC LETTER QAF, initial-medial form
+chr(0xED) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, final-isolated form
+chr(0xEE) : [u'\u06A9'],	#	ARABIC LETTER KEHEH, initial-medial form
+chr(0xEF) : [u'\u06AF'],	#	ARABIC LETTER GAF, final-isolated form
+chr(0xF0) : [u'\u06AF'],	#	ARABIC LETTER GAF, initial-medial form
+chr(0xF1) : [u'\u0644'],	#	ARABIC LETTER LAM, final-isolated form
+chr(0xF2) : [u'\u0644\u0627'],	#	ARABIC LIGATURE LAM WITH ALEF
+chr(0xF3) : [u'\u0644'],	#	ARABIC LETTER LAM, initial-medial form
+chr(0xF4) : [u'\u0645'],	#	ARABIC LETTER MEEM, final-isolated form
+chr(0xF5) : [u'\u0645'],	#	ARABIC LETTER MEEM, initial-medial form
+chr(0xF6) : [u'\u0646'],	#	ARABIC LETTER NOON, final-isolated form
+chr(0xF7) : [u'\u0646'],	#	ARABIC LETTER NOON, initial-medial form
+chr(0xF8) : [u'\u0648'],	#	ARABIC LETTER WAW
+chr(0xF9) : [u'\u0647'],	#	ARABIC LETTER HEH, final-isolated form
+chr(0xFA) : [u'\u0647'],	#	ARABIC LETTER HEH, medial form
+chr(0xFB) : [u'\u0647'],	#	ARABIC LETTER HEH, initial form
+chr(0xFC) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, final form
+chr(0xFD) : [u'\u06CC'],	#	ARABIC LETTER FARSI YEH, isolated form
+chr(0xFE) : [u'\u06CC']		#	ARABIC LETTER FARSI YEH, initial-medial form
+}
+
+F_SLASH = chr(0xD2)
+F_PRNT_OPEN = chr(0xDE)
+F_PRNT_CLOSE = chr(0xD7)
+F_AT_SIGN = chr(0xD0)
+F_PERCENT_SIGN = chr(0xB7)
+
+# latex and farsitex commands whose first parameter does not need \lr{...}
+commands = [ "begin", 
+"end",
+"input", "include", "includeonly",
+"hspace", "vspace", "hspace*", "vspace*",
+"label", "ref", "cite", "bibitem",
+"bibliographystyle",
+"parbox",
+"newenvironment", "newtheorem",
+"persianmathdigitsfamily",
+"fontfamily", "fontseries", "fontshape",
+"rmdefault", "sfdefault", "ttdefault",
+"bfdefault", "itdefault", "sldefault", "scdefault",
+"pagenumbering", "pagestyle", "thispagestyle",
+"setcounter", "stepcounter", "setlength", "addtolength"
+]
+
+
+def ft_is_numeric(ch):
+	if ((ch in ft_numerical) or 
+	    ((ch >= chr(0x80)) and (ch <= chr(0x89))) ):
+		return 1
+	return 0
+
+def ft_can_join_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_final) or
+	    (ch in ft_bidi_joiners_isolated) or
+	    (ch in ft_bidi_joiners_initial_medial) or
+	    (ch in ft_bidi_joiners_final_isolated)):
+    		return 1
+	return 0
+
+def ft_can_join_right(ch):
+	if (ft_can_join_left(ch) or 
+	    (ch in ft_right_joiners_final) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_right_joiners_final_isolated)):
+		return 1
+	return 0
+
+def ft_joining_left(ch):
+	if ((ch in ft_bidi_joiners_initial) or 
+	    (ch in ft_bidi_joiners_medial) or
+	    (ch in ft_bidi_joiners_initial_medial)):
+		return 1
+	return 0
+
+
+def ft_joining_right(ch):
+	if ((ch in ft_right_joiners_final) or
+	    (ch in ft_bidi_joiners_medial) or 
+	    (ch in ft_bidi_joiners_final)):
+		return 1
+	return 0
+
+def ft_not_right_joined(ch):
+	if ((ch in ft_bidi_joiners_initial) or
+	    (ch in ft_right_joiners_isolated) or
+	    (ch in ft_bidi_joiners_isolated)):
+		return 1
+	return 0
+
+def ft_adjust_shaping(text, i):
+	current = text[i]
+	u = u''
+	try:
+		u = table_FT_UN[current][0]
+	except KeyError:
+		return u''
+
+	#if you don't want shaping remove the following comment
+	#return u
+
+	if ((current in ft_vowels) or (ft_is_numeric(current))):
+		return u
+
+	#find next non-vowel character on the left
+	text_len = len(text)
+	next_index = i+1
+	while ((next_index < text_len) and (text[next_index] in ft_vowels)):
+		next_index += 1
+
+	if (next_index == text_len):
+		next = ''
+	else:
+		next = text[next_index]
+
+	# if current letter is joining from left but next letter is or can not joining
+	if (ft_joining_left(current)):
+		if (not ft_can_join_right(next)):
+			u += u'\u200D' #ZWJ
+		elif (ft_not_right_joined(next)):
+			u += u'\u200D\u200C' #ZWJ+ZWNJ
+	# if current letter can join but next letter is joining from right
+	elif (ft_can_join_left(current)):
+		if (ft_joining_right(next)):
+			u += u'\u200C\u200D' #ZWNJ+ZWJ
+		elif (ft_can_join_right(next)):
+			u += u'\u200C' #ZWNJ
+	return u
+
+def ft_adjust_number(text):
+	result = u''
+	i = len(text)-1
+	while (i >= 0):
+		result += ft_adjust_shaping(text, i)
+		i -= 1
+	return result
+
+
+def map_ft_unicode(text):
+	mapped_text = u''
+
+	i = 0
+	while (i < len(text)):
+		if (ft_is_numeric(text[i])):
+			next_index = i
+			while ((next_index+1 < len(text)) and
+			       (ft_is_numeric(text[next_index+1]))):
+				next_index += 1
+			mapped_text += ft_adjust_number(text[i:next_index+1])
+			i = next_index+1
+			continue
+
+		mapped_text += ft_adjust_shaping(text, i)
+		i += 1
+	return mapped_text
+
+# Finds next token all of the same language
+def ft_next_part(line, i, line_len):
+	global global_state
+	global recursive
+	global filenames
+	
+	j = i
+	language_flag = (line[j]<chr(0x80))
+	while ((j<line_len) and ((line[j]<chr(0x80)) == language_flag) ):
+		if ( (global_state == 0) and ( (line[j] == '%') or (line[j] == F_PERCENT_SIGN) ) and (line[j-1] != '\\') and (line[j-1] != F_SLASH) ):
+			global_state = 1
+		elif ((global_state == 0) and ((line[j:j+16] == '\\begin{verbatim}') or (line[j:j+17] == '\\begin{verbatim*}'))):
+			global_state = 2
+		elif ((global_state == 2) and ((line[j:j+14] == '\\end{verbatim}') or (line[j:j+15] == '\\end{verbatim*}'))):
+			global_state = 0
+		elif ((global_state == 0) and (line[j:j+6] == '\\verb*')):
+			next_index = line.find(line[j+6], j+7)
+			j = next_index
+		elif ((global_state == 0) and (line[j:j+5] == '\\verb')):
+			next_index = line.find(line[j+5], j+6)
+			j = next_index
+		elif (recursive == 1):
+			if ((global_state == 0) and (line[j:j+9] == '\\include{')):
+				next_index = line.find('}', j+9)
+				filename = line[j+10:next_index-1] + '.ftx'
+				if (os.path.exists(filename) and not filename in filenames):
+					filenames.append(filename)
+			elif ((global_state == 0) and (line[j:j+7] == '\\input{')):
+				next_index = line.find('}', j+7)
+				filename = line[j+8:next_index-1] + '.ftx'
+				if (os.path.exists(filename) and not filename in filenames):
+					filenames.append(filename)
+			elif ((global_state == 0) and (line[j:j+9] == F_SLASH + 'include' + F_PRNT_OPEN)):
+				next_index = line.find(F_PRNT_CLOSE, j+9)
+				if (line[j+9]!=F_AT_SIGN):
+					filename = line[j+9:next_index] + '.ftx'
+				else:
+					filename = line[j+10:next_index-1] + '.ftx'
+				if (os.path.exists(filename) and not filename in filenames):
+					filenames.append(filename)
+			elif ((global_state == 0) and (line[j:j+7] == F_SLASH + 'input' + F_PRNT_OPEN)):
+				next_index = line.find(F_PRNT_CLOSE, j+7)
+				if (line[j+7]!=F_AT_SIGN):
+					filename = line[j+7:next_index] + '.ftx'
+				else:
+					filename = line[j+8:next_index-1] + '.ftx'
+				if (os.path.exists(filename) and not filename in filenames):
+					filenames.append(filename)
+		j += 1
+	return j
+
+###############################################
+# from here all functions are used to translate
+# farsitex commands to xepersian commands
+###############################################
+
+def read_size(input,index,last_index):
+	dim_index = -1 
+	inch_index = input.find(u'in', index)
+	if (inch_index != -1):
+		dim_index = inch_index
+	mm_index = input.find(u'mm', index)
+	if (mm_index != -1):
+		if (dim_index == -1 or mm_index < index):
+			dim_index = mm_index
+	cm_index = input.find(u'cm', index)
+	if (cm_index != -1):
+		if (dim_index == -1 or cm_index < dim_index):
+			dim_index = cm_index
+	pt_index = input.find(u'pt', index)
+	if (pt_index != -1):
+		if (dim_index == -1 or pt_index < dim_index):
+			dim_index = pt_index
+	next_cmd = input.find(u'\\', index)
+	if (next_cmd == -1 and dim_index == -1):
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+	elif (next_cmd == -1 or (dim_index != -1 and next_cmd > dim_index)):
+		epsfxsize = input[index:dim_index+2]
+		return dim_index+2
+	elif (next_cmd != -1):
+		end_cmd = next_cmd+1
+		while (end_cmd < last_index and input[end_cmd].isalpha()):
+			end_cmd += 1
+		return end_cmd
+	else:
+		print "Error in parsing \epsfxsize command at " + str(line_number) + "\n"
+		return -1
+
+
+latex_options=[u'a4paper', u'a5paper', u'b5paper', 
+			   u'letterpaper', u'legalpaper', u'executivepaper', 
+			   u'landscape', u'10pt', u'11pt', u'12pt', 
+			   u'oneside', u'twoside', u'draft', 
+			   u'final', u'titlepage', u'notitlepage',
+			   u'onecolumn', u'twocolumn',
+			   u'leqno', u'fleqn']
+
+table_eq_packages = {
+u'poem'     : u'persianpoem',
+u'fmakeidx' : u'makeidx',
+u'ffancyhe' : u'fancyhdr',
+u'fmultico' : u'multicol'
+}
+
+farsitex_ignore_options = [u'persian', u'farsi', u'epsf', u'fgraphix', u'lotusfont']
+
+xepersian_packages = u'\n\\usepackage{url}\n\\usepackage{fancyvrb}\n\\usepackage{setspace}\\doublespace\n\\usepackage{graphicx}\n\\usepackage{amssymb}\n'
+xepersian_preamble = u'\\settextfont[Scale=1.2]{XB Zar}\n\\setlatintextfont[Scale=1.1]{Times New Roman}\n\\setdigitfont{XB Zar}\n\\let\\iranic\\it\n\\let\\siah\\bf\n\\let\\khabide\\sl\n\\def\\siahir{\\siah\\iranic}\n\\def\\siahkh{\\siah\\khabide}\n\\setpookfont{XB Kayhan Pook}\\let\\tookhali\\pookfamily\n\\setsayehfont{XB Kayhan Sayeh}\\let\\sayedar\\sayehfamily\n\\let\\farsi\\Persian\n\\let\\english\\Latin \n\\let\\farmbox\\mbox\n\\newcommand{\\ftxepmatrix}[1]{\\begin{pmatrix}#1\\end{pmatrix}}\n\\def\\FarsiTeX{\\lr{FarsiTeX}}\n\\def\\????????{\\rl{?????????}} \n\\let\\englishtitle\\latintitle\n\\let\\englishauthor\\latinauthor\n\\let\\englishdegree\\latindegree\n\\let\\englishthesisdate\\latinthesisdate \n\\let\\englishsupervisor\\latinsupervisor\n\\let\\englishdepartment\\latindepartment\n\\let\\makeenglishtitle\\makelatintitle \n\\let\\englishkeywords\\latinkeywords\n\\newenvironment{englishabstract}{\\begin{latinabstract}}{\\end{latinabstract}}\n \\u!
 niversity{\lr{University Name}} \n\\city{\lr{City Name}}\n\\latinuniversity{University Name}\n\\latincity{City Name}\n'
+
+def is_alpha_numeric_space(input):
+	input_len = len(input)
+	i = 0
+	while (i<input_len):
+		if (not (input[i].isalpha() or input[i].isdigit() or input[i]==u'.' or input[i]==u' ') ):
+			return 0
+		i+=1
+	return 1
+
+def is_alpha_numeric(input):
+	input_len = len(input)
+	i = 0
+	while (i<input_len):
+		if (not (input[i].isalpha() or input[i].isdigit() or input[i]=='.') ):
+			return 0
+		i+=1
+	return 1
+			
+def find_eq_cmd(keyword):
+	try:
+		eq_cmd = table_eq_packages[keyword]
+	except KeyError:
+		eq_cmd = u''
+	return eq_cmd
+
+def convert_persian_to_english(num):
+	result = u''
+	num_len = len(num)
+	index = 0
+	while (index < num_len):
+		if (ord(num[index]) >= ord(u'?') and ord(num[index]) <= ord(u'?')):
+			result += unichr(ord(num[index]) - ord(u'?') + ord(u'0'))
+		else:
+			result += num[index]
+		index += 1
+	return result
+
+def generate_farsitex_cmds_file(helper_filename,preamble):
+	try:
+		of = codecs.open(helper_filename, encoding='utf-8', mode='w')
+	except IOError:
+		print "Can not open the output file: " + helper_filename
+		exit(0)
+	of.write(preamble)
+	of.close
+
+
+# \verb|| -> \item[\verb||] or \section{\verb||}
+# \kasre{} \alef{} ...
+def translate_cmds(output_line):
+	global last_epsfxsize
+	global last_epsfxsize_line
+	global last_epsfysize
+	global last_epsfysize_line
+	global state
+	global filename
+
+	result = u''
+	line_len = len(output_line)
+	index = 0
+	if (state == 1): #\begin{verbatim}
+		end_verbatim = output_line.find('\\end{verbatim}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+14]
+		index = end_verbatim+14
+		state = 0
+	elif (state == 2): #\begin{verbatim*}
+		end_verbatim = output_line.find('\\end{verbatim*}')
+		if (end_verbatim == -1):
+			return output_line
+		result += output_line[0:end_verbatim+15]
+		index = end_verbatim+15
+		state = 0
+	elif (output_line[0:14] == "\\documentstyle"):
+		result += u'\\documentclass'
+		#process options
+		last_index = output_line.find(u']')
+		index = 15
+		first_option = 1
+		preamble = xepersian_preamble
+		packages = xepersian_packages
+		document_class = u''
+		while (index < last_index):
+			next_comma = output_line.find(u',',index,last_index)
+			if (next_comma == -1):
+				next_comma = last_index
+			first_of_option = index
+			while (output_line[first_of_option] == u' '):
+				first_of_option += 1
+			end_of_option = next_comma
+			while (output_line[end_of_option-1] == u' '):
+				end_of_option -= 1
+			option = output_line[first_of_option:end_of_option]
+			index = next_comma+1
+			eq_cmd = find_eq_cmd(option)
+			if (eq_cmd != u''):
+				packages += u'\\usepackage{' + eq_cmd + u'}\n'
+				continue
+			elif (option in farsitex_ignore_options):
+				continue
+			elif (option == u'sharifth'):
+				document_class = u'xepersian-thesis'
+				continue
+			elif (not option in latex_options):
+				packages += u'\\usepackage{' + option + u'}\n'
+				continue
+	
+			if (first_option):
+				result += u'['
+			else:
+				result += u','
+			result += option
+			first_option = 0
+		#end while
+		if (not first_option):
+			result += u']'
+		index = output_line.find(u'}',last_index)
+		if (document_class == u''):
+			result += output_line[last_index+1:index+1]
+		else:
+			result += u'{' + document_class + u'}'
+		# I assume that nothing important is after
+		# \documentstyle[]{}, otherwise it may conflict
+		# with our preamble
+		if (index != -1):
+			result += output_line[index+1:]
+		result += packages + u'\\usepackage{xepersian}\n'
+		helper_filename = filename + '_farsitex_cmds_xepersian.tex'
+		generate_farsitex_cmds_file(helper_filename,preamble)
+		result += '\\input{' + helper_filename + '}\n'
+		return result
+	#end elif "documentstyle"
+
+	while (index < line_len):
+		next_index = output_line.find(u'\\', index)
+		comment_index = output_line.find(u'%', index)
+		if (next_index == -1):
+			result += output_line[index:]
+			break
+		elif (state == 1):
+			if (output_line[next_index:next_index+14] == u'\\end{verbatim}'):
+				result += output_line[index:next_index+14]
+				index = next_index+14
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (state == 2):
+			if (output_line[next_index:next_index+15] == u'\\end{verbatim*}'):
+				result += output_line[index:next_index+15]
+				index = next_index+15
+				state = 0
+			else:
+				result += output_line[index:next_index+1]
+				index = next_index+1
+		elif (comment_index != -1 and comment_index < next_index):
+			result += output_line[index:]
+			break
+		elif (output_line[next_index:next_index+14] == u"\\input{amssym}"):
+			result += u'\\usepackage{amssymb}'
+			index = next_index+14
+		elif (output_line[next_index:next_index+12] == u"\\input{epsf}"):
+			index = next_index+12
+		elif (output_line[next_index:next_index+15] == u"\\includeepspdf{"):
+			result += u'\\includegraphics{'
+			index = next_index+15
+		elif (output_line[next_index:next_index+16] == u"\\begin{verbatim}"):
+			result += output_line[index:next_index+16]
+			index = next_index+16
+			state = 1
+		elif (output_line[next_index:next_index+17] == u"\\begin{verbatim*}"):
+			result += output_line[index:next_index+17]
+			index = next_index+17
+			state = 2
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\headrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\headrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+26] == u'\\setlength{\\footrulewidth}'):
+			end_cmd = output_line.find('}', next_index+26)
+			result += u'\\renewcommand{\\footrulewidth}' + output_line[next_index+26:end_cmd+1]
+			index = end_cmd+1
+		elif (output_line[next_index:next_index+10] == u"\\epsffile{"):
+			result += output_line[index:next_index]
+			result += u'\\includegraphics'
+			size_options = u''
+			if (line_number - last_epsfxsize_line <= 3):
+				size_options = u'width=' + last_epsfxsize
+			if (line_number - last_epsfysize_line <= 3):
+				if (size_options != u''):
+					size_options += u','
+				size_options += u'height=' + last_epsfysize
+			if (size_options != u''):
+				result += u'[' + size_options + u']'
+			end_prn = output_line.find(u'.eps}', next_index+9)
+
+			if (end_prn != -1):
+				result += output_line[next_index+9:end_prn] + u'}'
+				index = end_prn+5
+			else:
+				end_prn = output_line.find(u'.ps}', next_index+9)
+				if (end_prn != -1):
+					result += output_line[next_index+9:end_prn] + u'}'
+					index = end_prn+4
+				else:
+					end_prn = output_line.find(u'}', next_index+9)
+					result += output_line[next_index+9:end_prn+1]
+					index = end_prn+1
+		# I assume all the parameter of \epsfxsize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfxsize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfxsize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfxsize_line = line_number
+		# I assume all the parameter of \epsfysize comes in one line
+		elif (output_line[next_index:next_index+11] == u"\\epsfysize="):
+			end_size = read_size(output_line, next_index+11, line_len)
+			if (end_size != -1):
+				last_epsfysize = output_line[next_index+11:end_size]
+				index = end_size
+			else:
+				index = next_index+11
+			last_epsfysize_line = line_number
+		elif (output_line[next_index:next_index+10] == u"\\LR{\\verb*"):
+			end_verb = output_line.find(output_line[next_index+10], next_index+11)
+			verb_param = output_line[next_index+11:end_verb]
+			if (is_alpha_numeric(verb_param)):
+				result += output_line[index:next_index]
+				result += u'\\lr{\\tt{}' + verb_param
+			else:
+				result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+9] == u"\\LR{\\verb"):
+			end_verb = output_line.find(output_line[next_index+9], next_index+10)
+			verb_param = output_line[next_index+10:end_verb]
+			if (is_alpha_numeric_space(verb_param)):
+				result += output_line[index:next_index]
+				result += u'\\lr{\\tt{}' + verb_param
+			else:
+				result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+6] == u"\\verb*"):
+			end_verb = output_line.find(output_line[next_index+6], next_index+7)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+5] == u"\\verb"):
+			end_verb = output_line.find(output_line[next_index+5], next_index+6)
+			result += output_line[index:end_verb+1]
+			index = end_verb+1
+		elif (output_line[next_index:next_index+9] == u"\\pmatrix{"):
+			result += u'\\ftxepmatrix{'
+			index = next_index+9
+		elif (output_line[next_index:next_index+16] == u"\\begin{document}"):
+			result += u'\\begin{document}\n\\VerbatimFootnotes'
+			index = next_index+16
+		elif (output_line[next_index:next_index+12] == u'\\setcounter{'):
+			begin_num = output_line.find(u'{', next_index+12)
+			end_num = output_line.find(u'}', begin_num)
+			num = convert_persian_to_english(output_line[begin_num+1:end_num])
+			result += output_line[index:begin_num+1]
+			result += num + u'}'
+			index = end_num+1
+		elif (output_line[next_index:next_index+14] == u'\\addtocounter{'):
+			begin_num = output_line.find(u'{', next_index+14)
+			end_num = output_line.find(u'}', begin_num)
+			num = convert_persian_to_english(output_line[begin_num+1:end_num])
+			print 'HI:'
+			print num
+			result += output_line[index:begin_num+1]
+			result += num + u'}'
+			index = end_num+1
+		elif (output_line[next_index:next_index+13] == u'\\multicolumn{'):
+			begin_num = next_index+13
+			end_num = output_line.find(u'}', begin_num)
+			num = convert_persian_to_english(output_line[begin_num:end_num])
+			result += output_line[index:begin_num]
+			result += num + u'}'
+			index = end_num+1
+		else:
+			result += output_line[index:next_index+2]
+			index = next_index+2
+	#end while
+	return result
+
+###############################################
+# from here all functions are mainly used to
+# convert farsitex format to unicode
+###############################################
+
+def convert_file(f, of, convert_cmds):
+	global state
+	global line_number
+	global last_epsfysize_line
+	global last_epsfxsize_line
+	global last_epsfxsize
+	global last_epsfysize
+	global global_state
+
+	state = 0
+	line_number = 0
+	last_epsfysize_line = 0
+	last_epsfxsize_line = 0
+	last_epsfxsize = u''
+	last_epsfysize = u''
+
+	for line in f:
+		line_number += 1
+		print line_number,
+		output_line = u''
+		line_len = len(line)
+		
+		# remove new-line characters from end of line
+		if (line_len>1 and line[line_len-1] == '\n'):
+			line_len-=1
+		if (line_len>1 and line[line_len-1] == '\r'):
+			line_len-=1
+		
+		# check line-direction character
+		line_direction_rtl = (line[0] == '<')
+		if (line[0] != '>') and (line[0] != '<'):
+			print "FORMAT ERROR AT LINE: " + str(line_number)
+			exit(0)
+	
+		i = 1
+	
+		while (i<line_len):
+			next_part_index = ft_next_part(line, i, line_len)
+			next_part = line[i:next_part_index]
+			next_part_latin = (line[i]<chr(0x80))
+			
+			# see if we should put \lr{...} for the current english expression
+			if (global_state == 0):
+				if line_direction_rtl and next_part_latin:
+					is_command_rtl = (next_part_latin and (i>1) and (line[i-1]==F_SLASH) )
+					is_parameter_rtl = (next_part_latin and (i>1) and (next_part_index<line_len) and (line[i-1]==F_AT_SIGN) and (line[next_part_index]==F_AT_SIGN) )
+					is_math_rtl = (next_part_latin and (line[i]=="$") and (line[next_part_index-1]=="$") )
+					is_verb_parameter = ( (line[i-6:i] == F_SLASH+"verb") and not isalpha(line[i]))
+					is_verb = (next_part_latin and (line[i:i+5]=='\\verb' or line[i:i+6]==' \\verb'))
+					is_english = (next_part_latin and (line[i:i+8]=='\\english'))
+				
+					cmd_index = 0
+					while cmd_index < len(commands):
+						len_cmd = len(commands[cmd_index])+2
+						if ( (i > len_cmd) and (line[i-len_cmd:i] == F_SLASH+commands[cmd_index]+F_PRNT_OPEN) ):
+							break
+						cmd_index += 1
+					is_commands_group = cmd_index < len(commands)
+					is_documentstyle_cmd = (line_len > 15) and (line[1:15] == F_SLASH+"documentstyle")
+	
+			if next_part_latin:
+				if (global_state == 0):
+					# whether we should put a \lr{ command
+					if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb or is_english) ):
+						output_line += u'\\lr{'
+					if ( line_direction_rtl and is_verb):
+						output_line += u'\\LR{'
+				
+				# here is the main place that converting happens
+				output_line += next_part.encode( 'utf-8' )
+				
+				if (global_state == 0):
+					# check whether we already used a \lr command: then end it
+					if ( line_direction_rtl and not (is_command_rtl or is_parameter_rtl or is_math_rtl or is_commands_group or is_documentstyle_cmd or is_verb_parameter or is_verb or is_english) ):
+						output_line += u'}'
+					if ( line_direction_rtl and is_verb):
+						output_line += u'}'
+			else:
+				if (global_state == 0):
+					# whether we should put a \rl{} command
+					if ( not line_direction_rtl):
+						output_line += u'\\rl{'
+					
+				# here is the main place that converting happens
+				output_line += map_ft_unicode(next_part)
+				
+				if (global_state == 0):
+					# check whether we already used a \rl command: then end it
+					if (not line_direction_rtl):
+						output_line += u'}'
+					
+			i = next_part_index
+		# end of while			
+
+		#if there was a % commenting then we can return to normal situation
+		if (global_state == 1):
+			global_state = 0
+		
+		# convert some of the FarsiTeX commands to XePersian commands
+		# only if it is requested
+		if (convert_cmds):
+			result = translate_cmds(output_line) 
+		else:
+			result = output_line
+		output_line = result + u'\n'
+		# write the processed line
+		of.write(output_line)
+		# end of line processing
+	# end of file processing
+
+def print_usage():
+	print 'usage: python ftxe-0.6 [-r] [-s] [-x] [-u] in_filename1 in_filename2'
+	print '-r: (DEFAULT) recursively consider files included in the given files'
+	print '-s: do not recursively consider files'
+	print '-x: (DEFAULT) insert xepersian related commands'
+	print '-u: only convert to unicode'
+
+###################################
+# Begin of main body of the program
+###################################
+
+# global variables
+line_number = 0
+last_epsfxsize = u''
+last_epsfxsize_line = 0
+last_epsfysize = u''
+last_epsfysize_line = 0
+state = 0
+global_state = 0
+recursive = 1
+convert_xepersian = 1
+filename = ''
+
+if len(sys.argv) <= 1:
+	print_usage()
+	exit(0)
+
+#find options
+options_index = 1
+while (options_index < len(sys.argv) and sys.argv[options_index][0]=='-'):
+	if (sys.argv[options_index]=='-s'):
+		recursive = 0
+	elif (sys.argv[options_index]=='-u'):
+		convert_xepersian = 0
+	options_index += 1
+
+filenames = []
+while (options_index < len(sys.argv)):
+	filenames.append(sys.argv[options_index])
+	options_index += 1
+
+if (len(filenames) == 0):
+	print 'error: no input filename is specified!'
+	print_usage()
+	exit(0)
+	
+index = 0
+while (index < len(filenames)):
+	filename = filenames[index]
+	index += 1
+
+	outfile = ''
+	if (filename[-4:] != '.tex'):
+		outfile = filename[0:-3] + 'tex'
+	else: 
+		outfile = filename + '.tex'
+
+	print '\n\nConverting "' + filename + '" into "' + outfile + '"'
+	try:
+		f = open(filename, 'r')
+	except IOError:
+		print "Can not open the input file: " + filename
+		exit(0)
+
+	try:
+		of = codecs.open(outfile, encoding='utf-8', mode='w')
+	except IOError:
+		print "Can not open the output file: " + outfile
+		exit(0)
+
+	convert_file(f, of, convert_xepersian)
+
+	of.close()
+	f.close()	



